# 分析
注意以下两个代码在处理数组时的特点。其中计算二叉树的节点再开辟更为节约空间。

# code
```c 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
//计算节点数，方便开空间
 int TreeSize(struct TreeNode* root)
{
    if(root == NULL)
        return 0;
    return TreeSize(root->left)
        + TreeSize(root->right) + 1;
}

 typedef struct TreeNode TreeNode;
 void postoder(TreeNode* root,int* res,int* resSize)
 {
    if(root == NULL) return NULL;//空树
     
    postoder(root->left,res,resSize);//
    postoder(root->right,res,resSize);//
    res[(*resSize)++] = root->val;//
 }
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    *returnSize = TreeSize(root);
    int *res = (int *)malloc(sizeof(int)*(*returnSize));//开辟树大小的空间
    int *a = 0;
    postoder(root,res,&a);//函数实现

    return res;//返回数组
}
```

```c 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 typedef struct TreeNode TreeNode;
 void postoder(TreeNode* root,int* res,int* resSize)
 {
    if(root == NULL) return NULL;//空树
     
    postoder(root->left,res,resSize);//
    postoder(root->right,res,resSize);//
    res[(*resSize)++] = root->val;//
 }
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int *res = malloc(sizeof(int)*2000);
    *returnSize = 0;
    postoder(root,res,returnSize);//函数实现

    return res;//返回数组
}
```