# 思路
+ 编写height函数计算深度
+ 依次求出左右子树中的高度
+ abs绝对值控制左右子树的深度之差小于等于1
+ 求出左右子树中最大深度+1返回，加1表示是从根开始算深度
+ 最后函数调用判断树的深度
# code

```c 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

int height(struct TreeNode* root)
{
    if(root == NULL) return 0;//空树，返回节点深度为0，
    int HeightLeft = height(root->left);
    int HeightRight = height(root->right);
    //判断左右子树深度之差小于等于1，左右子树至少高为0
    if(HeightLeft >= 0 && HeightRight >= 0 && abs(HeightLeft-HeightRight)<=1){
        return fmax(HeightLeft,HeightRight)+1;//左右子树中较高的+1，即为从根开始算的深度
    }
    else{
        return -1;
    }
}
bool isBalanced(struct TreeNode* root){
    return height(root) >= 0;//应该是0，因为空时返回也是0
}
```