# code

```c 
typedef int STDataType;
struct Stack{
	STDataType *a;
	int top; //
	int capacity; //方便扩容
};

typedef struct Stack  Stack;

void StackInit(Stack* pst);
void StackDestory(Stack* pst);
//栈顶出入数据
void StackPush(Stack* pst, STDataType x);
void StackPop(Stack* pst);
STDataType StackTop(Stack *pst);
//空返回1 非空返回0
//int StackEmpty(Stackt* pst);
bool StackEmpty(Stack* pst);

int StackSize(Stack *pst);

//初始化
void StackInit(Stack* pst)
{
	//assert(pst);
	//pst->a = NULL;
	//pst -> top = 0;
	//pst->capacity = 0;

	//way2
	pst->a = (STDataType *)malloc(sizeof(STDataType) * 4);
	pst->top = 0;
	pst->capacity = 4;

}
//栈销毁
void StackDestory(Stack* pst)
{
	assert(pst);
	free(pst->a);
	pst->a = NULL; //销毁数据
	pst->capacity = pst->top = 0;//销毁指针
}
//入栈
void StackPush(Stack*pst, STDataType x)
{
	assert(pst);
	if (pst->top == pst->capacity){
		//满了，需扩容
		STDataType* tmp = (STDataType*)realloc(pst->a,sizeof(STDataType)*pst->capacity * 2);
		if (tmp == NULL){
			printf("realloc fail\n");
			exit(-1);//结束整个程序
		}
		pst->a = tmp;
		pst->capacity *= 2;//扩容
	}
	pst->a[pst->top] = x;//栈顶插入
	pst->top++;//栈顶移动
}
//出栈
void StackPop(Stack* pst)
{
	assert(pst);
	assert(!StackEmpty(pst));//保证栈不空
	pst->top--;
}
//返回栈顶元素
STDataType StackTop(Stack *pst)
{
	assert(pst);
	assert(!StackEmpty(pst));//抱枕栈不空
	return pst->a[pst->top - 1];//栈顶top指针指向下一位，减一就为栈顶
}
//栈是否为空
bool StackEmpty(Stack* pst)
{
	assert(pst);

	return pst->top == 0;
}
//栈大小
int StackSize(Stack *pst)
{
	assert(pst);
	return pst->top;
}

//定义两个栈
typedef struct {
    Stack pushST;
    Stack popST;
} MyQueue;

/** Initialize your data structure here. */

MyQueue* myQueueCreate() {
    MyQueue* q = (MyQueue*)malloc(sizeof(MyQueue));
    StackInit(&q->pushST);
    StackInit(&q->popST);

    return q;
}

/** Push element x to the back of queue. */
void myQueuePush(MyQueue* obj, int x) {
    StackPush(&obj->pushST,x);//入栈
}

/** Removes the element from in front of queue and returns that element. */
int myQueuePop(MyQueue* obj) {
    int top = myQueuePeek(obj);
    StackPop(&obj->popST);
    return top;
}

/** Get the front element. */
int myQueuePeek(MyQueue* obj) {
    if(StackEmpty(&obj->popST))
    {
        while(!StackEmpty(&obj->pushST))
        {
            //pushST 不空，入栈
            StackPush(&obj->popST,StackTop(&obj->pushST));
            StackPop(&obj->pushST);
        }
    }
    return StackTop(&obj->popST);
}

/** Returns whether the queue is empty. */
bool myQueueEmpty(MyQueue* obj) {
    return StackEmpty(&obj->pushST) && StackEmpty(&obj->popST);
}

void myQueueFree(MyQueue* obj) {
    StackDestory(&obj->pushST);
    StackDestory(&obj->popST);
    free(obj);
    obj = NULL;
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/


```