989 测试

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* addToArrayForm(int* num, int numSize, int k, int* returnSize){
    
    int ksize = 0;
    int kNum = k;

   // *returnSize = 0;
    //判断num数字有多少位，存到ksize中
    while(k){//34
        ++ksize;//2
        k/=10;
    }
    printf("ksize : %d\n", ksize);
    //判断数字位数和数组位数那个大，返回值+1，防止越界
    int len = ksize > numSize ? ksize+1 : numSize+1;
    printf("len : %d\n",len);
    int * retArr = (int *)malloc(sizeof(int)*len);

    int Ai = numSize -1; //数组
    printf("numSize: %d,Ai: %d",numSize,Ai);
    int Ki = 0;
    int next = 0;//进位
    int reti = 0;//先放的数组
    while(Ai>=0 || Ki < ksize){//数组位数有1位或者更多，或者，数字位数小于上面计算
        int aVal = 0;
        if(Ai >= 0)
            aVal = num[Ai--];//存数组中值
        int kVal = kNum%10;//存数字值
        kNum /= 10;
        Ki++;//数字位数

        int ret = aVal + kVal + next;//第一次进位为0
        if(ret >= 10){//有进位            
            next = 1;
            ret -= 10;
        } 
        else{//无进位            
            next = 0;
        }
        //倒着放，然后逆置
        retArr[reti++] = ret;//传递进位标志   
    }

    if(next == 1)//还有进位
        retArr[reti++] = 1;

    //逆置
    int left = 0;
    int right = reti - 1;
    while (left < right){
        int temp = retArr[left];
        retArr[left] = retArr[right];
        retArr[right] = temp;
        left++;
        right--;
    }

    *returnSize = reti;//数据个数
    return retArr;
}
```



```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* addToArrayForm(int* num, int numSize, int k, int* returnSize){
    
    int ksize = 0;
    int kNum = k;
    //判断num数字有多少位，存到ksize中
    while(kNum){//34
        ++ksize;//2
        kNum/=10;
    }
    //判断数字位数和数组位数那个大，返回值+1，防止越界
    int len = ksize > numSize ? ksize+1 : numSize+1;
    int * retArr = (int *)malloc(sizeof(int)*len);
    *returnSize = 0;
    
    for(int Ai =numSize-1; Ai >= 0;--Ai)
    {
        int sum = num[Ai] + k % 10;//从后往前加，从前往后放
        k /= 10;
        if(sum>=10)
        {
            k++;//19/10 = 1 进位 +1 =2 ，巧妙处理进位
            sum -= 10;//减10 就是进位后的值
        }  
        retArr[(*returnSize)++] = sum;//从前往后放
    }

    for(;k>0;k/=10)
    {
        retArr[(*returnSize)++] = k %10;
    }
    
     //逆置
    int left = 0;
    int right = (*returnSize)- 1;
    while (left < right){
        int temp = retArr[left];
        retArr[left] = retArr[right];
        retArr[right] = temp;
        left++;
        right--;
    }
    return retArr;
}

```

![测试插图](https://images.gitee.com/uploads/images/2021/0414/211726_57885012_3043085.png "屏幕截图.png")