# code
## 思路一：递归
```c
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){
    if(l1 == NULL){
        return l2;
    }
    else if(l2 == NULL){
        return l1;
    }
    else if(l1->val < l2->val){
        l1->next = mergeTwoLists(l1->next,l2);
        return l1;
    }
    else{//l2 small
        l2->next = mergeTwoLists(l1,l2->next);
        return l2;
    }
}

```
## 思路二：哨兵位头节点
```c

struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){
    struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
    struct ListNode* cur = head;

    while(l1 && l2){
        if(l1->val < l2->val){
            cur->next =l1;
            l1 = l1->next;
        }
        else{
            cur->next = l2;
            l2 = l2->next;
        }
        cur = cur->next;
    }

    if(l1 == NULL) cur->next = l2;
    else if(l2 == NULL) cur ->next =l1;
    return head->next;
}
```
## 思路三： 双指针

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){
    if(l1 == NULL) return l2;
    if(l2 == NULL) return l1;

    struct ListNode* head = NULL,*tail = NULL;
    //处理head 和 tail 与两个链表之间关系。
    if(l1->val < l2->val){
        head = tail = l1;
        l1 = l1->next;
    }
    else{
        head = tail = l2;
        l2 = l2->next;
    }

    while(l1 && l2){
        if(l1->val < l2->val){
            tail->next = l1;//小的尾插
            l1 = l1->next;
        }
        else{
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    //剩余部分尾插
    if(l1) tail->next = l1;
    if(l2) tail->next = l2;
    return head;
}
```



# 题目及分析
![输入图片说明](https://images.gitee.com/uploads/images/2021/0420/220152_508f1428_3043085.png "21合并两个有序链表.png")
## 思路一：递归

## 思路二：哨兵位头节点

## 思路三：双指针


