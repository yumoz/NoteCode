{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"LeetCode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/","text":"138 \u590d\u5236\u5e26\u968f\u673a\u6307\u9488\u7684\u94fe\u8868 \u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u6bcf\u4e2a\u8282\u70b9\u5305\u542b\u4e00\u4e2a\u989d\u5916\u589e\u52a0\u7684\u968f\u673a\u6307\u9488\uff0c\u8be5\u6307\u9488\u53ef\u4ee5\u6307\u5411\u94fe\u8868\u4e2d\u7684\u4efb\u4f55\u8282\u70b9\u6216\u7a7a\u8282\u70b9\u3002 \u8981\u6c42\u8fd4\u56de\u8fd9\u4e2a\u94fe\u8868\u7684 \u6df1\u62f7\u8d1d\u3002 \u6211\u4eec\u7528\u4e00\u4e2a\u7531 n \u4e2a\u8282\u70b9\u7ec4\u6210\u7684\u94fe\u8868\u6765\u8868\u793a\u8f93\u5165/\u8f93\u51fa\u4e2d\u7684\u94fe\u8868\u3002\u6bcf\u4e2a\u8282\u70b9\u7528\u4e00\u4e2a [val, random_index] \u8868\u793a\uff1a val\uff1a\u4e00\u4e2a\u8868\u793a Node.val \u7684\u6574\u6570\u3002 random_index\uff1a\u968f\u673a\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\u7d22\u5f15\uff08\u8303\u56f4\u4ece 0 \u5230 n-1\uff09\uff1b\u5982\u679c\u4e0d\u6307\u5411\u4efb\u4f55\u8282\u70b9\uff0c\u5219\u4e3a null \u3002 \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/copy-list-with-random-pointer \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 test \u4ee3\u7801 /** * Definition for a Node. * struct Node { * int val; * struct Node *next; * struct Node *random; * }; */ typedef struct Node Node; struct Node* copyRandomList(struct Node* head) { if(head == NULL) return NULL; //1.\u62f7\u8d1d\u8282\u70b9\u8fde\u63a5\u5230\u539f\u8282\u70b9\u540e\u9762 Node* cur = head; while(cur) { Node* copy = (Node*)malloc(sizeof(Node)); copy->next = NULL; copy->random = NULL; copy->val = cur->val; Node* next = cur->next;//copy cur->next=copy; copy->next= next; cur=next;//\u8fed\u4ee3 } //2.\u5904\u7406\u4e00\u4e0b\u62f7\u8d1d\u8282\u70b9\u7684random cur = head; while(cur){ Node* copy =cur->next; if(cur->random) copy->random=cur->random->next; else copy->random=NULL; cur=cur->next->next; } //3.\u62c6\u89e3\u51fa\u590d\u5236\u94fe\u8868 cur = head; Node* copyHead=head->next; while(cur){ Node* copy=cur->next; Node* next=copy->next; cur->next=next; if(next) copy->next=next->next; else copy->next=NULL; cur=next; } return copyHead; }","title":"138 \u590d\u5236\u5e26\u968f\u673a\u6307\u9488\u7684\u94fe\u8868"},{"location":"LeetCode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/#138","text":"\u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u6bcf\u4e2a\u8282\u70b9\u5305\u542b\u4e00\u4e2a\u989d\u5916\u589e\u52a0\u7684\u968f\u673a\u6307\u9488\uff0c\u8be5\u6307\u9488\u53ef\u4ee5\u6307\u5411\u94fe\u8868\u4e2d\u7684\u4efb\u4f55\u8282\u70b9\u6216\u7a7a\u8282\u70b9\u3002 \u8981\u6c42\u8fd4\u56de\u8fd9\u4e2a\u94fe\u8868\u7684 \u6df1\u62f7\u8d1d\u3002 \u6211\u4eec\u7528\u4e00\u4e2a\u7531 n \u4e2a\u8282\u70b9\u7ec4\u6210\u7684\u94fe\u8868\u6765\u8868\u793a\u8f93\u5165/\u8f93\u51fa\u4e2d\u7684\u94fe\u8868\u3002\u6bcf\u4e2a\u8282\u70b9\u7528\u4e00\u4e2a [val, random_index] \u8868\u793a\uff1a val\uff1a\u4e00\u4e2a\u8868\u793a Node.val \u7684\u6574\u6570\u3002 random_index\uff1a\u968f\u673a\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\u7d22\u5f15\uff08\u8303\u56f4\u4ece 0 \u5230 n-1\uff09\uff1b\u5982\u679c\u4e0d\u6307\u5411\u4efb\u4f55\u8282\u70b9\uff0c\u5219\u4e3a null \u3002 \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/copy-list-with-random-pointer \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 test","title":"138 \u590d\u5236\u5e26\u968f\u673a\u6307\u9488\u7684\u94fe\u8868"},{"location":"LeetCode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/#_1","text":"/** * Definition for a Node. * struct Node { * int val; * struct Node *next; * struct Node *random; * }; */ typedef struct Node Node; struct Node* copyRandomList(struct Node* head) { if(head == NULL) return NULL; //1.\u62f7\u8d1d\u8282\u70b9\u8fde\u63a5\u5230\u539f\u8282\u70b9\u540e\u9762 Node* cur = head; while(cur) { Node* copy = (Node*)malloc(sizeof(Node)); copy->next = NULL; copy->random = NULL; copy->val = cur->val; Node* next = cur->next;//copy cur->next=copy; copy->next= next; cur=next;//\u8fed\u4ee3 } //2.\u5904\u7406\u4e00\u4e0b\u62f7\u8d1d\u8282\u70b9\u7684random cur = head; while(cur){ Node* copy =cur->next; if(cur->random) copy->random=cur->random->next; else copy->random=NULL; cur=cur->next->next; } //3.\u62c6\u89e3\u51fa\u590d\u5236\u94fe\u8868 cur = head; Node* copyHead=head->next; while(cur){ Node* copy=cur->next; Node* next=copy->next; cur->next=next; if(next) copy->next=next->next; else copy->next=NULL; cur=next; } return copyHead; }","title":"\u4ee3\u7801"},{"location":"LeetCode/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","text":"\u73af\u5f62\u94fe\u8868 1.1\u9898\u76ee\u63cf\u8ff0\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u5224\u65ad\u94fe\u8868\u4e2d\u662f\u5426\u6709\u73af\u3002 \u5982\u679c\u94fe\u8868\u4e2d\u6709\u67d0\u4e2a\u8282\u70b9\uff0c\u53ef\u4ee5\u901a\u8fc7\u8fde\u7eed\u8ddf\u8e2a next \u6307\u9488\u518d\u6b21\u5230\u8fbe\uff0c\u5219\u94fe\u8868\u4e2d\u5b58\u5728\u73af\u3002 \u4e3a\u4e86\u8868\u793a\u7ed9\u5b9a\u94fe\u8868\u4e2d\u7684\u73af\uff0c\u6211\u4eec\u4f7f\u7528\u6574\u6570 pos \u6765\u8868\u793a\u94fe\u8868\u5c3e\u8fde\u63a5\u5230\u94fe\u8868\u4e2d\u7684\u4f4d\u7f6e\uff08\u7d22\u5f15\u4ece 0 \u5f00\u59cb\uff09\u3002 \u5982\u679c pos \u662f -1\uff0c\u5219\u5728\u8be5\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\u3002\u6ce8\u610f\uff1apos \u4e0d\u4f5c\u4e3a\u53c2\u6570\u8fdb\u884c\u4f20\u9012\uff0c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6807\u8bc6\u94fe\u8868\u7684\u5b9e\u9645\u60c5\u51b5\u3002 \u5982\u679c\u94fe\u8868\u4e2d\u5b58\u5728\u73af\uff0c\u5219\u8fd4\u56de true \u3002 \u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u8fdb\u9636\uff1a \u4f60\u80fd\u7528 O(1)\uff08\u5373\uff0c\u5e38\u91cf\uff09\u5185\u5b58\u89e3\u51b3\u6b64\u95ee\u9898\u5417\uff1f \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/linked-list-cycle \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 1.2 \u5206\u6790\uff1a \u5bf9\u4e8e\u6b64\u95ee\u9898\uff0c\u91c7\u7528\u5feb\u6162\u6307\u9488\u6765\u89e3\u51b3\uff0c\u5e76\u4e14\u6307\u9488\u76f8\u5dee1\u4e2a\u6b65\u957f /** \\* Definition for singly-linked list. \\* struct ListNode { \\* int val; \\* struct ListNode *next; \\* }; */ bool hasCycle(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; while(fast && fast->next )//\u5224\u65adfast\u6307\u9488\u4e0d\u7a7a { \u200b slow=slow->next; \u200b fast=fast->next->next; \u200b if(slow==fast){ \u200b return true; \u200b } } return false; }","title":"\u73af\u5f62\u94fe\u8868"},{"location":"LeetCode/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#_1","text":"","title":"\u73af\u5f62\u94fe\u8868"},{"location":"LeetCode/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#11","text":"\u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u5224\u65ad\u94fe\u8868\u4e2d\u662f\u5426\u6709\u73af\u3002 \u5982\u679c\u94fe\u8868\u4e2d\u6709\u67d0\u4e2a\u8282\u70b9\uff0c\u53ef\u4ee5\u901a\u8fc7\u8fde\u7eed\u8ddf\u8e2a next \u6307\u9488\u518d\u6b21\u5230\u8fbe\uff0c\u5219\u94fe\u8868\u4e2d\u5b58\u5728\u73af\u3002 \u4e3a\u4e86\u8868\u793a\u7ed9\u5b9a\u94fe\u8868\u4e2d\u7684\u73af\uff0c\u6211\u4eec\u4f7f\u7528\u6574\u6570 pos \u6765\u8868\u793a\u94fe\u8868\u5c3e\u8fde\u63a5\u5230\u94fe\u8868\u4e2d\u7684\u4f4d\u7f6e\uff08\u7d22\u5f15\u4ece 0 \u5f00\u59cb\uff09\u3002 \u5982\u679c pos \u662f -1\uff0c\u5219\u5728\u8be5\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\u3002\u6ce8\u610f\uff1apos \u4e0d\u4f5c\u4e3a\u53c2\u6570\u8fdb\u884c\u4f20\u9012\uff0c\u4ec5\u4ec5\u662f\u4e3a\u4e86\u6807\u8bc6\u94fe\u8868\u7684\u5b9e\u9645\u60c5\u51b5\u3002 \u5982\u679c\u94fe\u8868\u4e2d\u5b58\u5728\u73af\uff0c\u5219\u8fd4\u56de true \u3002 \u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u8fdb\u9636\uff1a \u4f60\u80fd\u7528 O(1)\uff08\u5373\uff0c\u5e38\u91cf\uff09\u5185\u5b58\u89e3\u51b3\u6b64\u95ee\u9898\u5417\uff1f \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/linked-list-cycle \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"1.1\u9898\u76ee\u63cf\u8ff0\uff1a"},{"location":"LeetCode/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#12","text":"\u5bf9\u4e8e\u6b64\u95ee\u9898\uff0c\u91c7\u7528\u5feb\u6162\u6307\u9488\u6765\u89e3\u51b3\uff0c\u5e76\u4e14\u6307\u9488\u76f8\u5dee1\u4e2a\u6b65\u957f /** \\* Definition for singly-linked list. \\* struct ListNode { \\* int val; \\* struct ListNode *next; \\* }; */ bool hasCycle(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; while(fast && fast->next )//\u5224\u65adfast\u6307\u9488\u4e0d\u7a7a { \u200b slow=slow->next; \u200b fast=fast->next->next; \u200b if(slow==fast){ \u200b return true; \u200b } } return false; }","title":"1.2 \u5206\u6790\uff1a"},{"location":"LeetCode/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/","text":"142 \u73af\u5f62\u94fe\u8868 \u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u5f00\u59cb\u5165\u73af\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002 \u5982\u679c\u94fe\u8868\u65e0\u73af\uff0c\u5219\u8fd4\u56de null\u3002 \u4e3a\u4e86\u8868\u793a\u7ed9\u5b9a\u94fe\u8868\u4e2d\u7684\u73af\uff0c\u6211\u4eec\u4f7f\u7528\u6574\u6570 pos \u6765\u8868\u793a\u94fe\u8868\u5c3e\u8fde\u63a5\u5230\u94fe\u8868\u4e2d\u7684\u4f4d\u7f6e\uff08\u7d22\u5f15\u4ece 0 \u5f00\u59cb\uff09\u3002 \u5982\u679c pos \u662f -1\uff0c\u5219\u5728\u8be5\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\u3002\u6ce8\u610f\uff0cpos \u4ec5\u4ec5\u662f\u7528\u4e8e\u6807\u8bc6\u73af\u7684\u60c5\u51b5\uff0c\u5e76\u4e0d\u4f1a\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u5230\u51fd\u6570\u4e2d\u3002 \u8bf4\u660e\uff1a\u4e0d\u5141\u8bb8\u4fee\u6539\u7ed9\u5b9a\u7684\u94fe\u8868\u3002 \u8fdb\u9636\uff1a \u4f60\u662f\u5426\u53ef\u4ee5\u4f7f\u7528 O(1) \u7a7a\u95f4\u89e3\u51b3\u6b64\u9898\uff1f \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahead = [3,2,0,-4], pos = 1 \u8f93\u51fa\uff1a\u8fd4\u56de\u7d22\u5f15\u4e3a 1 \u7684\u94fe\u8868\u8282\u70b9 \u89e3\u91ca\uff1a\u94fe\u8868\u4e2d\u6709\u4e00\u4e2a\u73af\uff0c\u5176\u5c3e\u90e8\u8fde\u63a5\u5230\u7b2c\u4e8c\u4e2a\u8282\u70b9\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahead = [1,2], pos = 0 \u8f93\u51fa\uff1a\u8fd4\u56de\u7d22\u5f15\u4e3a 0 \u7684\u94fe\u8868\u8282\u70b9 \u89e3\u91ca\uff1a\u94fe\u8868\u4e2d\u6709\u4e00\u4e2a\u73af\uff0c\u5176\u5c3e\u90e8\u8fde\u63a5\u5230\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahead = [1], pos = -1 \u8f93\u51fa\uff1a\u8fd4\u56de null \u89e3\u91ca\uff1a\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\u3002 \u63d0\u793a\uff1a \u94fe\u8868\u4e2d\u8282\u70b9\u7684\u6570\u76ee\u8303\u56f4\u5728\u8303\u56f4 [0, 104] \u5185 -105 <= Node.val <= 105 pos \u7684\u503c\u4e3a -1 \u6216\u8005\u94fe\u8868\u4e2d\u7684\u4e00\u4e2a\u6709\u6548\u7d22\u5f15 \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/linked-list-cycle-ii \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode *detectCycle(struct ListNode *head) { struct ListNode * slow ,*fast; slow=fast=head; while(fast&&fast->next) { slow=slow->next; fast=fast->next->next; if(fast==slow) { break; } } if(fast==NULL||fast->next==NULL) return NULL; struct ListNode *meet=fast; while(head!=meet) { head=head->next; meet=meet->next; } return meet; }","title":"142 \u73af\u5f62\u94fe\u8868"},{"location":"LeetCode/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/#142","text":"\u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u5f00\u59cb\u5165\u73af\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002 \u5982\u679c\u94fe\u8868\u65e0\u73af\uff0c\u5219\u8fd4\u56de null\u3002 \u4e3a\u4e86\u8868\u793a\u7ed9\u5b9a\u94fe\u8868\u4e2d\u7684\u73af\uff0c\u6211\u4eec\u4f7f\u7528\u6574\u6570 pos \u6765\u8868\u793a\u94fe\u8868\u5c3e\u8fde\u63a5\u5230\u94fe\u8868\u4e2d\u7684\u4f4d\u7f6e\uff08\u7d22\u5f15\u4ece 0 \u5f00\u59cb\uff09\u3002 \u5982\u679c pos \u662f -1\uff0c\u5219\u5728\u8be5\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\u3002\u6ce8\u610f\uff0cpos \u4ec5\u4ec5\u662f\u7528\u4e8e\u6807\u8bc6\u73af\u7684\u60c5\u51b5\uff0c\u5e76\u4e0d\u4f1a\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u5230\u51fd\u6570\u4e2d\u3002 \u8bf4\u660e\uff1a\u4e0d\u5141\u8bb8\u4fee\u6539\u7ed9\u5b9a\u7684\u94fe\u8868\u3002 \u8fdb\u9636\uff1a \u4f60\u662f\u5426\u53ef\u4ee5\u4f7f\u7528 O(1) \u7a7a\u95f4\u89e3\u51b3\u6b64\u9898\uff1f \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahead = [3,2,0,-4], pos = 1 \u8f93\u51fa\uff1a\u8fd4\u56de\u7d22\u5f15\u4e3a 1 \u7684\u94fe\u8868\u8282\u70b9 \u89e3\u91ca\uff1a\u94fe\u8868\u4e2d\u6709\u4e00\u4e2a\u73af\uff0c\u5176\u5c3e\u90e8\u8fde\u63a5\u5230\u7b2c\u4e8c\u4e2a\u8282\u70b9\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahead = [1,2], pos = 0 \u8f93\u51fa\uff1a\u8fd4\u56de\u7d22\u5f15\u4e3a 0 \u7684\u94fe\u8868\u8282\u70b9 \u89e3\u91ca\uff1a\u94fe\u8868\u4e2d\u6709\u4e00\u4e2a\u73af\uff0c\u5176\u5c3e\u90e8\u8fde\u63a5\u5230\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahead = [1], pos = -1 \u8f93\u51fa\uff1a\u8fd4\u56de null \u89e3\u91ca\uff1a\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\u3002 \u63d0\u793a\uff1a \u94fe\u8868\u4e2d\u8282\u70b9\u7684\u6570\u76ee\u8303\u56f4\u5728\u8303\u56f4 [0, 104] \u5185 -105 <= Node.val <= 105 pos \u7684\u503c\u4e3a -1 \u6216\u8005\u94fe\u8868\u4e2d\u7684\u4e00\u4e2a\u6709\u6548\u7d22\u5f15 \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/linked-list-cycle-ii \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode *detectCycle(struct ListNode *head) { struct ListNode * slow ,*fast; slow=fast=head; while(fast&&fast->next) { slow=slow->next; fast=fast->next->next; if(fast==slow) { break; } } if(fast==NULL||fast->next==NULL) return NULL; struct ListNode *meet=fast; while(head!=meet) { head=head->next; meet=meet->next; } return meet; }","title":"142 \u73af\u5f62\u94fe\u8868"},{"location":"LeetCode/147%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","text":"147 \u5bf9\u94fe\u8868\u8fdb\u884c\u63d2\u5165\u6392\u5e8f \u9898\u76ee\uff1a // /** // * Definition for singly-linked list. // * struct ListNode { // * int val; // * struct ListNode *next; // * }; // */ // typedef struct ListNode Node; // struct ListNode* insertionSortList(struct ListNode* head){ // if(head==NULL || head->next==NULL) // return head; // Node* sortHead=head; // Node* cur=head->next; // sortHead->next=NULL; // while(cur) // { // Node* next=cur->next; // // // if(cur->val == sortHead->val) // { // //\u5934\u63d2 // cur->next=sortHead; // sortHead=cur; // } // else // { // //\u4e2d\u95f4\u63d2\u5165 // Node* sortPrev = sortHead; // Node* sortCur = sortPrev->next; // while(sortCur) // { // if(cur->val <= sortCur->val) // { // sortPrev->next=cur; // cur->next=sortCur; // break; // } // else // { // sortPrev = sortCur; // sortCur = sortCur->next; // } // } // //\u5c3e\u63d2 // if(sortCur == NULL) // { // sortPrev->next = cur; // cur->next =NULL; // } // } // cur=next; // } // return sortHead; // } /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ // \u53c2\u8003\uff1ahttps://blog.csdn.net/qq_43647942/article/details/112387933 typedef struct ListNode Node; struct ListNode* insertionSortList(struct ListNode* head){ if (head == NULL || head->next == NULL) {//\u94fe\u8868\u4e3a\u7a7a\u6216\u53ea\u6709\u4e00\u4e2a\u8282\u70b9\u76f4\u63a5\u8fd4\u56de return head; } Node* sorthead = head;//\u5b9a\u4e49\u65b0\u7684\u94fe\u8868\uff0c\u628a\u539f\u94fe\u8868\u7684\u6bcf\u4e2a\u8282\u70b9\u6709\u5e8f\u63d2\u5165\u5230\u65b0\u94fe\u8868\u4e2d\u53bb Node* cur = head->next; Node* sorttail = head;//\u65b0\u94fe\u8868\u7684\u5c3e\u7ed3\u70b9\uff0c\u65b9\u4fbf\u5c3e\u63d2 sorttail->next = NULL;//\u5c3e\u7ed3\u70b9\u7684next\u57df\u7f6e\u7a7a while(cur){ Node* sortcur = sorthead; Node* prev = NULL; while(sortcur && cur->val >= sortcur->val){//\u539f\u94fe\u8868\u7684cur\u8282\u70b9\u5728\u65b0\u94fe\u8868\u4e2d\u627e\u5230\u63d2\u5165\u7684\u4f4d\u7f6e prev = sortcur; sortcur = sortcur->next; } if(sortcur == NULL){//\u539f\u94fe\u8868\u7684cur\u8282\u70b9\u6bd4\u65b0\u94fe\u8868\u4e2d\u6bcf\u4e2a\u8282\u70b9\u90fd\u5927\uff0c\u6267\u884c\u5c3e\u63d2 sorttail->next = cur; cur = cur->next; sorttail = sorttail->next; sorttail->next = NULL; } else if(prev == NULL){//cur\u8282\u70b9\u6bd4\u65b0\u94fe\u8868\u4e2d\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c0f\uff0c\u6267\u884c\u5934\u63d2 Node* next = cur->next; cur->next = sorthead; sorthead = cur; cur = next; } else{//\u4e0d\u662f\u5c3e\u63d2\uff0c\u4e5f\u4e0d\u662f\u5934\u63d2\uff0c\u6307\u5b9a\u4f4d\u7f6e\u63d2\u5165 prev->next = cur; cur = cur->next; prev->next->next = sortcur; } } head = sorthead; return head;//\u8fd4\u56de\u539f\u94fe\u8868\u7684\u5934 }","title":"147 \u5bf9\u94fe\u8868\u8fdb\u884c\u63d2\u5165\u6392\u5e8f"},{"location":"LeetCode/147%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#147","text":"\u9898\u76ee\uff1a // /** // * Definition for singly-linked list. // * struct ListNode { // * int val; // * struct ListNode *next; // * }; // */ // typedef struct ListNode Node; // struct ListNode* insertionSortList(struct ListNode* head){ // if(head==NULL || head->next==NULL) // return head; // Node* sortHead=head; // Node* cur=head->next; // sortHead->next=NULL; // while(cur) // { // Node* next=cur->next; // // // if(cur->val == sortHead->val) // { // //\u5934\u63d2 // cur->next=sortHead; // sortHead=cur; // } // else // { // //\u4e2d\u95f4\u63d2\u5165 // Node* sortPrev = sortHead; // Node* sortCur = sortPrev->next; // while(sortCur) // { // if(cur->val <= sortCur->val) // { // sortPrev->next=cur; // cur->next=sortCur; // break; // } // else // { // sortPrev = sortCur; // sortCur = sortCur->next; // } // } // //\u5c3e\u63d2 // if(sortCur == NULL) // { // sortPrev->next = cur; // cur->next =NULL; // } // } // cur=next; // } // return sortHead; // } /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ // \u53c2\u8003\uff1ahttps://blog.csdn.net/qq_43647942/article/details/112387933 typedef struct ListNode Node; struct ListNode* insertionSortList(struct ListNode* head){ if (head == NULL || head->next == NULL) {//\u94fe\u8868\u4e3a\u7a7a\u6216\u53ea\u6709\u4e00\u4e2a\u8282\u70b9\u76f4\u63a5\u8fd4\u56de return head; } Node* sorthead = head;//\u5b9a\u4e49\u65b0\u7684\u94fe\u8868\uff0c\u628a\u539f\u94fe\u8868\u7684\u6bcf\u4e2a\u8282\u70b9\u6709\u5e8f\u63d2\u5165\u5230\u65b0\u94fe\u8868\u4e2d\u53bb Node* cur = head->next; Node* sorttail = head;//\u65b0\u94fe\u8868\u7684\u5c3e\u7ed3\u70b9\uff0c\u65b9\u4fbf\u5c3e\u63d2 sorttail->next = NULL;//\u5c3e\u7ed3\u70b9\u7684next\u57df\u7f6e\u7a7a while(cur){ Node* sortcur = sorthead; Node* prev = NULL; while(sortcur && cur->val >= sortcur->val){//\u539f\u94fe\u8868\u7684cur\u8282\u70b9\u5728\u65b0\u94fe\u8868\u4e2d\u627e\u5230\u63d2\u5165\u7684\u4f4d\u7f6e prev = sortcur; sortcur = sortcur->next; } if(sortcur == NULL){//\u539f\u94fe\u8868\u7684cur\u8282\u70b9\u6bd4\u65b0\u94fe\u8868\u4e2d\u6bcf\u4e2a\u8282\u70b9\u90fd\u5927\uff0c\u6267\u884c\u5c3e\u63d2 sorttail->next = cur; cur = cur->next; sorttail = sorttail->next; sorttail->next = NULL; } else if(prev == NULL){//cur\u8282\u70b9\u6bd4\u65b0\u94fe\u8868\u4e2d\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c0f\uff0c\u6267\u884c\u5934\u63d2 Node* next = cur->next; cur->next = sorthead; sorthead = cur; cur = next; } else{//\u4e0d\u662f\u5c3e\u63d2\uff0c\u4e5f\u4e0d\u662f\u5934\u63d2\uff0c\u6307\u5b9a\u4f4d\u7f6e\u63d2\u5165 prev->next = cur; cur = cur->next; prev->next->next = sortcur; } } head = sorthead; return head;//\u8fd4\u56de\u539f\u94fe\u8868\u7684\u5934 }","title":"147 \u5bf9\u94fe\u8868\u8fdb\u884c\u63d2\u5165\u6392\u5e8f"},{"location":"LeetCode/explain/","text":"\u4ecb\u7ecd","title":"\u4ecb\u7ecd"},{"location":"LeetCode/explain/#_1","text":"","title":"\u4ecb\u7ecd"},{"location":"mkdocs%E5%85%A5%E9%97%A8/","text":"MkLorum For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. \u6d4b\u8bd5","title":"MkLorum"},{"location":"mkdocs%E5%85%A5%E9%97%A8/#mklorum","text":"For full documentation visit mkdocs.org .","title":"MkLorum"},{"location":"mkdocs%E5%85%A5%E9%97%A8/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs%E5%85%A5%E9%97%A8/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"mkdocs%E5%85%A5%E9%97%A8/#_1","text":"","title":"\u6d4b\u8bd5"},{"location":"mkdocs%E5%85%A5%E9%97%A8/About/","text":"\u7b2c\u4e8c\u4e2aMarkdown For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. \u6d4b\u8bd5","title":"\u7b2c\u4e8c\u4e2aMarkdown"},{"location":"mkdocs%E5%85%A5%E9%97%A8/About/#markdown","text":"For full documentation visit mkdocs.org .","title":"\u7b2c\u4e8c\u4e2aMarkdown"},{"location":"mkdocs%E5%85%A5%E9%97%A8/About/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs%E5%85%A5%E9%97%A8/About/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"mkdocs%E5%85%A5%E9%97%A8/About/#_1","text":"","title":"\u6d4b\u8bd5"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/","text":"\u4ed3\u5e93\u8bf4\u660e \u5b58\u50a8\u8bed\u8a00\u672c\u8eab\u7684\u8bed\u6cd5\uff0cSrcCode,Project\u5b58\u653e\u5bf9\u5e94\u7684\u4ee3\u7801\u548c\u9879\u76ee\uff1b \u76ee\u5f55\u7ed3\u6784\uff1a\u8bed\u8a00\uff08C/C++/MATLAB\uff09-\u6e90\u7801\u6216\u9879\u76ee\uff08SrcCode,Project\uff09\uff0c\u76f4\u63a5\u76ee\u5f55\u5b58\u653e\u5404\u8bed\u8a00\u7684\u7b14\u8bb0\uff08\u6682\u65f6\u8fd9\u6837\u5b9a\u4e49\uff09\u3002 \u7f51\u7ad9\u6536\u85cf \u6536\u85cf\u5927\u5168 \u7f16\u7a0b\u7f51\u7ad9 \u9879\u76ee \u4ecb\u7ecd \u5176\u4ed6 Matplot++ A C++ Graphics Library for Data Visualization \u65e0 Dependency Walker (depends.exe) Home Page Depends.exe \u52a8\u6001\u5e93\u4f9d\u8d56\u5206\u6790\u5de5\u5177 \u5b50\u6a21\u5757\u4ecb\u7ecd\u4e0e\u94fe\u63a5 \u5e8f\u53f7 \u5185\u5bb9\u4e0e\u94fe\u63a5 \u4ecb\u7ecd 1 \u4e66\u7c4d\u4e0e\u5176\u6e90\u7801 2 data set Generates 3D building geometry JSON tiles from OpenStreetMap data \uff1b 3dTiles tilesets of the Metropolis of Lyon - version1 | LIRIS's datasets library (cnrs.fr) \uff1b UD-Sample-data/3DTiles at master \u00b7 VCityTeam/UD-Sample-data \u00b7 GitHub \uff1b 3D Tiles from the Japanese PLATEAU open data set\uff1a GitHub - gkjohnson/plateau-3d-tiles-data: 3D Tiles from the Japanese PLATEAU open data set. \uff1b","title":"\u4ed3\u5e93\u8bf4\u660e"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/#_1","text":"\u5b58\u50a8\u8bed\u8a00\u672c\u8eab\u7684\u8bed\u6cd5\uff0cSrcCode,Project\u5b58\u653e\u5bf9\u5e94\u7684\u4ee3\u7801\u548c\u9879\u76ee\uff1b \u76ee\u5f55\u7ed3\u6784\uff1a\u8bed\u8a00\uff08C/C++/MATLAB\uff09-\u6e90\u7801\u6216\u9879\u76ee\uff08SrcCode,Project\uff09\uff0c\u76f4\u63a5\u76ee\u5f55\u5b58\u653e\u5404\u8bed\u8a00\u7684\u7b14\u8bb0\uff08\u6682\u65f6\u8fd9\u6837\u5b9a\u4e49\uff09\u3002","title":"\u4ed3\u5e93\u8bf4\u660e"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/#_2","text":"","title":"\u7f51\u7ad9\u6536\u85cf"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/#_3","text":"","title":"\u6536\u85cf\u5927\u5168"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/#_4","text":"\u9879\u76ee \u4ecb\u7ecd \u5176\u4ed6 Matplot++ A C++ Graphics Library for Data Visualization \u65e0 Dependency Walker (depends.exe) Home Page Depends.exe \u52a8\u6001\u5e93\u4f9d\u8d56\u5206\u6790\u5de5\u5177","title":"\u7f16\u7a0b\u7f51\u7ad9"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/#_5","text":"\u5e8f\u53f7 \u5185\u5bb9\u4e0e\u94fe\u63a5 \u4ecb\u7ecd 1 \u4e66\u7c4d\u4e0e\u5176\u6e90\u7801 2","title":"\u5b50\u6a21\u5757\u4ecb\u7ecd\u4e0e\u94fe\u63a5"},{"location":"mkdocs%E5%85%A5%E9%97%A8/test/#data-set","text":"Generates 3D building geometry JSON tiles from OpenStreetMap data \uff1b 3dTiles tilesets of the Metropolis of Lyon - version1 | LIRIS's datasets library (cnrs.fr) \uff1b UD-Sample-data/3DTiles at master \u00b7 VCityTeam/UD-Sample-data \u00b7 GitHub \uff1b 3D Tiles from the Japanese PLATEAU open data set\uff1a GitHub - gkjohnson/plateau-3d-tiles-data: 3D Tiles from the Japanese PLATEAU open data set. \uff1b","title":"data set"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/01_Doxygen%E5%85%A5%E9%97%A8/","text":"teedoc python lib mkdocs python lib Doxygen\u4e3b\u8981\u89e3\u51b3\u8bf4\u660e\u4e66\u95ee\u9898\uff0c\u53ef\u4ee5\u5728\u6211\u4eec\u5199\u4ee3\u7801\u7684\u65f6\u5019\u8bb2\u6ce8\u91ca\u8f6c\u5316\u4e3a\u8bf4\u660e\u4e66\uff0cGraphviz\u4e3b\u8981\u662f\u7528\u4e8e\u56fe\u5f62\u5c55\u793a\uff0chtml help workshop\u4e3b\u8981\u4f7f\u7528\u751f\u6210CHM\u6587\u6863\u3002 1.Doxygen Doxygen\u80fd\u5c06\u7a0b\u5e8f\u4e2d\u7684\u7279\u5b9a\u6279\u6ce8\u8f6c\u6362\u6210\u4e3a\u8bf4\u660e\u6587\u4ef6\u3002\u5b83\u53ef\u4ee5\u4f9d\u636e\u7a0b\u5e8f\u672c\u8eab\u7684\u7ed3\u6784\uff0c\u5c06\u7a0b\u5e8f\u4e2d\u6309\u89c4\u8303\u6ce8\u91ca\u7684\u6279\u6ce8\u7ecf\u8fc7\u5904\u7406\u751f\u6210\u4e00\u4e2a\u7eaf\u7cb9\u7684\u53c2\u8003\u624b\u518c\uff0c\u901a\u8fc7\u63d0\u53d6\u4ee3\u7801\u7ed3\u6784\u6216\u501f\u52a9\u81ea\u52a8\u751f\u6210\u7684\u5305\u542b\u4f9d\u8d56\u56fe\uff08include dependency graphs\uff09\u3001\u7ee7\u627f\u56fe\uff08inheritance diagram\uff09\u4ee5\u53ca\u534f\u4f5c\u56fe\uff08collaboration diagram\uff09\u6765\u53ef\u89c6\u5316\u6587\u6863\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c Doxygen\u751f\u6210\u7684\u5e2e\u52a9\u6587\u6863\u7684\u683c\u5f0f\u53ef\u4ee5\u662fCHM\u3001RTF\u3001PostScript\u3001PDF\u3001HTML\u7b49\u3002 2.graphviz Graphviz(Graph Visualization Software)\u662f\u4e00\u4e2a\u7531AT&T\u5b9e\u9a8c\u5ba4\u542f\u52a8\u7684\u5f00\u6e90\u5de5\u5177\u5305,\u7528\u4e8e\u7ed8\u5236DOT\u8bed\u8a00\u811a\u672c\u63cf\u8ff0\u7684\u56fe\u5f62\u3002\u8981\u4f7f\u7528Doxygen\u751f\u6210\u4f9d\u8d56\u56fe\u3001\u7ee7\u627f\u56fe\u4ee5\u53ca\u534f\u4f5c\u56fe\uff0c\u5fc5\u987b\u5148\u5b89\u88c5graphviz\u8f6f\u4ef6\u3002 Link \uff1b 3.HTML Help WorkShop \u5fae\u8f6f\u51fa\u54c1\u7684HTML Help WorkShop\u662f\u5236\u4f5cCHM\u6587\u4ef6\u7684\u6700\u4f73\u5de5\u5177\uff0c\u5b83\u80fd\u5c06HTML\u6587\u4ef6\u7f16\u8bd1\u751f\u6210CHM\u6587\u6863\u3002Doxygen\u8f6f\u4ef6\u9ed8\u8ba4\u751f\u6210HTML\u6587\u4ef6\u6216Latex\u6587\u4ef6\uff0c\u6211\u4eec\u8981\u901a\u8fc7HTML\u751f\u6210CHM\u6587\u6863\uff0c\u9700\u8981\u5148\u5b89\u88c5HTML Help WorkShop\u8f6f\u4ef6\uff0c\u5e76\u5728Doxygen\u4e2d\u8fdb\u884c\u5173\u8054 \u6ce8\u610f\uff1a\u5b89\u88c5\u5b8c\u540e\u8fdb\u884cDoxygen\u914d\u7f6e\u65f6\u9700\u8981\u5173\u8054graphviz\u548cHTML Help WorkShop\u7684\u5b89\u88c5\u8def\u5f84\u3002 \u95ee\u9898 \u9884\u7f16\u8bd1\u7684\u95ee\u9898","title":"01 Doxygen\u5165\u95e8"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/01_Doxygen%E5%85%A5%E9%97%A8/#_1","text":"","title":"\u95ee\u9898"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/01_Doxygen%E5%85%A5%E9%97%A8/#_2","text":"","title":"\u9884\u7f16\u8bd1\u7684\u95ee\u9898"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/","text":"\u591a\u79cd-C/C++\u5de5\u7a0b\u7684\u6587\u6863\u81ea\u52a8\u751f\u6210\u5de5\u5177 - \u77e5\u4e4e (zhihu.com) ; Doxygen\u4e3b\u8981\u89e3\u51b3\u8bf4\u660e\u4e66\u95ee\u9898\uff0c\u53ef\u4ee5\u5728\u6211\u4eec\u5199\u4ee3\u7801\u7684\u65f6\u5019\u8bb2\u6ce8\u91ca\u8f6c\u5316\u4e3a\u8bf4\u660e\u4e66\uff0cGraphviz\u4e3b\u8981\u662f\u7528\u4e8e\u56fe\u5f62\u5c55\u793a\uff0chtml help workshop\u4e3b\u8981\u4f7f\u7528\u751f\u6210CHM\u6587\u6863\u3002 1.Doxygen Doxygen\u80fd\u5c06\u7a0b\u5e8f\u4e2d\u7684\u7279\u5b9a\u6279\u6ce8\u8f6c\u6362\u6210\u4e3a\u8bf4\u660e\u6587\u4ef6\u3002\u5b83\u53ef\u4ee5\u4f9d\u636e\u7a0b\u5e8f\u672c\u8eab\u7684\u7ed3\u6784\uff0c\u5c06\u7a0b\u5e8f\u4e2d\u6309\u89c4\u8303\u6ce8\u91ca\u7684\u6279\u6ce8\u7ecf\u8fc7\u5904\u7406\u751f\u6210\u4e00\u4e2a\u7eaf\u7cb9\u7684\u53c2\u8003\u624b\u518c\uff0c\u901a\u8fc7\u63d0\u53d6\u4ee3\u7801\u7ed3\u6784\u6216\u501f\u52a9\u81ea\u52a8\u751f\u6210\u7684\u5305\u542b\u4f9d\u8d56\u56fe\uff08include dependency graphs\uff09\u3001\u7ee7\u627f\u56fe\uff08inheritance diagram\uff09\u4ee5\u53ca\u534f\u4f5c\u56fe\uff08collaboration diagram\uff09\u6765\u53ef\u89c6\u5316\u6587\u6863\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c Doxygen\u751f\u6210\u7684\u5e2e\u52a9\u6587\u6863\u7684\u683c\u5f0f\u53ef\u4ee5\u662fCHM\u3001RTF\u3001PostScript\u3001PDF\u3001HTML\u7b49\u3002 2.graphviz Graphviz(Graph Visualization Software)\u662f\u4e00\u4e2a\u7531AT&T\u5b9e\u9a8c\u5ba4\u542f\u52a8\u7684\u5f00\u6e90\u5de5\u5177\u5305,\u7528\u4e8e\u7ed8\u5236DOT\u8bed\u8a00\u811a\u672c\u63cf\u8ff0\u7684\u56fe\u5f62\u3002\u8981\u4f7f\u7528Doxygen\u751f\u6210\u4f9d\u8d56\u56fe\u3001\u7ee7\u627f\u56fe\u4ee5\u53ca\u534f\u4f5c\u56fe\uff0c\u5fc5\u987b\u5148\u5b89\u88c5graphviz\u8f6f\u4ef6\u3002 Link \uff1b 3.HTML Help WorkShop \u5fae\u8f6f\u51fa\u54c1\u7684HTML Help WorkShop\u662f\u5236\u4f5cCHM\u6587\u4ef6\u7684\u6700\u4f73\u5de5\u5177\uff0c\u5b83\u80fd\u5c06HTML\u6587\u4ef6\u7f16\u8bd1\u751f\u6210CHM\u6587\u6863\u3002Doxygen\u8f6f\u4ef6\u9ed8\u8ba4\u751f\u6210HTML\u6587\u4ef6\u6216Latex\u6587\u4ef6\uff0c\u6211\u4eec\u8981\u901a\u8fc7HTML\u751f\u6210CHM\u6587\u6863\uff0c\u9700\u8981\u5148\u5b89\u88c5HTML Help WorkShop\u8f6f\u4ef6\uff0c\u5e76\u5728Doxygen\u4e2d\u8fdb\u884c\u5173\u8054 \u6ce8\u610f\uff1a\u5b89\u88c5\u5b8c\u540e\u8fdb\u884cDoxygen\u914d\u7f6e\u65f6\u9700\u8981\u5173\u8054graphviz\u548cHTML Help WorkShop\u7684\u5b89\u88c5\u8def\u5f84\u3002 Doxygen \u793a\u610f\u4e00 \u8bed\u6cd5 \u6587\u4ef6\u6ce8\u91ca /** * @file \u6587\u4ef6\u540d * @brief \u7b80\u4ecb * @details \u7ec6\u8282 * @author \u4f5c\u8005 * @version \u7248\u672c\u53f7 * @date \u5e74-\u6708-\u65e5 * @copyright \u7248\u6743 */ \u7ed3\u6784\u4f53\u6ce8\u91ca /** * @brief \u7c7b\u7684\u8be6\u7ec6\u63cf\u8ff0 */ \u51fd\u6570\u6ce8\u91ca /** * @brief \u51fd\u6570\u63cf\u8ff0 * @param \u53c2\u6570\u63cf\u8ff0 * @return \u8fd4\u56de\u63cf\u8ff0 * @retval \u8fd4\u56de\u503c\u63cf\u8ff0 */ \u53d8\u91cf\u6ce8\u91ca //\u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa int a; /** * @brief \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa */ int a; int a; /*!< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa */ int a; /**< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa */ int a; //!< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa int a; ///< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa \u5173\u7cfb\u56fe \u9ec4\u6846\u52a0\u8f7d\u8def\u5f84\uff1aGraphviz-11.0.0-win64\u4f4e\u4e0b\u7684bin\u76ee\u5f55 \u751f\u6210PDF \u6240\u9700\u5de5\u5177 CTex\uff1b \u4e0b\u8f7d\u94fe\u63a5 \uff1b \u6b65\u9aa4\uff1a \u5b89\u88c5\u6253\u5f00WinEdt\uff1b \u6253\u5f00Doxygen\u751f\u6210\u7684\u6587\u4ef6\uff08refman.tex\uff09; \u7f16\u8bd1\uff0c\u76f4\u63a5\u53ef\u4ee5\u751f\u6210PDF\uff0c\u5b8c\u7f8e\uff01 \u53c2\u8003 \u4e0b\u8f7d\u94fe\u63a5 \uff1b \u4f7f\u7528\u624b\u518c \uff1b","title":"02 Doxygen\u8bed\u6cd5"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#doxygen","text":"\u793a\u610f\u4e00","title":"Doxygen"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_1","text":"","title":"\u8bed\u6cd5"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_2","text":"/** * @file \u6587\u4ef6\u540d * @brief \u7b80\u4ecb * @details \u7ec6\u8282 * @author \u4f5c\u8005 * @version \u7248\u672c\u53f7 * @date \u5e74-\u6708-\u65e5 * @copyright \u7248\u6743 */","title":"\u6587\u4ef6\u6ce8\u91ca"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_3","text":"/** * @brief \u7c7b\u7684\u8be6\u7ec6\u63cf\u8ff0 */","title":"\u7ed3\u6784\u4f53\u6ce8\u91ca"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_4","text":"/** * @brief \u51fd\u6570\u63cf\u8ff0 * @param \u53c2\u6570\u63cf\u8ff0 * @return \u8fd4\u56de\u63cf\u8ff0 * @retval \u8fd4\u56de\u503c\u63cf\u8ff0 */","title":"\u51fd\u6570\u6ce8\u91ca"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_5","text":"//\u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa int a; /** * @brief \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa */ int a; int a; /*!< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa */ int a; /**< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa */ int a; //!< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa int a; ///< \u5b9a\u4e49\u4e00\u4e2a\u6574\u578b\u53d8\u91cfa","title":"\u53d8\u91cf\u6ce8\u91ca"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_6","text":"\u9ec4\u6846\u52a0\u8f7d\u8def\u5f84\uff1aGraphviz-11.0.0-win64\u4f4e\u4e0b\u7684bin\u76ee\u5f55","title":"\u5173\u7cfb\u56fe"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#pdf","text":"\u6240\u9700\u5de5\u5177 CTex\uff1b \u4e0b\u8f7d\u94fe\u63a5 \uff1b \u6b65\u9aa4\uff1a \u5b89\u88c5\u6253\u5f00WinEdt\uff1b \u6253\u5f00Doxygen\u751f\u6210\u7684\u6587\u4ef6\uff08refman.tex\uff09; \u7f16\u8bd1\uff0c\u76f4\u63a5\u53ef\u4ee5\u751f\u6210PDF\uff0c\u5b8c\u7f8e\uff01","title":"\u751f\u6210PDF"},{"location":"%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/02_Doxygen%E8%AF%AD%E6%B3%95/#_7","text":"\u4e0b\u8f7d\u94fe\u63a5 \uff1b \u4f7f\u7528\u624b\u518c \uff1b","title":"\u53c2\u8003"},{"location":"%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85/","text":"\u5982\u4f55\u4f7f\u7528\u8f6f\u4ef6\u6253\u5305\u5de5\u5177 \u76f8\u5173\u547d\u4ee4 \u53c2\u8003\uff1a link \uff1b \u6e90\u7801\u53c2\u8003 \uff1b","title":"\u5982\u4f55\u4f7f\u7528\u8f6f\u4ef6\u6253\u5305\u5de5\u5177"},{"location":"%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85/#_1","text":"","title":"\u5982\u4f55\u4f7f\u7528\u8f6f\u4ef6\u6253\u5305\u5de5\u5177"},{"location":"%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85/#_2","text":"\u53c2\u8003\uff1a link \uff1b \u6e90\u7801\u53c2\u8003 \uff1b","title":"\u76f8\u5173\u547d\u4ee4"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/readme/","text":"\u5bfc\u822a \u52a8\u6001\u89c4\u5212","title":"\u5bfc\u822a"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/readme/#_1","text":"\u52a8\u6001\u89c4\u5212","title":"\u5bfc\u822a"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","text":"\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u603b\u7ed3\uff08dynamic-programming\uff09 \u52a8\u6001\u89c4\u5212\uff0c\u5e38\u5e38\u9002\u7528\u4e8e\u6709\u91cd\u53e0\u5b50\u95ee\u9898\u548c\u6700\u4f18\u5b50\u7ed3\u6784\u6027\u8d28\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u8bb0\u5f55\u6240\u6709\u5b50\u95ee\u9898\u7684\u7ed3\u679c\uff0c\u56e0\u6b64\u52a8\u6001\u89c4\u5212\u65b9\u6cd5\u6240\u8017\u65f6\u95f4\u5f80\u5f80\u8fdc\u5c11\u4e8e\u6734\u7d20\u89e3\u6cd5\u3002\u52a8\u6001\u89c4\u5212\u6709\u81ea\u5e95\u5411\u4e0a\u548c\u81ea\u9876\u5411\u4e0b\u4e24\u79cd\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u5f0f\u3002 \u81ea\u9876\u5411\u4e0b\u5373\u8bb0\u5fc6\u5316\u9012\u5f52 \uff0c \u81ea\u5e95\u5411\u4e0a\u5c31\u662f\u9012\u63a8 \u3002\u4f7f\u7528\u52a8\u6001\u89c4\u5212\u89e3\u51b3\u7684\u95ee\u9898\u6709\u4e2a\u660e\u663e\u7684\u7279\u70b9\uff0c\u4e00\u65e6\u4e00\u4e2a\u5b50\u95ee\u9898\u7684\u6c42\u89e3\u5f97\u5230\u7ed3\u679c\uff0c\u4ee5\u540e\u7684\u8ba1\u7b97\u8fc7\u7a0b\u5c31\u4e0d\u4f1a\u4fee\u6539\u5b83\uff0c\u8fd9\u6837\u7684\u7279\u70b9\u53eb\u505a\u65e0\u540e\u6548\u6027\uff0c\u6c42\u89e3\u95ee\u9898\u7684\u8fc7\u7a0b\u5f62\u6210\u4e86\u4e00\u5f20\u6709\u5411\u65e0\u73af\u56fe\u3002\u52a8\u6001\u89c4\u5212\u53ea\u89e3\u51b3\u6bcf\u4e2a\u5b50\u95ee\u9898\u4e00\u6b21\uff0c\u5177\u6709\u5929\u7136\u526a\u679d\u7684\u529f\u80fd\uff0c\u4ece\u800c\u51cf\u5c11\u8ba1\u7b97\u91cf\u3002 \u6253\u5bb6\u52ab\u820d \u601d\u8003\u8fc7\u7a0b\uff1a class Solution { public: int rob(vector<int>& nums) { if(nums.empty()) return 0; int len = nums.size(); if(len == 1) return nums[0]; int first = nums[0]; int second = max(nums[0], nums[1]); for(int i = 2; i < nums.size(); i++){ int temp = second; second = max(first + nums[i], second); first = temp; } return second; } }; \u6253\u5bb6\u7a83\u820d2 \u6b64\u65f6\uff0c\u6240\u6709\u623f\u5b50\u6784\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u5373\u7b2c\u4e00\u5bb6\u548c\u6700\u540e\u4e00\u5bb6\u623f\u5b50\u8fde\u63a5\u7740\u3002\u8bf7\u5206\u6790\u3002 \u5206\u6790\uff1a \u53ea\u6709\u4e00\u5bb6\uff0c\u53ea\u80fd\u6295\u4e00\u5bb6\uff1b \u53ea\u6709\u4e24\u5bb6\uff0c\u53ea\u80fd\u5077\u53d6\u6700\u9ad8\u7684\u4e00\u5bb6\u3002 \u5927\u4e8e\u4e24\u5bb6\uff0c\u5206\u533a\u5077\u7a83\u8303\u56f4\u3002\u5047\u8bbelen = nums.size() ; \u82e5\u5077\u4e86\u7b2c\u4e00\u5bb6\uff0c\u5219\u6700\u540e\u4e00\u5bb6\u4e0d\u80fd\u5077\u7a83\u3002\u5077\u7a83\u8303\u56f4\u4e3a\uff1a[0,len-2] \u82e5\u5077\u4e86\u6700\u540e\u4e00\u5bb6\uff0c\u5219\u7b2c\u4e00\u5bb6\u4e0d\u80fd\u5077\u7a83\u3002\u5077\u7a83\u8303\u56f4\u4e3a\uff1a[1, len-1] \u9009\u62e9\u6b65\u9aa4\u4e09\u79cd\u6700\u5927\u91d1\u989d\u6570\u8fd4\u56de\u3002 \u60c5\u51b5\u5206\u6790\uff1a \u53c2\u8003\u4ee3\u7801\uff1a class Solution { public: int rRange(vector<int>& nums, int start, int end) { int first = nums[start]; int second = max(nums[start], nums[start+1]); for(int i = start + 2; i <= end; i++){ int temp = second; second = max(first + nums[i], second); first = temp; } return second; } int rob(vector<int>& nums) { int len = nums.size(); if(len == 1) return nums[0]; else if(len == 2) return max(nums[0], nums[1]); return max(rRange(nums, 0, len-2), rRange(nums, 1, len - 1)); } }; \u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570 LeetCode740.\u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570 \u3002 \u5728nums\u6570\u7ec4\u57fa\u7840\u6784\u9020\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4temp\uff0c\u8fd9\u4e2a\u6570\u7ec4\u662f\u4ee5\u5143\u7d20\u7684\u503c\u6765\u505a\u4e0b\u6807\uff0c\u4e0b\u6807\u5bf9\u5e94\u7684\u5143\u7d20\u662f\u539f\u6765\u7684\u5143\u7d20\u7684\u4e2a\u6570\u3002 \u5982\uff1a nums = [2,2,3,3,3,4]; temp = [0,0,2,3,1];//\u8868\u793anums\u4e2d0\u548c1\u54040\u4e2a\uff0c2\u67092\u4e2a\uff0c3\u67093\u4e2a\uff0c4\u67091\u4e2a \u95ee\u9898\u8f6c\u5316\u4e3a\u6253\u5bb6\u7a83\u820d\u95ee\u9898\uff0c \u6253\u5bb6\u7a83\u820d\u6700\u4f18\u7ed3\u6784\uff1adp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); \u6b64\u95ee\u9898\u6700\u4f18\u7ed3\u6784\uff1a dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * all[i]); class Solution { public: int deleteAndEarn(vector<int>& nums) { if(nums.size() < 1) return 0; int maxVal = 0; for(auto e: nums){ maxVal = max(maxVal, e);//\u786e\u5b9a\u6570\u7ec4\u957f\u5ea6 } vector<int> count(maxVal+1), dp(maxVal+1); for(auto val: nums){ count[val]++; //temp\u6570\u7ec4 } dp[1] = count[1]; for(int i = 2; i <= maxVal; i++){ dp[i] = max(dp[i-1], dp[i-2] + count[i]*i); } return dp[maxVal]; } }; \u8df3\u8dc3\u6e38\u620f LeetCode55.\u8df3\u8dc3\u6e38\u620f \u5206\u6790\uff1a \u627e\u51fa\u6700\u8fdc\u53ef\u4ee5\u5230\u8fbe\u7684\u6700\u53f3\u4f4d\u7f6e \u5982\u679c\u6700\u8fdc\u53ef\u5230\u8fbe\u6700\u53f3\u4f4d\u7f6e\u8d85\u8fc7nums\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u5143\u7d20 \u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\uff1b class Solution { public: bool canJump(vector<int>& nums) { int n = nums.size(); int rightMax = 0; for(int i = 0; i < n; i++){ if(i <= rightMax){ rightMax = max(rightMax, i+nums[i]);//\u8bb0\u5f55\u6700\u8fdc\u5230\u8fbe if(rightMax >= n-1) return true; } } return false; } }; \u8df3\u8dc3\u6e38\u620f2 \u76ee\u6807\uff1a\u4f7f\u7528\u6700\u5c11\u8df3\u8dc3\u6b21\u6570\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e \u53cd\u5411\u67e5\u627e \u8003\u8651\u6700\u540e\u4e00\u6b65\u8df3\u8dc3\u524d\u6240\u5728\u4f4d\u7f6e\uff0c\u901a\u8fc7\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\u5982\u679c\u6709\u591a\u4e2a\u4f4d\u7f6e\u90fd\u80fd\u8df3\u8dc3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u90a3\u4e48\u5e94\u8be5\u9009\u62e9\u8ddd\u79bb\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u6700\u8fdc\u7684\u4f4d\u7f6e\uff0c\u5373\u5bf9\u5e94\u4e0b\u6807\u6700\u5c0f\u7684\u4f4d\u7f6e\u3002\u6240\u4ee5\uff0c\u4ece\u5de6\u5411\u53f3\u904d\u5386\u6570\u7ec4\uff0c\u9009\u62e9\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u8981\u6c42\u7684\u4f4d\u7f6e\u3002\u786e\u5b9a\u6700\u540e\u4e00\u6b65\u8df3\u8dc3\u524d\u6240\u5728\u4f4d\u7f6e\u4e4b\u540e\uff0c\u8d2a\u5fc3\u7684\u9009\u62e9\u5012\u6570\u7b2c\u4e8c\u6b65\u8df3\u8dc3\u524d\u6240\u5728\u4f4d\u7f6e\uff0c\u4f9d\u6b21\u7c7b\u63a8\uff0c\u76f4\u5230\u627e\u5230\u6700\u5f00\u59cb\u4f4d\u7f6e\u3002 class Solution { public int jump(int[] nums) { int position = nums.length - 1; int steps = 0; while (position > 0) { for (int i = 0; i < position; i++) { if (i + nums[i] >= position) { position = i; steps++; break; } } } return steps; } } \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 \u6b63\u5411\u67e5\u627e \u6b63\u5411\u67e5\u627e\uff0c\u6bcf\u6b21\u67e5\u627e\u6700\u8fdc\u53ef\u5230\u8fbe\u4f4d\u7f6e class Solution { public: int jump(vector<int>& nums) { int maxPos = 0, len = nums.size(), end = 0, sumStep = 0; for(int i = 0; i < len -1; i++){ if(maxPos >= i){ maxPos = max(maxPos, i + nums[i]); if(i == end){ end = maxPos; ++sumStep; } } } return sumStep; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n)$\uff0cn\u4e3a\u6570\u7ec4\u957f\u5ea6\u3002 \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a$O(1)$\u3002 27-11-10 \u7ec4\u957f\uff1a \u8fdb\u7a0b\u7ec4\u7ec4\u957f\uff1a\u547d\u4ee4\u884c\u4e0a\u542f\u52a8\u7684\u591a\u4e2a\u8fdb\u7a0b\uff0c\u534f\u540c\u5b8c\u6210\u67d0\u79cd\u4efb\u52a1\uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a\u88ab\u521b\u5efa\u51fa\u6765\u7684\u8fdb\u7a0b\uff0c\u79f0\u4e4b\u4e3a\u7ec4\u957f\u8fdb\u7a0b\u3002 \u5b88\u62a4\u8fdb\u7a0b\u672c\u8d28\u4e5f\u662f\u5b64\u513f\u8fdb\u7a0b\u3002 \u4f1a\u8bdd\u9996\u8fdb\u7a0b\u6709\u6743\u9650\u6253\u5f00\u7ec8\u7aef\u3002 ps axj | head -1 && ps axj | grep \u6587\u4ef6\u540d killall \u8fdb\u7a0b\u540d\u79f0 \u6740\u6389\u8fdb\u7a0b ls /dev/null -al\u5b57\u7b26\u6587\u4ef6\u3001\u8bbe\u5907\uff1b\u6240\u6709\u8bbe\u5907\u5f80\u8fd9\u4e2a\u6587\u4ef6\u5199\uff0c\u7b49\u4e8e\u4e22\u5f03\u8fd9\u4e2a\u6587\u4ef6\uff0c\u901a\u5e38\u7528\u6765\u8fdb\u884c\u5c4f\u853d\uff0cdrop\u8f93\u5165\u8f93\u51fa\u4fe1\u606f\u3002 //void deamon(int nochidr , int noclose) int main() { umask(0);// sys/type.h sys/stat.h if(fork()>0){ exit(0); } signal(SIGCHLD, SIG_IGN); setsid();//\u5c06\u975e\u7ec4\u957f\u8fdb\u7a0b\u8bbe\u4e3a\u65b0\u7684\u72ec\u7acb\u4f1a\u8bdd //if\u8bed\u53e5\uff0c\u53ef\u4ee5\u9009\u62e9\u4e0d\u505a\uff0c\u9632\u5fa1\u6027\u7f16\u7a0b if(fork()>0){ //father exit(0); } //\u53ef\u9009\u62e9\u9009\u9879 chdir(\"/\");//\u4fee\u6539\u5f53\u524d\u8def\u5f84\u4e3a\u6839\u76ee\u5f55\uff0c\u65e0\u6cd5\u6253\u5f00\u7ec8\u7aef\u8bbe\u5907 if(nochld == 0) { //\u53ef\u9009\u62e9\u9009\u9879 chdir(\"/\");//\u4fee\u6539\u5f53\u524d\u8def\u5f84\u4e3a\u6839\u76ee\u5f55\uff0c\u65e0\u6cd5\u6253\u5f00\u7ec8\u7aef\u8bbe\u5907 } //\u53ef\u9009\u62e9\u9009\u9879 close(0); int fd = open(\"dev/null\", O_RDWR); if(fd < 0){return;} dup2(fd, 1); dup2(fd, 2); if(noclose == 0) { close(0); int fd = open(\"dev/null\", O_RDWR); if(fd < 0){return;} dup2(fd, 1); dup2(fd, 2); } //\u8d70\u5230\u6b64\u5904\uff0c\u5b59\u5b50\u8fdb\u7a0b\u6267\u884c while(1){ } return 0; } int main() { my_daemon(1,1); while(1){ sleep(1); } } ls /proc/\u8fdb\u7a0b\u7f16\u53f7/fd PGRP\u6807\u8bb0\u8fdb\u7a0b\u7ec4\u7ec4\u957f\u7f16\u53f7 \u7236\u8fdb\u7a0b\u5c31\u662f\u7ec4\u957f\uff0c \u7ebf\u7a0b \u7ebf\u7a0b\u5728\u8fdb\u7a0b\u5185\u90e8\u8fd0\u884c\uff0c\u7ebf\u7a0b\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u5185\u8fd0\u884c\u3002 in Linux\uff0c\u7ad9\u5728CPU\u7684\u89d2\u5ea6\uff0c\u80fd\u5426\u8bc6\u522btask_struct\u662f\u8fdb\u7a0b\u8fd8\u662f\u7ebf\u7a0b\uff1f\uff1f \u4ec0\u4e48\u662f\u8fdb\u7a0b\uff1f\uff08\u7ad9\u5728\u5185\u6838\u89d2\u5ea6\uff09 \u200b \u627f\u62c5\u5206\u914d\u7cfb\u7edf\u8d44\u6e90\u7684\u57fa\u672c\u5355\u4f4d \u79f0\u4e4b\u4e3a\u8fdb\u7a0b\u3002 \u8fdb\u7a0b\u5206\u914dtask_struct \u548c\u5730\u5740\u7a7a\u95f4\uff1b \u4e4b\u524d\u5bf9\u8fdb\u7a0b\u7684\u7406\u89e3 \uff0c\u6240\u6709\u8fdb\u7a0b\u90fd\u662f\u53ea\u6709\u4e00\u4e2atask_struct \uff0c\u8be5\u8fdb\u7a0b\u5185\u90e8\u53ea\u6709\u4e00\u4e2a\u6267\u884c\u6d41\u3002\u3010\u5355\u6267\u884c\u6d41\u8fdb\u7a0b\u3011 \u7ad9\u5728CPU\u7684\u89d2\u5ea6\uff0cin Linux\uff0c\u7ad9\u5728CPU\u7684\u89d2\u5ea6\uff0c\u80fd\u5426\u8bc6\u522btask_struct\u662f\u8fdb\u7a0b\u8fd8\u662f\u7ebf\u7a0b\uff1f\uff1f\u3010\u4e0d\u80fd\uff0c\u4e5f\u4e0d\u9700\u8981\u8bc6\u522b\uff0c\u56e0\u4e3a\uff0cCPU\u53ea\u5173\u5fc3\u4e00\u4e2a\u4e00\u4e2a\u7684\u72ec\u7acb\u6267\u884c\u6d41\u3002\u5728CPU\u770b\u6765\uff0ctask_struct <= OS\u539f\u7406\u4e0a\u9762\u7684\u8fdb\u7a0b\u63a7\u5236\u5757\u7684\u3011 \u5728linux\u4e0b\uff0c\u5e76\u4e0d\u5b58\u5728\u771f\u6b63\u7684\u591a\u7ebf\u7a0b\uff0c\u5176\u5b9e\u662f\u7528\u8fdb\u7a0b\u6a21\u62df\u7684\u7ebf\u7a0b\u3002\u600e\u4e48\u7406\u89e3\uff1f\u5f53\u7ebf\u7a0b\u8db3\u591f\u591a\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u7ba1\u7406\u7ebf\u7a0b\u3002 Linux\u4e2d\uff0c\u6240\u6709\u6267\u884c\u6d41\uff0c\u90fd\u53eb\u505a\u8f7b\u91cf\u7ea7\u8fdb\u7a0b\u3002 NAME pthread_create - create a new thread SYNOPSIS #include <pthread.h> int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); Compile and link with -pthread. DESCRIPTION The pthread_create() function starts a new thread in the calling process. The new thread starts execution by invoking start_routine(); arg is passed as the sole argu\u2010 ment of start_routine(). pthread_create() \u51fd\u6570\u5728\u8c03\u7528\u8fdb\u7a0b\u4e2d\u542f\u52a8\u4e00\u4e2a\u65b0\u7ebf\u7a0b\u3002 \u65b0\u7ebf\u7a0b\u901a\u8fc7\u8c03\u7528 start_routine() \u5f00\u59cb\u6267\u884c\uff1b arg \u4f5c\u4e3a start_routine() \u7684\u552f\u4e00\u53c2\u6570\u4f20\u9012\u3002 The new thread terminates in one of the following ways: * It calls pthread_exit(3), specifying an exit status value that is available to another thread in the same process that calls pthread_join(3). * It returns from start_routine(). This is equivalent to calling pthread_exit(3) with the value supplied in the return statement. * It is canceled (see pthread_cancel(3)). * Any of the threads in the process calls exit(3), or the main thread performs a return from main(). This causes the termination of all threads in the process. \u4ece\u7cfb\u7edf\u7406\u89e3char *str = \"hello yumoz\"; str[1] = \"o\";\u51fa\u9519\u539f\u56e0\u3002\u56e0\u4e3a\u7269\u7406\u5185\u5b58\u5230\u6808\u7684\u6620\u5c04\u5173\u7cfb\u51fa\u73b0\u95ee\u9898\u3002 \u8ba1\u7b97\u5bc6\u96c6\u578b\uff1a\u6267\u884c\u6d41\u7684\u5927\u90e8\u5206\u4efb\u52a1\uff0c\u4e3b\u8981\u4ee5\u8ba1\u7b97\u4e3a\u4e3b\uff1a\u52a0\u5bc6\u89e3\u5bc6\u3001\u6392\u5e8f IO\u5bc6\u96c6\u578b\uff1a\u6267\u884c\u6d41\u7684\u5927\u90e8\u5206\u4efb\u52a1\uff0c\u662f\u4ee5IO\u4e3a\u4e3b\uff0c\u5237\u78c1\u76d8\uff0c\u8bbf\u95ee\u6570\u636e\u5e93\uff0c\u8bbf\u95ee\u7f51\u7edc\u3002 \u4f5c\u4e1a\u7b14\u8bb0 \u4e00\u3001\u7b2c\u4e00\u5929 1 \u5b57\u6bcd\u53d8\u6362 \u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 ^= 32; \u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5c0f\u5199 : \u5b57\u7b26 |= 32; \u5c0f\u5199\u53d8\u5927\u5199\u3001\u5927\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 &= -33; \u4f8b\u5982\uff1a ASCII\u7801\u8868\u4e2d\u5927\u5199\u7684A\u662f65\uff0c\u5c0f\u5199\u7684a\u662f97\uff0c\u5b83\u4eec\u7684\u5dee\u662f32 65 | 32 \u8f6c\u4e3a\u4e8c\u8fdb\u5236\uff08\u63098\u4f4d\u6765\u7b97\uff09\u53ef\u4ee5\u5f97\u5230 0100 0001 | 0010 0000 = 0110 0001 = 97 = a \u4e8c\u3001day2 \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e int searchInsert(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; int ans = numsSize; while(left <= right) { int mid = ((right - left) >> 1) + left; if(target <= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } \u4e09\u3001day3","title":"\u7b97\u6cd5 \u52a8\u6001\u89c4\u5212"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_1","text":"\u601d\u8003\u8fc7\u7a0b\uff1a class Solution { public: int rob(vector<int>& nums) { if(nums.empty()) return 0; int len = nums.size(); if(len == 1) return nums[0]; int first = nums[0]; int second = max(nums[0], nums[1]); for(int i = 2; i < nums.size(); i++){ int temp = second; second = max(first + nums[i], second); first = temp; } return second; } };","title":"\u6253\u5bb6\u52ab\u820d"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2","text":"\u6b64\u65f6\uff0c\u6240\u6709\u623f\u5b50\u6784\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u5373\u7b2c\u4e00\u5bb6\u548c\u6700\u540e\u4e00\u5bb6\u623f\u5b50\u8fde\u63a5\u7740\u3002\u8bf7\u5206\u6790\u3002 \u5206\u6790\uff1a \u53ea\u6709\u4e00\u5bb6\uff0c\u53ea\u80fd\u6295\u4e00\u5bb6\uff1b \u53ea\u6709\u4e24\u5bb6\uff0c\u53ea\u80fd\u5077\u53d6\u6700\u9ad8\u7684\u4e00\u5bb6\u3002 \u5927\u4e8e\u4e24\u5bb6\uff0c\u5206\u533a\u5077\u7a83\u8303\u56f4\u3002\u5047\u8bbelen = nums.size() ; \u82e5\u5077\u4e86\u7b2c\u4e00\u5bb6\uff0c\u5219\u6700\u540e\u4e00\u5bb6\u4e0d\u80fd\u5077\u7a83\u3002\u5077\u7a83\u8303\u56f4\u4e3a\uff1a[0,len-2] \u82e5\u5077\u4e86\u6700\u540e\u4e00\u5bb6\uff0c\u5219\u7b2c\u4e00\u5bb6\u4e0d\u80fd\u5077\u7a83\u3002\u5077\u7a83\u8303\u56f4\u4e3a\uff1a[1, len-1] \u9009\u62e9\u6b65\u9aa4\u4e09\u79cd\u6700\u5927\u91d1\u989d\u6570\u8fd4\u56de\u3002 \u60c5\u51b5\u5206\u6790\uff1a \u53c2\u8003\u4ee3\u7801\uff1a class Solution { public: int rRange(vector<int>& nums, int start, int end) { int first = nums[start]; int second = max(nums[start], nums[start+1]); for(int i = start + 2; i <= end; i++){ int temp = second; second = max(first + nums[i], second); first = temp; } return second; } int rob(vector<int>& nums) { int len = nums.size(); if(len == 1) return nums[0]; else if(len == 2) return max(nums[0], nums[1]); return max(rRange(nums, 0, len-2), rRange(nums, 1, len - 1)); } };","title":"\u6253\u5bb6\u7a83\u820d2"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_2","text":"LeetCode740.\u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570 \u3002 \u5728nums\u6570\u7ec4\u57fa\u7840\u6784\u9020\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4temp\uff0c\u8fd9\u4e2a\u6570\u7ec4\u662f\u4ee5\u5143\u7d20\u7684\u503c\u6765\u505a\u4e0b\u6807\uff0c\u4e0b\u6807\u5bf9\u5e94\u7684\u5143\u7d20\u662f\u539f\u6765\u7684\u5143\u7d20\u7684\u4e2a\u6570\u3002 \u5982\uff1a nums = [2,2,3,3,3,4]; temp = [0,0,2,3,1];//\u8868\u793anums\u4e2d0\u548c1\u54040\u4e2a\uff0c2\u67092\u4e2a\uff0c3\u67093\u4e2a\uff0c4\u67091\u4e2a \u95ee\u9898\u8f6c\u5316\u4e3a\u6253\u5bb6\u7a83\u820d\u95ee\u9898\uff0c \u6253\u5bb6\u7a83\u820d\u6700\u4f18\u7ed3\u6784\uff1adp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); \u6b64\u95ee\u9898\u6700\u4f18\u7ed3\u6784\uff1a dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * all[i]); class Solution { public: int deleteAndEarn(vector<int>& nums) { if(nums.size() < 1) return 0; int maxVal = 0; for(auto e: nums){ maxVal = max(maxVal, e);//\u786e\u5b9a\u6570\u7ec4\u957f\u5ea6 } vector<int> count(maxVal+1), dp(maxVal+1); for(auto val: nums){ count[val]++; //temp\u6570\u7ec4 } dp[1] = count[1]; for(int i = 2; i <= maxVal; i++){ dp[i] = max(dp[i-1], dp[i-2] + count[i]*i); } return dp[maxVal]; } };","title":"\u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_3","text":"LeetCode55.\u8df3\u8dc3\u6e38\u620f \u5206\u6790\uff1a \u627e\u51fa\u6700\u8fdc\u53ef\u4ee5\u5230\u8fbe\u7684\u6700\u53f3\u4f4d\u7f6e \u5982\u679c\u6700\u8fdc\u53ef\u5230\u8fbe\u6700\u53f3\u4f4d\u7f6e\u8d85\u8fc7nums\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u5143\u7d20 \u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\uff1b class Solution { public: bool canJump(vector<int>& nums) { int n = nums.size(); int rightMax = 0; for(int i = 0; i < n; i++){ if(i <= rightMax){ rightMax = max(rightMax, i+nums[i]);//\u8bb0\u5f55\u6700\u8fdc\u5230\u8fbe if(rightMax >= n-1) return true; } } return false; } };","title":"\u8df3\u8dc3\u6e38\u620f"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2_1","text":"\u76ee\u6807\uff1a\u4f7f\u7528\u6700\u5c11\u8df3\u8dc3\u6b21\u6570\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e","title":"\u8df3\u8dc3\u6e38\u620f2"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_4","text":"\u8003\u8651\u6700\u540e\u4e00\u6b65\u8df3\u8dc3\u524d\u6240\u5728\u4f4d\u7f6e\uff0c\u901a\u8fc7\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\u5982\u679c\u6709\u591a\u4e2a\u4f4d\u7f6e\u90fd\u80fd\u8df3\u8dc3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u90a3\u4e48\u5e94\u8be5\u9009\u62e9\u8ddd\u79bb\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u6700\u8fdc\u7684\u4f4d\u7f6e\uff0c\u5373\u5bf9\u5e94\u4e0b\u6807\u6700\u5c0f\u7684\u4f4d\u7f6e\u3002\u6240\u4ee5\uff0c\u4ece\u5de6\u5411\u53f3\u904d\u5386\u6570\u7ec4\uff0c\u9009\u62e9\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u8981\u6c42\u7684\u4f4d\u7f6e\u3002\u786e\u5b9a\u6700\u540e\u4e00\u6b65\u8df3\u8dc3\u524d\u6240\u5728\u4f4d\u7f6e\u4e4b\u540e\uff0c\u8d2a\u5fc3\u7684\u9009\u62e9\u5012\u6570\u7b2c\u4e8c\u6b65\u8df3\u8dc3\u524d\u6240\u5728\u4f4d\u7f6e\uff0c\u4f9d\u6b21\u7c7b\u63a8\uff0c\u76f4\u5230\u627e\u5230\u6700\u5f00\u59cb\u4f4d\u7f6e\u3002 class Solution { public int jump(int[] nums) { int position = nums.length - 1; int steps = 0; while (position > 0) { for (int i = 0; i < position; i++) { if (i + nums[i] >= position) { position = i; steps++; break; } } } return steps; } } \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u53cd\u5411\u67e5\u627e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_5","text":"\u6b63\u5411\u67e5\u627e\uff0c\u6bcf\u6b21\u67e5\u627e\u6700\u8fdc\u53ef\u5230\u8fbe\u4f4d\u7f6e class Solution { public: int jump(vector<int>& nums) { int maxPos = 0, len = nums.size(), end = 0, sumStep = 0; for(int i = 0; i < len -1; i++){ if(maxPos >= i){ maxPos = max(maxPos, i + nums[i]); if(i == end){ end = maxPos; ++sumStep; } } } return sumStep; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n)$\uff0cn\u4e3a\u6570\u7ec4\u957f\u5ea6\u3002 \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a$O(1)$\u3002","title":"\u6b63\u5411\u67e5\u627e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#27-11-10","text":"\u7ec4\u957f\uff1a \u8fdb\u7a0b\u7ec4\u7ec4\u957f\uff1a\u547d\u4ee4\u884c\u4e0a\u542f\u52a8\u7684\u591a\u4e2a\u8fdb\u7a0b\uff0c\u534f\u540c\u5b8c\u6210\u67d0\u79cd\u4efb\u52a1\uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a\u88ab\u521b\u5efa\u51fa\u6765\u7684\u8fdb\u7a0b\uff0c\u79f0\u4e4b\u4e3a\u7ec4\u957f\u8fdb\u7a0b\u3002 \u5b88\u62a4\u8fdb\u7a0b\u672c\u8d28\u4e5f\u662f\u5b64\u513f\u8fdb\u7a0b\u3002 \u4f1a\u8bdd\u9996\u8fdb\u7a0b\u6709\u6743\u9650\u6253\u5f00\u7ec8\u7aef\u3002 ps axj | head -1 && ps axj | grep \u6587\u4ef6\u540d killall \u8fdb\u7a0b\u540d\u79f0 \u6740\u6389\u8fdb\u7a0b ls /dev/null -al\u5b57\u7b26\u6587\u4ef6\u3001\u8bbe\u5907\uff1b\u6240\u6709\u8bbe\u5907\u5f80\u8fd9\u4e2a\u6587\u4ef6\u5199\uff0c\u7b49\u4e8e\u4e22\u5f03\u8fd9\u4e2a\u6587\u4ef6\uff0c\u901a\u5e38\u7528\u6765\u8fdb\u884c\u5c4f\u853d\uff0cdrop\u8f93\u5165\u8f93\u51fa\u4fe1\u606f\u3002 //void deamon(int nochidr , int noclose) int main() { umask(0);// sys/type.h sys/stat.h if(fork()>0){ exit(0); } signal(SIGCHLD, SIG_IGN); setsid();//\u5c06\u975e\u7ec4\u957f\u8fdb\u7a0b\u8bbe\u4e3a\u65b0\u7684\u72ec\u7acb\u4f1a\u8bdd //if\u8bed\u53e5\uff0c\u53ef\u4ee5\u9009\u62e9\u4e0d\u505a\uff0c\u9632\u5fa1\u6027\u7f16\u7a0b if(fork()>0){ //father exit(0); } //\u53ef\u9009\u62e9\u9009\u9879 chdir(\"/\");//\u4fee\u6539\u5f53\u524d\u8def\u5f84\u4e3a\u6839\u76ee\u5f55\uff0c\u65e0\u6cd5\u6253\u5f00\u7ec8\u7aef\u8bbe\u5907 if(nochld == 0) { //\u53ef\u9009\u62e9\u9009\u9879 chdir(\"/\");//\u4fee\u6539\u5f53\u524d\u8def\u5f84\u4e3a\u6839\u76ee\u5f55\uff0c\u65e0\u6cd5\u6253\u5f00\u7ec8\u7aef\u8bbe\u5907 } //\u53ef\u9009\u62e9\u9009\u9879 close(0); int fd = open(\"dev/null\", O_RDWR); if(fd < 0){return;} dup2(fd, 1); dup2(fd, 2); if(noclose == 0) { close(0); int fd = open(\"dev/null\", O_RDWR); if(fd < 0){return;} dup2(fd, 1); dup2(fd, 2); } //\u8d70\u5230\u6b64\u5904\uff0c\u5b59\u5b50\u8fdb\u7a0b\u6267\u884c while(1){ } return 0; } int main() { my_daemon(1,1); while(1){ sleep(1); } } ls /proc/\u8fdb\u7a0b\u7f16\u53f7/fd PGRP\u6807\u8bb0\u8fdb\u7a0b\u7ec4\u7ec4\u957f\u7f16\u53f7 \u7236\u8fdb\u7a0b\u5c31\u662f\u7ec4\u957f\uff0c","title":"27-11-10"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_6","text":"\u7ebf\u7a0b\u5728\u8fdb\u7a0b\u5185\u90e8\u8fd0\u884c\uff0c\u7ebf\u7a0b\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u5185\u8fd0\u884c\u3002 in Linux\uff0c\u7ad9\u5728CPU\u7684\u89d2\u5ea6\uff0c\u80fd\u5426\u8bc6\u522btask_struct\u662f\u8fdb\u7a0b\u8fd8\u662f\u7ebf\u7a0b\uff1f\uff1f \u4ec0\u4e48\u662f\u8fdb\u7a0b\uff1f\uff08\u7ad9\u5728\u5185\u6838\u89d2\u5ea6\uff09 \u200b \u627f\u62c5\u5206\u914d\u7cfb\u7edf\u8d44\u6e90\u7684\u57fa\u672c\u5355\u4f4d \u79f0\u4e4b\u4e3a\u8fdb\u7a0b\u3002 \u8fdb\u7a0b\u5206\u914dtask_struct \u548c\u5730\u5740\u7a7a\u95f4\uff1b \u4e4b\u524d\u5bf9\u8fdb\u7a0b\u7684\u7406\u89e3 \uff0c\u6240\u6709\u8fdb\u7a0b\u90fd\u662f\u53ea\u6709\u4e00\u4e2atask_struct \uff0c\u8be5\u8fdb\u7a0b\u5185\u90e8\u53ea\u6709\u4e00\u4e2a\u6267\u884c\u6d41\u3002\u3010\u5355\u6267\u884c\u6d41\u8fdb\u7a0b\u3011 \u7ad9\u5728CPU\u7684\u89d2\u5ea6\uff0cin Linux\uff0c\u7ad9\u5728CPU\u7684\u89d2\u5ea6\uff0c\u80fd\u5426\u8bc6\u522btask_struct\u662f\u8fdb\u7a0b\u8fd8\u662f\u7ebf\u7a0b\uff1f\uff1f\u3010\u4e0d\u80fd\uff0c\u4e5f\u4e0d\u9700\u8981\u8bc6\u522b\uff0c\u56e0\u4e3a\uff0cCPU\u53ea\u5173\u5fc3\u4e00\u4e2a\u4e00\u4e2a\u7684\u72ec\u7acb\u6267\u884c\u6d41\u3002\u5728CPU\u770b\u6765\uff0ctask_struct <= OS\u539f\u7406\u4e0a\u9762\u7684\u8fdb\u7a0b\u63a7\u5236\u5757\u7684\u3011 \u5728linux\u4e0b\uff0c\u5e76\u4e0d\u5b58\u5728\u771f\u6b63\u7684\u591a\u7ebf\u7a0b\uff0c\u5176\u5b9e\u662f\u7528\u8fdb\u7a0b\u6a21\u62df\u7684\u7ebf\u7a0b\u3002\u600e\u4e48\u7406\u89e3\uff1f\u5f53\u7ebf\u7a0b\u8db3\u591f\u591a\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u7ba1\u7406\u7ebf\u7a0b\u3002 Linux\u4e2d\uff0c\u6240\u6709\u6267\u884c\u6d41\uff0c\u90fd\u53eb\u505a\u8f7b\u91cf\u7ea7\u8fdb\u7a0b\u3002 NAME pthread_create - create a new thread SYNOPSIS #include <pthread.h> int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); Compile and link with -pthread. DESCRIPTION The pthread_create() function starts a new thread in the calling process. The new thread starts execution by invoking start_routine(); arg is passed as the sole argu\u2010 ment of start_routine(). pthread_create() \u51fd\u6570\u5728\u8c03\u7528\u8fdb\u7a0b\u4e2d\u542f\u52a8\u4e00\u4e2a\u65b0\u7ebf\u7a0b\u3002 \u65b0\u7ebf\u7a0b\u901a\u8fc7\u8c03\u7528 start_routine() \u5f00\u59cb\u6267\u884c\uff1b arg \u4f5c\u4e3a start_routine() \u7684\u552f\u4e00\u53c2\u6570\u4f20\u9012\u3002 The new thread terminates in one of the following ways: * It calls pthread_exit(3), specifying an exit status value that is available to another thread in the same process that calls pthread_join(3). * It returns from start_routine(). This is equivalent to calling pthread_exit(3) with the value supplied in the return statement. * It is canceled (see pthread_cancel(3)). * Any of the threads in the process calls exit(3), or the main thread performs a return from main(). This causes the termination of all threads in the process. \u4ece\u7cfb\u7edf\u7406\u89e3char *str = \"hello yumoz\"; str[1] = \"o\";\u51fa\u9519\u539f\u56e0\u3002\u56e0\u4e3a\u7269\u7406\u5185\u5b58\u5230\u6808\u7684\u6620\u5c04\u5173\u7cfb\u51fa\u73b0\u95ee\u9898\u3002 \u8ba1\u7b97\u5bc6\u96c6\u578b\uff1a\u6267\u884c\u6d41\u7684\u5927\u90e8\u5206\u4efb\u52a1\uff0c\u4e3b\u8981\u4ee5\u8ba1\u7b97\u4e3a\u4e3b\uff1a\u52a0\u5bc6\u89e3\u5bc6\u3001\u6392\u5e8f IO\u5bc6\u96c6\u578b\uff1a\u6267\u884c\u6d41\u7684\u5927\u90e8\u5206\u4efb\u52a1\uff0c\u662f\u4ee5IO\u4e3a\u4e3b\uff0c\u5237\u78c1\u76d8\uff0c\u8bbf\u95ee\u6570\u636e\u5e93\uff0c\u8bbf\u95ee\u7f51\u7edc\u3002 \u4f5c\u4e1a\u7b14\u8bb0","title":"\u7ebf\u7a0b"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_7","text":"","title":"\u4e00\u3001\u7b2c\u4e00\u5929"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#1","text":"\u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 ^= 32; \u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5c0f\u5199 : \u5b57\u7b26 |= 32; \u5c0f\u5199\u53d8\u5927\u5199\u3001\u5927\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 &= -33; \u4f8b\u5982\uff1a ASCII\u7801\u8868\u4e2d\u5927\u5199\u7684A\u662f65\uff0c\u5c0f\u5199\u7684a\u662f97\uff0c\u5b83\u4eec\u7684\u5dee\u662f32 65 | 32 \u8f6c\u4e3a\u4e8c\u8fdb\u5236\uff08\u63098\u4f4d\u6765\u7b97\uff09\u53ef\u4ee5\u5f97\u5230 0100 0001 | 0010 0000 = 0110 0001 = 97 = a","title":"1 \u5b57\u6bcd\u53d8\u6362"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#day2","text":"","title":"\u4e8c\u3001day2"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_8","text":"int searchInsert(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; int ans = numsSize; while(left <= right) { int mid = ((right - left) >> 1) + left; if(target <= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; }","title":"\u641c\u7d22\u63d2\u5165\u4f4d\u7f6e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#day3","text":"","title":"\u4e09\u3001day3"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/","text":"\u5b57\u7b26\u4e32\u76f8\u5173\u7ec3\u4e60 \u5b57\u7b26\u4e32\u5339\u914d\u7b97\u6cd5 \u66b4\u529b\u7b97\u6cd5 #include <stdio.h> #include <string.h> #include <assert.h> //\u66b4\u529b\u5339\u914d\u65b9\u6cd5 // str \u4e3b\u4e32 sub \u5b50\u4e32 int BF(char *str, char *sub) { assert(str != NULL && sub != NULL); if (str == NULL || sub == NULL) { return -1; } int i = 0; int j = 0; int strLen = strlen(str); int subLen = strlen(sub); while (i < strLen && j < subLen) { if (str[i] == sub[j]) { i++; j++; } else //\u56de\u9000 { i = i - j + 1; // \u6ce8\u610f\u56de\u9000\u7684\u662f\u591a\u5c11 j = 0; } } if (j >= subLen) { return i - j; } return -1; } int main() { printf(\"%d\\n\", BF(\"ababcabcdabcde\", \"abcd\")); printf(\"%d\\n\", BF(\"ababcabcdabcde\", \"abcde\")); printf(\"%d\\n\", BF(\"ababcabcdabcde\", \"abcdef\")); return 0; } KMP\u7b97\u6cd5 \uff08\u53c2\u8003PDFKMP\u7b97\u6cd5\uff09 \u5f15\u51fanext\u6570\u7ec4 KMP \u7684\u7cbe\u9ad3\u5c31\u662f next \u6570\u7ec4\uff1a\u4e5f\u5c31\u662f\u7528 next[j] = k;\u6765\u8868\u793a\uff0c\u4e0d\u540c\u7684 j \u6765\u5bf9\u5e94\u4e00\u4e2a K \u503c\uff0c \u8fd9\u4e2a K \u5c31\u662f\u4f60\u5c06\u6765\u8981\u79fb\u52a8\u7684 j\u8981\u79fb\u52a8\u7684\u4f4d\u7f6e\u3002 \u800c K \u7684\u503c\u662f\u8fd9\u6837\u6c42\u7684\uff1a \u89c4\u5219\uff1a\u627e\u5230\u5339\u914d\u6210\u529f\u90e8\u5206\u7684\u4e24\u4e2a\u76f8\u7b49\u7684\u771f\u5b50\u4e32\uff08\u4e0d\u5305\u542b\u672c\u8eab\uff09\uff0c\u4e00\u4e2a\u4ee5\u4e0b\u6807 0 \u5b57\u7b26\u5f00\u59cb\uff0c\u53e6\u4e00\u4e2a\u4ee5 j-1 \u4e0b\u6807\u5b57\u7b26\u7ed3\u5c3e\u3002 \u4e0d\u7ba1\u4ec0\u4e48\u6570\u636e next[0] = -1;next[1] = 0;\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u4ee5\u4e0b\u6807\u6765\u5f00\u59cb\uff0c\u800c\u8bf4\u5230\u7684\u7b2c\u51e0\u4e2a\u7b2c\u51e0\u4e2a\u662f\u4ece 1 \u5f00\u59cb\uff1b 17\u7535\u8bdd\u53f7\u7801\u7684\u7ec4\u5408 \u7535\u8bdd\u53f7\u7801\u7684\u5b57\u6bcd\u7ec4\u5408 \uff0c \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b\u6570\u5b572-9\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u6240\u6709\u5b83\u80fd\u8868\u793a\u7684\u5b57\u6bcd\u7ec4\u5408\u3002\u7b54\u6848\u53ef\u4ee5\u6309\u4efb\u610f\u987a\u5e8f\u8fd4\u56de\u3002\u6570\u5b57\u548c\u5b57\u6bcd\u5bf9\u5e94\u7684\u6620\u5c04\u5982\u4e0b\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1adigits = \"23\" \u8f93\u51fa\uff1a[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1adigits = \"\" \u8f93\u51fa\uff1a[] \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1adigits = \"2\" \u8f93\u51fa\uff1a[\"a\",\"b\",\"c\"] unorder_map\u601d\u8def class Solution { public: vector<string> letterCombinations(string digits) { vector<string> combinations; if (digits.empty()) { return combinations; } unordered_map<char, string> phoneMap{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations; } void backtrack(vector<string>& combinations, const unordered_map<char, string>& phoneMap, const string& digits, int index, string& combination) { if (index == digits.length()) { combinations.push_back(combination); } else { char digit = digits[index]; const string& letters = phoneMap.at(digit); for (const char& letter: letters) { combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination); combination.pop_back(); } } } }; \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 \u89e3\u6cd5\u4e8c vector & string class Solution { public: vector<string> phone={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> letterCombinations(string digits) { if(digits.size() == 0) return {}; vector<string> res; res.push_back(\"\"); for(char digit : digits) { vector<string> temp; for(string s : res) // s\u662f\u524d\u9762\u4e00\u8f6e\u5b57\u7b26\u9009\u62e9\u7ed3\u679c { for(char candidate : phone[digit - '0']) //candidate \u662f\u672c\u8f6e\u5f85\u9009\u62e9\u7684\u5b57\u7b26 { temp.push_back(s + candidate); } } res.swap(temp); //\u4ea4\u6362temp \u548c res } return res; } }; \u7406\u89e3swap","title":"\u5b57\u7b26\u4e32\u76f8\u5173\u7ec3\u4e60"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#_1","text":"","title":"\u5b57\u7b26\u4e32\u76f8\u5173\u7ec3\u4e60"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#_2","text":"","title":"\u5b57\u7b26\u4e32\u5339\u914d\u7b97\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#_3","text":"#include <stdio.h> #include <string.h> #include <assert.h> //\u66b4\u529b\u5339\u914d\u65b9\u6cd5 // str \u4e3b\u4e32 sub \u5b50\u4e32 int BF(char *str, char *sub) { assert(str != NULL && sub != NULL); if (str == NULL || sub == NULL) { return -1; } int i = 0; int j = 0; int strLen = strlen(str); int subLen = strlen(sub); while (i < strLen && j < subLen) { if (str[i] == sub[j]) { i++; j++; } else //\u56de\u9000 { i = i - j + 1; // \u6ce8\u610f\u56de\u9000\u7684\u662f\u591a\u5c11 j = 0; } } if (j >= subLen) { return i - j; } return -1; } int main() { printf(\"%d\\n\", BF(\"ababcabcdabcde\", \"abcd\")); printf(\"%d\\n\", BF(\"ababcabcdabcde\", \"abcde\")); printf(\"%d\\n\", BF(\"ababcabcdabcde\", \"abcdef\")); return 0; }","title":"\u66b4\u529b\u7b97\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#kmp","text":"\uff08\u53c2\u8003PDFKMP\u7b97\u6cd5\uff09 \u5f15\u51fanext\u6570\u7ec4 KMP \u7684\u7cbe\u9ad3\u5c31\u662f next \u6570\u7ec4\uff1a\u4e5f\u5c31\u662f\u7528 next[j] = k;\u6765\u8868\u793a\uff0c\u4e0d\u540c\u7684 j \u6765\u5bf9\u5e94\u4e00\u4e2a K \u503c\uff0c \u8fd9\u4e2a K \u5c31\u662f\u4f60\u5c06\u6765\u8981\u79fb\u52a8\u7684 j\u8981\u79fb\u52a8\u7684\u4f4d\u7f6e\u3002 \u800c K \u7684\u503c\u662f\u8fd9\u6837\u6c42\u7684\uff1a \u89c4\u5219\uff1a\u627e\u5230\u5339\u914d\u6210\u529f\u90e8\u5206\u7684\u4e24\u4e2a\u76f8\u7b49\u7684\u771f\u5b50\u4e32\uff08\u4e0d\u5305\u542b\u672c\u8eab\uff09\uff0c\u4e00\u4e2a\u4ee5\u4e0b\u6807 0 \u5b57\u7b26\u5f00\u59cb\uff0c\u53e6\u4e00\u4e2a\u4ee5 j-1 \u4e0b\u6807\u5b57\u7b26\u7ed3\u5c3e\u3002 \u4e0d\u7ba1\u4ec0\u4e48\u6570\u636e next[0] = -1;next[1] = 0;\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u4ee5\u4e0b\u6807\u6765\u5f00\u59cb\uff0c\u800c\u8bf4\u5230\u7684\u7b2c\u51e0\u4e2a\u7b2c\u51e0\u4e2a\u662f\u4ece 1 \u5f00\u59cb\uff1b","title":"KMP\u7b97\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#17","text":"\u7535\u8bdd\u53f7\u7801\u7684\u5b57\u6bcd\u7ec4\u5408 \uff0c \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b\u6570\u5b572-9\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u6240\u6709\u5b83\u80fd\u8868\u793a\u7684\u5b57\u6bcd\u7ec4\u5408\u3002\u7b54\u6848\u53ef\u4ee5\u6309\u4efb\u610f\u987a\u5e8f\u8fd4\u56de\u3002\u6570\u5b57\u548c\u5b57\u6bcd\u5bf9\u5e94\u7684\u6620\u5c04\u5982\u4e0b\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1adigits = \"23\" \u8f93\u51fa\uff1a[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1adigits = \"\" \u8f93\u51fa\uff1a[] \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1adigits = \"2\" \u8f93\u51fa\uff1a[\"a\",\"b\",\"c\"]","title":"17\u7535\u8bdd\u53f7\u7801\u7684\u7ec4\u5408"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#unorder_map","text":"class Solution { public: vector<string> letterCombinations(string digits) { vector<string> combinations; if (digits.empty()) { return combinations; } unordered_map<char, string> phoneMap{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations; } void backtrack(vector<string>& combinations, const unordered_map<char, string>& phoneMap, const string& digits, int index, string& combination) { if (index == digits.length()) { combinations.push_back(combination); } else { char digit = digits[index]; const string& letters = phoneMap.at(digit); for (const char& letter: letters) { combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination); combination.pop_back(); } } } }; \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"unorder_map\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/#vector-string","text":"class Solution { public: vector<string> phone={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> letterCombinations(string digits) { if(digits.size() == 0) return {}; vector<string> res; res.push_back(\"\"); for(char digit : digits) { vector<string> temp; for(string s : res) // s\u662f\u524d\u9762\u4e00\u8f6e\u5b57\u7b26\u9009\u62e9\u7ed3\u679c { for(char candidate : phone[digit - '0']) //candidate \u662f\u672c\u8f6e\u5f85\u9009\u62e9\u7684\u5b57\u7b26 { temp.push_back(s + candidate); } } res.swap(temp); //\u4ea4\u6362temp \u548c res } return res; } }; \u7406\u89e3swap","title":"\u89e3\u6cd5\u4e8c vector &amp; string"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/","text":"\u9898\u76ee-\u4e24\u4e2a\u6570\u7ec4\u7684\u4ea4\u96c6 LeetCode349 \u4e24\u4e2a\u6570\u7ec4\u7684\u4ea4\u96c6 \u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4\uff0c\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u5b83\u4eec\u7684\u4ea4\u96c6\u3002 \u5b9e\u4f8b\uff1a \u8f93\u5165\uff1anums1 = [4,9,5], nums2 = [9,4,9,8,4] \u8f93\u51fa\uff1a[9,4] \u5206\u6790 \u501f\u52a9\u793a\u4f8b \u8f93\u5165\uff1anums1 = [1,2,2,1], nums2 = [2,2] \u8f93\u51fa\uff1a[2] \u5206\u6790\u7ed3\u679c\u5982\u4e0b\u56fe\uff1a \u4e24\u4e2a\u8fed\u4ee3\u5668\u6307\u9488\u4ece\u5934\u5f00\u59cb\u6bd4\u8f83\uff0c \u82e5\u4e0d\u76f8\u7b49\uff0c\u5c0f\u5f97\u5c31\u662f\u5dee\u5f02\u96c6\u5408\uff0c\u7136\u540e \u5c0f\u7684\u5411\u540e\u8d70\u4e00\u6b65 \uff1b \u82e5\u76f8\u7b49\uff0c\u5c31\u662f\u4ea4\u96c6\u7684\u6210\u5458\uff0c \u4e24\u4e2a\u6307\u9488\u4e00\u8d77\u5411\u540e\u8d70 \u3002 \u7ea2\u8272\u6846\u8868\u793a\u81ea\u5df1\u7684vector\uff0c\u7528\u6765\u5b58\u653e\u9700\u8981\u8fd4\u56de\u7684\u4ea4\u96c6\u3002 \u53c2\u8003\u89e3\u6cd5 class Solution { public: vector<int> intersection(vector<int>& nums1, vector<int>& nums2) { set<int> s1; for(auto e: nums1) s1.insert(e);//s1 set set<int> s2; for(auto e: nums2) s2.insert(e); //s2 set vector<int> vRet;//\u5b58\u653e\u8fd4\u56de\u6570\u7ec4 auto it1 = s1.begin(); auto it2 = s2.begin(); while(it1 != s1.end() && it2 != s2.end()){ if(*it1 < *it2) it1++; else if(*it1 > *it2) it2++; else { vRet.push_back(*it2); it1++; it2++; } } return vRet; } }; \u9898\u76ee-\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4 LeetCode88 \u76f4\u63a5\u5408\u5e76+\u6392\u5e8f class Solution { public: void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { for (int i = 0; i != n; ++i) { nums1[m + i] = nums2[i]; } sort(nums1.begin(), nums1.end()); } }; \u53cc\u6307\u9488 \u5229\u7528\u5df2\u77e5\u6570\u7ec4\u5df2\u7ecf\u6392\u5e8f\u6027\u8d28\u5b8c\u6210\u4e0b\u5217\u95ee\u9898 class Solution { public: void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { int p1 = 0; int p2 = 0; int sorted[m+n]; int cur; //\u8bb0\u5f55\u5f53\u524d\u503c\uff0c\u7528\u4e8e\u63d2\u5165sorted\u6570\u7ec4\u4e2d while(p1 < m || p2 < n) { if(p1 == m) //\u6392\u5b8cnums1 { cur = nums2[p2++]; } else if(p2 == n) { cur = nums1[p1++]; } else if(nums1[p1] < nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1+p2-1] = cur; } for(int i = 0; i != m+n; ++i) { nums1[i] = sorted[i]; } } }; \u9898\u76ee-\u6709\u5e8f\u6570\u7ec4\u7684\u5e73\u65b9 977 \u6392\u5e8f class Solution { public: vector<int> sortedSquares(vector<int>& nums) { vector<int> ans; for (int num: nums) { ans.push_back(num * num); } sort(ans.begin(), ans.end()); return ans; } }; \u53cc\u6307\u9488 \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 class Solution { public: vector<int> sortedSquares(vector<int>& nums) { int n = nums.size(); int negative = -1; for (int i = 0; i < n; ++i) { if (nums[i] < 0) { negative = i; } else { break; } } vector<int> ans; int i = negative, j = negative + 1; while (i >= 0 || j < n) { if (i < 0) { ans.push_back(nums[j] * nums[j]); ++j; } else if (j == n) { ans.push_back(nums[i] * nums[i]); --i; } else if (nums[i] * nums[i] < nums[j] * nums[j]) { ans.push_back(nums[i] * nums[i]); --i; } else { ans.push_back(nums[j] * nums[j]); ++j; } } return ans; } }; \u53cc\u6307\u9488 \u540c\u6837\u5730\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u6307\u9488\u5206\u522b\u6307\u5411\u4f4d\u7f6e 00 \u548c n-1n\u22121\uff0c\u6bcf\u6b21\u6bd4\u8f83\u4e24\u4e2a\u6307\u9488\u5bf9\u5e94\u7684\u6570\uff0c\u9009\u62e9\u8f83\u5927\u7684\u90a3\u4e2a\u9006\u5e8f\u653e\u5165\u7b54\u6848\u5e76\u79fb\u52a8\u6307\u9488\u3002\u8fd9\u79cd\u65b9\u6cd5\u65e0\u9700\u5904\u7406\u67d0\u4e00\u6307\u9488\u79fb\u52a8\u81f3\u8fb9\u754c\u7684\u60c5\u51b5\uff0c\u8bfb\u8005\u53ef\u4ee5\u4ed4\u7ec6\u601d\u8003\u5176\u7cbe\u9ad3\u6240\u5728\u3002 class Solution { public: vector<int> sortedSquares(vector<int>& nums) { int n = nums.size(); vector<int> ans(n); for (int i = 0, j = n - 1, pos = n - 1; i <= j;) { if (nums[i] * nums[i] > nums[j] * nums[j]) { ans[pos] = nums[i] * nums[i]; ++i; } else { ans[pos] = nums[j] * nums[j]; --j; } --pos; } return ans; } }; \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 \u9898\u4e00 \u9898\u76ee\u94fe\u63a5 \u5728\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4array\u4e2d\uff08\u6bcf\u4e2a\u4e00\u7ef4\u6570\u7ec4\u7684\u957f\u5ea6\u76f8\u540c\uff09\uff0c\u6bcf\u4e00\u884c\u90fd\u6309\u7167\u4ece\u5de6\u5230\u53f3\u9012\u589e\u7684\u987a\u5e8f\u6392\u5e8f\uff0c\u6bcf\u4e00\u5217\u90fd\u6309\u7167\u4ece\u4e0a\u5230\u4e0b\u9012\u589e\u7684\u987a\u5e8f\u6392\u5e8f\u3002\u8bf7\u5b8c\u6210\u4e00\u4e2a\u51fd\u6570\uff0c\u8f93\u5165\u8fd9\u6837\u7684\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u6570\uff0c\u5224\u65ad\u6570\u7ec4\u4e2d\u662f\u5426\u542b\u6709\u8be5\u6574\u6570\u3002 [ [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15] ] \u7ed9\u5b9a target = 7\uff0c\u8fd4\u56de true\u3002 \u7ed9\u5b9a target = 3\uff0c\u8fd4\u56de false\u3002 \u66b4\u529b\u904d\u5386\u6cd5 class Solution { public: bool Find(int target, vector<vector<int> > array) { //\u66b4\u529b\u904d\u5386 if(array.size() == 0 || array[0].size() == 0) return false; for(const auto& vec : array){ for(const auto& val : vec){ if(val == target) return true; } } return false;//\u672a\u627e\u5230 } }; \u4e8c\u5206\u6cd5 \u53c2\u8003\u4e00\u7ef4\u6570\u7ec4\u4e8c\u5206\u6cd5\u601d\u8def\uff0c\u5047\u8bbe\u5bf9\u4e8e\u4e8c\u7ef4\u6570\u7ec4\u4e5f\u6210\u7acb\u3002 \u5224\u65adtarget\u548cmid\u4f4d\u7f6e\u6570\u5b57\u5927\u5c0f\uff0c\u4f5c\u6bd4\u8f83\u3002 \u67e5\u627e\u7684\u8fc7\u7a0b\u672c\u8d28\u5c31\u662f\u6392\u9664\u8fc7\u7a0b\uff0c\u8c01\u6392\u9664\u591a\uff0c\u9009\u8c01\u3002 class Solution { public: // \u4e8c\u5206\u6cd5\u641c\u7d22 bool BinarySearch(vector<int> arr,int target) { int left = 0,right = arr.size()-1; //[left,right] while(left <= right) { int mid = left + ((right-left)>>1); if(arr[mid] == target) return true; else if(arr[mid] < target) left = mid + 1; //\u53f3\u8fb9\u627e else right = mid - 1; //\u5de6\u8fb9\u627e } return false; } bool Find(int target, vector<vector<int> > array) { //\u89e3\u6cd5\u4e8c\uff1a\u4e8c\u5206\u6cd5\u89e3\u7b54\u8fc7\u7a0b for(auto e : array) { if(BinarySearch(e, target)) return true; } return false; } }; \u601d\u8def\u53c2\u8003\u4ee3\u7801 arr 0 1 2 3 4 5 0 val 1 2 3 4 \u5176\u4e2dval\u5de6\u8fb9\u7684\u5c0f\u4e8eval\uff0cval\u4e0b\u8fb9\u7684\u5927\u4e8eval\uff0c\u6bd4\u8f83\u89c4\u5219\u5982\u4e0b \u82e5target > val \uff0c\u8868\u660etarget\u5728\u66f4\u5927\u4f4d\u7f6e\uff0c\u6240\u4ee5\u884c\u52a0\u4e00\uff0c\u5411\u4e0b\u79fb\u52a8\u67e5\u8be2 \u82e5target < val \uff0c\u8868\u660etarget\u5728\u66f4\u5c0f\u4f4d\u7f6e\uff0c\u6240\u4ee5\u5217\u51cf\u4e00\uff0c\u5411\u5de6\u79fb\u52a8\u67e5\u8be2 class Solution { public: bool Find(int target, vector<vector<int> > array) { int i = 0; int j = array[0].size() - 1;//\u7b2c\u4e00\u884c\u6700\u53f3\u5143\u7d20\uff0c\u8868\u793a\u7b2c\u4e00\u884c\u6700\u5927\u5143\u7d20 while(i < array.size() && j >= 0){ if(target < array[i][j]) //array[i][j]\u4e3a\u5f53\u524d\u884c\u6700\u5927\uff0c\u5f53\u524d\u5217\u6700\u5c0f j--;//\u5217\u524d\u79fb else if(target > array[i][j]) i++; //\u884c\u4e0b\u79fb\u52a8 else return true; } return false; } }; \u590d\u6742\u5ea6\u5206\u6790\uff1a \u5176\u4e2d\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(m+n),\u5bf9\u5e94\u4e8em\u884c\uff0cn\u5217\u7684\u79fb\u52a8\u6b21\u6570 \u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a1\uff0c\u56e0\u4e3a\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cfval \u9898\u4e8c \u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u6570\u5b57 \u628a\u4e00\u4e2a\u6570\u7ec4\u6700\u5f00\u59cb\u7684\u82e5\u5e72\u4e2a\u5143\u7d20\u642c\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u6570\u7ec4\u7684\u65cb\u8f6c\u3002 \u8f93\u5165\u4e00\u4e2a\u975e\u9012\u51cf\u6392\u5e8f\u7684\u6570\u7ec4\u7684\u4e00\u4e2a\u65cb \u8f6c\uff0c\u8f93\u51fa\u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u5143\u7d20\u3002 \u4f8b\u5982\u6570\u7ec4{3,4,5,1,2}\u4e3a{1,2,3,4,5}\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8be5\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u4e3a1\u3002 NOTE\uff1a\u7ed9\u51fa\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u4e8e0\uff0c\u82e5\u6570\u7ec4\u5927\u5c0f\u4e3a0\uff0c\u8bf7\u8fd4\u56de0\u3002 \u66b4\u529b\u89e3\u6cd5 \u5f3a\u884c\u904d\u5386\u6570\u7ec4\uff0c\u627e\u51fa\u6700\u5c0f\u503c\u3002\u6ca1\u6709\u7528\u5230\u9898\u76ee\u5df2\u7ed9\u7684\u542b\u4e49\uff0c\u975e\u964d\u5e8f\uff0c\u65cb\u8f6c\u7b49\u5173\u952e\u5b57\u3002 class Solution { public: int minNumberInRotateArray(vector<int> rotateArray) { //\u66b4\u529b\u89e3\u6cd5 int val = rotateArray[0]; for(const auto& arr : rotateArray){ if(arr < val) val = arr; } return val; } }; class Solution { public: int minNumberInRotateArray(vector<int> rotateArray) { //\u66b4\u529b\u89e3\u6cd5 if(rotateArray.empty()) return 0; for(int i = 0; i < rotateArray.size()-1; i++){ if(rotateArray[i] > rotateArray[i+1]) return rotateArray[i+1]; } return rotateArray[0]; } }; \u4e8c\u5206\u67e5\u627e \u56e0\u4e3a\u6570\u7ec4\u975e\u9012\u51cf\uff0c\u65cb\u8f6c\u540e\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5de6\u534a\u90e8\u5206\u975e\u9012\u51cf\uff0c\u6709\u534a\u90e8\u5206\u975e\u9012\u51cf\u3002\u5e76\u4e14\uff0c\u524d\u534a\u90e8\u5206\u6574\u4f53\u5927\u4e8e\u540e\u534a\u90e8\u5206\u3002\u6240\u4ee5\u638c\u63e1\u6b64\u89c4\u5f8b\uff0c\u7ee7\u7eed\u67e5\u627e\uff0c\u5b9a\u4e49left\u6307\u5411\u6700\u5de6\u4fa7\uff0cright\u6307\u5411\u6700\u53f3\u4fa7\uff0cmid\u6307\u5411\u4e2d\u95f4\u4f4d\u7f6e\u3002\u82e5\uff1a arr[mid] >= arr[left] \u8bf4\u660emid\u4f4d\u7f6e\u5728\u539f\u6570\u7ec4\u524d\u534a\u90e8\u5206\uff0c\u8fdb\u4e00\u6b65\u8bf4\u660e\uff0c\u76ee\u6807\u6700\u5c0f\u503c\uff0c\u5728mid\u7684\u53f3\u4fa7\uff0c\u8ba9left=mid arr[mid] < arr[left] \u8bf4\u660emid\u4f4d\u7f6e\u5728\u539f\u6570\u7ec4\u540e\u534a\u90e8\u5206\uff0c\u8fdb\u4e00\u6b65\u8bf4\u660e\uff0c\u76ee\u6807\u6700\u5c0f\u503c\uff0c\u5728mid\u7684\u5de6\u4fa7\uff0c\u8ba9right=mid \u53c2\u8003\u4ee3\u7801\uff1a class Solution { public: int minNumberInRotateArray(vector<int> rotateArray) { //\u4e8c\u5206\u6cd5 if(rotateArray.empty()) return 0; int left = 0; int right = rotateArray.size() - 1; int mid = 0; while(rotateArray[left] >= rotateArray[right]){ if(right - left == 1){ //\u8868\u660e\u5de6\u53f3\u4e24\u6570\u76f8\u90bb mid = right; break; } mid = left + ((right - left) >> 1); //\u65e0\u6cd5\u5224\u65ad\u76ee\u6807\u5728mid\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7 if(rotateArray[mid] == rotateArray[left] && rotateArray[right] == rotateArray[left]){ int res = rotateArray[left]; for(int i = left+1; i<right; i++){ if(res > rotateArray[i]) res = rotateArray[i]; } return res; } //\u5224\u65ad\u6765\u81ea\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9 if(rotateArray[mid] >= rotateArray[left]) //mid\u5728\u5de6\u534a\u90e8\u5206 left = mid; else //mid\u5728\u6709\u534a\u90e8\u5206 right = mid; }//end of while return rotateArray[mid]; } }; \u9898\u4e09 \u8c03\u6574\u6570\u7ec4\u987a\u5e8f\u4f7f\u5947\u6570\u4f4d\u4f4d\u4e8e\u5076\u6570\u4f4d\u524d\u9762 \u8f85\u52a9\u6570\u7ec4 class Solution { public: void reOrderArray(vector<int> &array) { //\u8f85\u52a9\u6570\u7ec4 \u7a7a\u95f4 vector<int> vec; for(const int& v : array){ if(v & 1) vec.push_back(v);//\u5c06\u5947\u6570\u63d2\u5165vec\u4e2d } for(const int& v: array){ if(!(v & 1)) vec.push_back(v);//\u540e\u9762\u7ee7\u7eed\u63d2\u5165vec\u4e2d } //\u5c06vec\u62f7\u8d1d\u5230array copy(vec.begin(), vec.end(), array.begin()); } }; \u601d\u8def in-place \u4f7f\u7528\u63d2\u5165\u6392\u5e8f\u7684\u601d\u60f3\uff0c\u4f46\u662f\u6211\u89c9\u5f97\u8fd9\u4e2a\u4ee3\u7801\u6709\u70b9\u7f3a\u9677\u3002 class Solution { public: void reOrderArray(vector<int> &array) { //\u63d2\u5165\u6392\u5e8f\u601d\u8def int k = 0;//\u6807\u8bb0\u5947\u6570\u4e0b\u6807\u4f4d\u7f6e for(int i = 0; i < array.size(); i++){ if((array[i] & 1) == 1){ //\u5947\u6570 int temp = array[i]; //\u8bb0\u5f55\u6b64\u6570 int j = i; //\u8bb0\u5f55\u5947\u6570\u4f4d\u7f6e\u7684\u4e0b\u6807 while(j > k){ array[j] = array[j-1]; // \u5c06\u5947\u6570\u524d\u9762\u7684\u5076\u6570\u79fb\u52a8 j--; } array[k++] = temp; } } } }; class Solution { public: void reOrderArray(vector<int> &array) { int i = 0; for (int j=0; j<array.size(); ++j) { if (array[j]&1) { int tmp = array[j]; for (int k=j-1; k>=i; --k) { array[k+1] = array[k]; } array[i++] = tmp; } } } };","title":"\u9898\u76ee-\u4e24\u4e2a\u6570\u7ec4\u7684\u4ea4\u96c6"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#-","text":"LeetCode349 \u4e24\u4e2a\u6570\u7ec4\u7684\u4ea4\u96c6 \u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4\uff0c\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u5b83\u4eec\u7684\u4ea4\u96c6\u3002 \u5b9e\u4f8b\uff1a \u8f93\u5165\uff1anums1 = [4,9,5], nums2 = [9,4,9,8,4] \u8f93\u51fa\uff1a[9,4]","title":"\u9898\u76ee-\u4e24\u4e2a\u6570\u7ec4\u7684\u4ea4\u96c6"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_1","text":"\u501f\u52a9\u793a\u4f8b \u8f93\u5165\uff1anums1 = [1,2,2,1], nums2 = [2,2] \u8f93\u51fa\uff1a[2] \u5206\u6790\u7ed3\u679c\u5982\u4e0b\u56fe\uff1a \u4e24\u4e2a\u8fed\u4ee3\u5668\u6307\u9488\u4ece\u5934\u5f00\u59cb\u6bd4\u8f83\uff0c \u82e5\u4e0d\u76f8\u7b49\uff0c\u5c0f\u5f97\u5c31\u662f\u5dee\u5f02\u96c6\u5408\uff0c\u7136\u540e \u5c0f\u7684\u5411\u540e\u8d70\u4e00\u6b65 \uff1b \u82e5\u76f8\u7b49\uff0c\u5c31\u662f\u4ea4\u96c6\u7684\u6210\u5458\uff0c \u4e24\u4e2a\u6307\u9488\u4e00\u8d77\u5411\u540e\u8d70 \u3002 \u7ea2\u8272\u6846\u8868\u793a\u81ea\u5df1\u7684vector\uff0c\u7528\u6765\u5b58\u653e\u9700\u8981\u8fd4\u56de\u7684\u4ea4\u96c6\u3002","title":"\u5206\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_2","text":"class Solution { public: vector<int> intersection(vector<int>& nums1, vector<int>& nums2) { set<int> s1; for(auto e: nums1) s1.insert(e);//s1 set set<int> s2; for(auto e: nums2) s2.insert(e); //s2 set vector<int> vRet;//\u5b58\u653e\u8fd4\u56de\u6570\u7ec4 auto it1 = s1.begin(); auto it2 = s2.begin(); while(it1 != s1.end() && it2 != s2.end()){ if(*it1 < *it2) it1++; else if(*it1 > *it2) it2++; else { vRet.push_back(*it2); it1++; it2++; } } return vRet; } };","title":"\u53c2\u8003\u89e3\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#-_1","text":"LeetCode88","title":"\u9898\u76ee-\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_3","text":"class Solution { public: void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { for (int i = 0; i != n; ++i) { nums1[m + i] = nums2[i]; } sort(nums1.begin(), nums1.end()); } };","title":"\u76f4\u63a5\u5408\u5e76+\u6392\u5e8f"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_4","text":"\u5229\u7528\u5df2\u77e5\u6570\u7ec4\u5df2\u7ecf\u6392\u5e8f\u6027\u8d28\u5b8c\u6210\u4e0b\u5217\u95ee\u9898 class Solution { public: void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { int p1 = 0; int p2 = 0; int sorted[m+n]; int cur; //\u8bb0\u5f55\u5f53\u524d\u503c\uff0c\u7528\u4e8e\u63d2\u5165sorted\u6570\u7ec4\u4e2d while(p1 < m || p2 < n) { if(p1 == m) //\u6392\u5b8cnums1 { cur = nums2[p2++]; } else if(p2 == n) { cur = nums1[p1++]; } else if(nums1[p1] < nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1+p2-1] = cur; } for(int i = 0; i != m+n; ++i) { nums1[i] = sorted[i]; } } };","title":"\u53cc\u6307\u9488"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#-_2","text":"977","title":"\u9898\u76ee-\u6709\u5e8f\u6570\u7ec4\u7684\u5e73\u65b9"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_5","text":"class Solution { public: vector<int> sortedSquares(vector<int>& nums) { vector<int> ans; for (int num: nums) { ans.push_back(num * num); } sort(ans.begin(), ans.end()); return ans; } };","title":"\u6392\u5e8f"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_6","text":"\u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 class Solution { public: vector<int> sortedSquares(vector<int>& nums) { int n = nums.size(); int negative = -1; for (int i = 0; i < n; ++i) { if (nums[i] < 0) { negative = i; } else { break; } } vector<int> ans; int i = negative, j = negative + 1; while (i >= 0 || j < n) { if (i < 0) { ans.push_back(nums[j] * nums[j]); ++j; } else if (j == n) { ans.push_back(nums[i] * nums[i]); --i; } else if (nums[i] * nums[i] < nums[j] * nums[j]) { ans.push_back(nums[i] * nums[i]); --i; } else { ans.push_back(nums[j] * nums[j]); ++j; } } return ans; } };","title":"\u53cc\u6307\u9488"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_7","text":"\u540c\u6837\u5730\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u6307\u9488\u5206\u522b\u6307\u5411\u4f4d\u7f6e 00 \u548c n-1n\u22121\uff0c\u6bcf\u6b21\u6bd4\u8f83\u4e24\u4e2a\u6307\u9488\u5bf9\u5e94\u7684\u6570\uff0c\u9009\u62e9\u8f83\u5927\u7684\u90a3\u4e2a\u9006\u5e8f\u653e\u5165\u7b54\u6848\u5e76\u79fb\u52a8\u6307\u9488\u3002\u8fd9\u79cd\u65b9\u6cd5\u65e0\u9700\u5904\u7406\u67d0\u4e00\u6307\u9488\u79fb\u52a8\u81f3\u8fb9\u754c\u7684\u60c5\u51b5\uff0c\u8bfb\u8005\u53ef\u4ee5\u4ed4\u7ec6\u601d\u8003\u5176\u7cbe\u9ad3\u6240\u5728\u3002 class Solution { public: vector<int> sortedSquares(vector<int>& nums) { int n = nums.size(); vector<int> ans(n); for (int i = 0, j = n - 1, pos = n - 1; i <= j;) { if (nums[i] * nums[i] > nums[j] * nums[j]) { ans[pos] = nums[i] * nums[i]; ++i; } else { ans[pos] = nums[j] * nums[j]; --j; } --pos; } return ans; } }; \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u53cc\u6307\u9488"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_8","text":"\u9898\u76ee\u94fe\u63a5 \u5728\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4array\u4e2d\uff08\u6bcf\u4e2a\u4e00\u7ef4\u6570\u7ec4\u7684\u957f\u5ea6\u76f8\u540c\uff09\uff0c\u6bcf\u4e00\u884c\u90fd\u6309\u7167\u4ece\u5de6\u5230\u53f3\u9012\u589e\u7684\u987a\u5e8f\u6392\u5e8f\uff0c\u6bcf\u4e00\u5217\u90fd\u6309\u7167\u4ece\u4e0a\u5230\u4e0b\u9012\u589e\u7684\u987a\u5e8f\u6392\u5e8f\u3002\u8bf7\u5b8c\u6210\u4e00\u4e2a\u51fd\u6570\uff0c\u8f93\u5165\u8fd9\u6837\u7684\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u6570\uff0c\u5224\u65ad\u6570\u7ec4\u4e2d\u662f\u5426\u542b\u6709\u8be5\u6574\u6570\u3002 [ [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15] ] \u7ed9\u5b9a target = 7\uff0c\u8fd4\u56de true\u3002 \u7ed9\u5b9a target = 3\uff0c\u8fd4\u56de false\u3002","title":"\u9898\u4e00"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_9","text":"class Solution { public: bool Find(int target, vector<vector<int> > array) { //\u66b4\u529b\u904d\u5386 if(array.size() == 0 || array[0].size() == 0) return false; for(const auto& vec : array){ for(const auto& val : vec){ if(val == target) return true; } } return false;//\u672a\u627e\u5230 } };","title":"\u66b4\u529b\u904d\u5386\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_10","text":"\u53c2\u8003\u4e00\u7ef4\u6570\u7ec4\u4e8c\u5206\u6cd5\u601d\u8def\uff0c\u5047\u8bbe\u5bf9\u4e8e\u4e8c\u7ef4\u6570\u7ec4\u4e5f\u6210\u7acb\u3002 \u5224\u65adtarget\u548cmid\u4f4d\u7f6e\u6570\u5b57\u5927\u5c0f\uff0c\u4f5c\u6bd4\u8f83\u3002 \u67e5\u627e\u7684\u8fc7\u7a0b\u672c\u8d28\u5c31\u662f\u6392\u9664\u8fc7\u7a0b\uff0c\u8c01\u6392\u9664\u591a\uff0c\u9009\u8c01\u3002 class Solution { public: // \u4e8c\u5206\u6cd5\u641c\u7d22 bool BinarySearch(vector<int> arr,int target) { int left = 0,right = arr.size()-1; //[left,right] while(left <= right) { int mid = left + ((right-left)>>1); if(arr[mid] == target) return true; else if(arr[mid] < target) left = mid + 1; //\u53f3\u8fb9\u627e else right = mid - 1; //\u5de6\u8fb9\u627e } return false; } bool Find(int target, vector<vector<int> > array) { //\u89e3\u6cd5\u4e8c\uff1a\u4e8c\u5206\u6cd5\u89e3\u7b54\u8fc7\u7a0b for(auto e : array) { if(BinarySearch(e, target)) return true; } return false; } }; \u601d\u8def\u53c2\u8003\u4ee3\u7801 arr 0 1 2 3 4 5 0 val 1 2 3 4 \u5176\u4e2dval\u5de6\u8fb9\u7684\u5c0f\u4e8eval\uff0cval\u4e0b\u8fb9\u7684\u5927\u4e8eval\uff0c\u6bd4\u8f83\u89c4\u5219\u5982\u4e0b \u82e5target > val \uff0c\u8868\u660etarget\u5728\u66f4\u5927\u4f4d\u7f6e\uff0c\u6240\u4ee5\u884c\u52a0\u4e00\uff0c\u5411\u4e0b\u79fb\u52a8\u67e5\u8be2 \u82e5target < val \uff0c\u8868\u660etarget\u5728\u66f4\u5c0f\u4f4d\u7f6e\uff0c\u6240\u4ee5\u5217\u51cf\u4e00\uff0c\u5411\u5de6\u79fb\u52a8\u67e5\u8be2 class Solution { public: bool Find(int target, vector<vector<int> > array) { int i = 0; int j = array[0].size() - 1;//\u7b2c\u4e00\u884c\u6700\u53f3\u5143\u7d20\uff0c\u8868\u793a\u7b2c\u4e00\u884c\u6700\u5927\u5143\u7d20 while(i < array.size() && j >= 0){ if(target < array[i][j]) //array[i][j]\u4e3a\u5f53\u524d\u884c\u6700\u5927\uff0c\u5f53\u524d\u5217\u6700\u5c0f j--;//\u5217\u524d\u79fb else if(target > array[i][j]) i++; //\u884c\u4e0b\u79fb\u52a8 else return true; } return false; } }; \u590d\u6742\u5ea6\u5206\u6790\uff1a \u5176\u4e2d\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(m+n),\u5bf9\u5e94\u4e8em\u884c\uff0cn\u5217\u7684\u79fb\u52a8\u6b21\u6570 \u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a1\uff0c\u56e0\u4e3a\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cfval","title":"\u4e8c\u5206\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_11","text":"\u628a\u4e00\u4e2a\u6570\u7ec4\u6700\u5f00\u59cb\u7684\u82e5\u5e72\u4e2a\u5143\u7d20\u642c\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u6570\u7ec4\u7684\u65cb\u8f6c\u3002 \u8f93\u5165\u4e00\u4e2a\u975e\u9012\u51cf\u6392\u5e8f\u7684\u6570\u7ec4\u7684\u4e00\u4e2a\u65cb \u8f6c\uff0c\u8f93\u51fa\u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u5143\u7d20\u3002 \u4f8b\u5982\u6570\u7ec4{3,4,5,1,2}\u4e3a{1,2,3,4,5}\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8be5\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u4e3a1\u3002 NOTE\uff1a\u7ed9\u51fa\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u4e8e0\uff0c\u82e5\u6570\u7ec4\u5927\u5c0f\u4e3a0\uff0c\u8bf7\u8fd4\u56de0\u3002","title":"\u9898\u4e8c \u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u6570\u5b57"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_12","text":"\u5f3a\u884c\u904d\u5386\u6570\u7ec4\uff0c\u627e\u51fa\u6700\u5c0f\u503c\u3002\u6ca1\u6709\u7528\u5230\u9898\u76ee\u5df2\u7ed9\u7684\u542b\u4e49\uff0c\u975e\u964d\u5e8f\uff0c\u65cb\u8f6c\u7b49\u5173\u952e\u5b57\u3002 class Solution { public: int minNumberInRotateArray(vector<int> rotateArray) { //\u66b4\u529b\u89e3\u6cd5 int val = rotateArray[0]; for(const auto& arr : rotateArray){ if(arr < val) val = arr; } return val; } }; class Solution { public: int minNumberInRotateArray(vector<int> rotateArray) { //\u66b4\u529b\u89e3\u6cd5 if(rotateArray.empty()) return 0; for(int i = 0; i < rotateArray.size()-1; i++){ if(rotateArray[i] > rotateArray[i+1]) return rotateArray[i+1]; } return rotateArray[0]; } };","title":"\u66b4\u529b\u89e3\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_13","text":"\u56e0\u4e3a\u6570\u7ec4\u975e\u9012\u51cf\uff0c\u65cb\u8f6c\u540e\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5de6\u534a\u90e8\u5206\u975e\u9012\u51cf\uff0c\u6709\u534a\u90e8\u5206\u975e\u9012\u51cf\u3002\u5e76\u4e14\uff0c\u524d\u534a\u90e8\u5206\u6574\u4f53\u5927\u4e8e\u540e\u534a\u90e8\u5206\u3002\u6240\u4ee5\u638c\u63e1\u6b64\u89c4\u5f8b\uff0c\u7ee7\u7eed\u67e5\u627e\uff0c\u5b9a\u4e49left\u6307\u5411\u6700\u5de6\u4fa7\uff0cright\u6307\u5411\u6700\u53f3\u4fa7\uff0cmid\u6307\u5411\u4e2d\u95f4\u4f4d\u7f6e\u3002\u82e5\uff1a arr[mid] >= arr[left] \u8bf4\u660emid\u4f4d\u7f6e\u5728\u539f\u6570\u7ec4\u524d\u534a\u90e8\u5206\uff0c\u8fdb\u4e00\u6b65\u8bf4\u660e\uff0c\u76ee\u6807\u6700\u5c0f\u503c\uff0c\u5728mid\u7684\u53f3\u4fa7\uff0c\u8ba9left=mid arr[mid] < arr[left] \u8bf4\u660emid\u4f4d\u7f6e\u5728\u539f\u6570\u7ec4\u540e\u534a\u90e8\u5206\uff0c\u8fdb\u4e00\u6b65\u8bf4\u660e\uff0c\u76ee\u6807\u6700\u5c0f\u503c\uff0c\u5728mid\u7684\u5de6\u4fa7\uff0c\u8ba9right=mid \u53c2\u8003\u4ee3\u7801\uff1a class Solution { public: int minNumberInRotateArray(vector<int> rotateArray) { //\u4e8c\u5206\u6cd5 if(rotateArray.empty()) return 0; int left = 0; int right = rotateArray.size() - 1; int mid = 0; while(rotateArray[left] >= rotateArray[right]){ if(right - left == 1){ //\u8868\u660e\u5de6\u53f3\u4e24\u6570\u76f8\u90bb mid = right; break; } mid = left + ((right - left) >> 1); //\u65e0\u6cd5\u5224\u65ad\u76ee\u6807\u5728mid\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7 if(rotateArray[mid] == rotateArray[left] && rotateArray[right] == rotateArray[left]){ int res = rotateArray[left]; for(int i = left+1; i<right; i++){ if(res > rotateArray[i]) res = rotateArray[i]; } return res; } //\u5224\u65ad\u6765\u81ea\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9 if(rotateArray[mid] >= rotateArray[left]) //mid\u5728\u5de6\u534a\u90e8\u5206 left = mid; else //mid\u5728\u6709\u534a\u90e8\u5206 right = mid; }//end of while return rotateArray[mid]; } };","title":"\u4e8c\u5206\u67e5\u627e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_14","text":"","title":"\u9898\u4e09 \u8c03\u6574\u6570\u7ec4\u987a\u5e8f\u4f7f\u5947\u6570\u4f4d\u4f4d\u4e8e\u5076\u6570\u4f4d\u524d\u9762"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_15","text":"class Solution { public: void reOrderArray(vector<int> &array) { //\u8f85\u52a9\u6570\u7ec4 \u7a7a\u95f4 vector<int> vec; for(const int& v : array){ if(v & 1) vec.push_back(v);//\u5c06\u5947\u6570\u63d2\u5165vec\u4e2d } for(const int& v: array){ if(!(v & 1)) vec.push_back(v);//\u540e\u9762\u7ee7\u7eed\u63d2\u5165vec\u4e2d } //\u5c06vec\u62f7\u8d1d\u5230array copy(vec.begin(), vec.end(), array.begin()); } };","title":"\u8f85\u52a9\u6570\u7ec4"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/#_16","text":"in-place \u4f7f\u7528\u63d2\u5165\u6392\u5e8f\u7684\u601d\u60f3\uff0c\u4f46\u662f\u6211\u89c9\u5f97\u8fd9\u4e2a\u4ee3\u7801\u6709\u70b9\u7f3a\u9677\u3002 class Solution { public: void reOrderArray(vector<int> &array) { //\u63d2\u5165\u6392\u5e8f\u601d\u8def int k = 0;//\u6807\u8bb0\u5947\u6570\u4e0b\u6807\u4f4d\u7f6e for(int i = 0; i < array.size(); i++){ if((array[i] & 1) == 1){ //\u5947\u6570 int temp = array[i]; //\u8bb0\u5f55\u6b64\u6570 int j = i; //\u8bb0\u5f55\u5947\u6570\u4f4d\u7f6e\u7684\u4e0b\u6807 while(j > k){ array[j] = array[j-1]; // \u5c06\u5947\u6570\u524d\u9762\u7684\u5076\u6570\u79fb\u52a8 j--; } array[k++] = temp; } } } }; class Solution { public: void reOrderArray(vector<int> &array) { int i = 0; for (int j=0; j<array.size(); ++j) { if (array[j]&1) { int tmp = array[j]; for (int k=j-1; k>=i; --k) { array[k+1] = array[k]; } array[i++] = tmp; } } } };","title":"\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/094%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"code /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ /** * Note: The returned array must be malloced, assume caller calls free(). */ //\u8ba1\u7b97\u8282\u70b9\u6570\uff0c\u65b9\u4fbf\u5f00\u7a7a\u95f4 int TreeSize(struct TreeNode* root) { if(root == NULL) return 0; return TreeSize(root->left) + TreeSize(root->right) + 1; } typedef struct TreeNode TreeNode; void inoder(TreeNode* root,int* res,int* resSize) { if(root == NULL) return NULL;//\u7a7a\u6811 inoder(root->left,res,resSize);// res[(*resSize)++] = root->val;// inoder(root->right,res,resSize);// } int* inorderTraversal(struct TreeNode* root, int* returnSize){ *returnSize = TreeSize(root);//\u8bb0\u5f55\u8282\u70b9\u6570 int *res = (int*)malloc(sizeof(int)*(*returnSize));//\u5f00\u8f9f\u8282\u70b9\u6570\u76ee\u5927\u5c0f\u7684\u7a7a\u95f4 int * a = 0; inoder(root,res,&a);//\u51fd\u6570\u5b9e\u73b0 return res;//\u8fd4\u56de\u6570\u7ec4 }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/094%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ /** * Note: The returned array must be malloced, assume caller calls free(). */ //\u8ba1\u7b97\u8282\u70b9\u6570\uff0c\u65b9\u4fbf\u5f00\u7a7a\u95f4 int TreeSize(struct TreeNode* root) { if(root == NULL) return 0; return TreeSize(root->left) + TreeSize(root->right) + 1; } typedef struct TreeNode TreeNode; void inoder(TreeNode* root,int* res,int* resSize) { if(root == NULL) return NULL;//\u7a7a\u6811 inoder(root->left,res,resSize);// res[(*resSize)++] = root->val;// inoder(root->right,res,resSize);// } int* inorderTraversal(struct TreeNode* root, int* returnSize){ *returnSize = TreeSize(root);//\u8bb0\u5f55\u8282\u70b9\u6570 int *res = (int*)malloc(sizeof(int)*(*returnSize));//\u5f00\u8f9f\u8282\u70b9\u6570\u76ee\u5927\u5c0f\u7684\u7a7a\u95f4 int * a = 0; inoder(root,res,&a);//\u51fd\u6570\u5b9e\u73b0 return res;//\u8fd4\u56de\u6570\u7ec4 }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","text":"code /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* p, struct TreeNode* q){ if(p == NULL && q == NULL) return true;//\u5982\u679c\u6811\u4e3a\u7a7a if(p == NULL || q == NULL) return false;//\u5176\u4e2d\u4e00\u4e2a\u6811\u4e3a\u7a7a if(p->val != q->val) return false; //\u9012\u5f52\u4e0b\u4e00\u5c42 return isSameTree(p->left,q->left) && isSameTree(p->right,q->right); }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* p, struct TreeNode* q){ if(p == NULL && q == NULL) return true;//\u5982\u679c\u6811\u4e3a\u7a7a if(p == NULL || q == NULL) return false;//\u5176\u4e2d\u4e00\u4e2a\u6811\u4e3a\u7a7a if(p->val != q->val) return false; //\u9012\u5f52\u4e0b\u4e00\u5c42 return isSameTree(p->left,q->left) && isSameTree(p->right,q->right); }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","text":"\u601d\u8def \u7f16\u5199height\u51fd\u6570\u8ba1\u7b97\u6df1\u5ea6 \u4f9d\u6b21\u6c42\u51fa\u5de6\u53f3\u5b50\u6811\u4e2d\u7684\u9ad8\u5ea6 abs\u7edd\u5bf9\u503c\u63a7\u5236\u5de6\u53f3\u5b50\u6811\u7684\u6df1\u5ea6\u4e4b\u5dee\u5c0f\u4e8e\u7b49\u4e8e1 \u6c42\u51fa\u5de6\u53f3\u5b50\u6811\u4e2d\u6700\u5927\u6df1\u5ea6+1\u8fd4\u56de\uff0c\u52a01\u8868\u793a\u662f\u4ece\u6839\u5f00\u59cb\u7b97\u6df1\u5ea6 \u6700\u540e\u51fd\u6570\u8c03\u7528\u5224\u65ad\u6811\u7684\u6df1\u5ea6 code /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int height(struct TreeNode* root) { if(root == NULL) return 0;//\u7a7a\u6811\uff0c\u8fd4\u56de\u8282\u70b9\u6df1\u5ea6\u4e3a0\uff0c int HeightLeft = height(root->left); int HeightRight = height(root->right); //\u5224\u65ad\u5de6\u53f3\u5b50\u6811\u6df1\u5ea6\u4e4b\u5dee\u5c0f\u4e8e\u7b49\u4e8e1\uff0c\u5de6\u53f3\u5b50\u6811\u81f3\u5c11\u9ad8\u4e3a0 if(HeightLeft >= 0 && HeightRight >= 0 && abs(HeightLeft-HeightRight)<=1){ return fmax(HeightLeft,HeightRight)+1;//\u5de6\u53f3\u5b50\u6811\u4e2d\u8f83\u9ad8\u7684+1\uff0c\u5373\u4e3a\u4ece\u6839\u5f00\u59cb\u7b97\u7684\u6df1\u5ea6 } else{ return -1; } } bool isBalanced(struct TreeNode* root){ return height(root) >= 0;//\u5e94\u8be5\u662f0\uff0c\u56e0\u4e3a\u7a7a\u65f6\u8fd4\u56de\u4e5f\u662f0 }","title":"\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/#_1","text":"\u7f16\u5199height\u51fd\u6570\u8ba1\u7b97\u6df1\u5ea6 \u4f9d\u6b21\u6c42\u51fa\u5de6\u53f3\u5b50\u6811\u4e2d\u7684\u9ad8\u5ea6 abs\u7edd\u5bf9\u503c\u63a7\u5236\u5de6\u53f3\u5b50\u6811\u7684\u6df1\u5ea6\u4e4b\u5dee\u5c0f\u4e8e\u7b49\u4e8e1 \u6c42\u51fa\u5de6\u53f3\u5b50\u6811\u4e2d\u6700\u5927\u6df1\u5ea6+1\u8fd4\u56de\uff0c\u52a01\u8868\u793a\u662f\u4ece\u6839\u5f00\u59cb\u7b97\u6df1\u5ea6 \u6700\u540e\u51fd\u6570\u8c03\u7528\u5224\u65ad\u6811\u7684\u6df1\u5ea6","title":"\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int height(struct TreeNode* root) { if(root == NULL) return 0;//\u7a7a\u6811\uff0c\u8fd4\u56de\u8282\u70b9\u6df1\u5ea6\u4e3a0\uff0c int HeightLeft = height(root->left); int HeightRight = height(root->right); //\u5224\u65ad\u5de6\u53f3\u5b50\u6811\u6df1\u5ea6\u4e4b\u5dee\u5c0f\u4e8e\u7b49\u4e8e1\uff0c\u5de6\u53f3\u5b50\u6811\u81f3\u5c11\u9ad8\u4e3a0 if(HeightLeft >= 0 && HeightRight >= 0 && abs(HeightLeft-HeightRight)<=1){ return fmax(HeightLeft,HeightRight)+1;//\u5de6\u53f3\u5b50\u6811\u4e2d\u8f83\u9ad8\u7684+1\uff0c\u5373\u4e3a\u4ece\u6839\u5f00\u59cb\u7b97\u7684\u6df1\u5ea6 } else{ return -1; } } bool isBalanced(struct TreeNode* root){ return height(root) >= 0;//\u5e94\u8be5\u662f0\uff0c\u56e0\u4e3a\u7a7a\u65f6\u8fd4\u56de\u4e5f\u662f0 }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/","text":"\u5206\u6790 \u6ce8\u610f\u4ee5\u4e0b\u4e24\u4e2a\u4ee3\u7801\u5728\u5904\u7406\u6570\u7ec4\u65f6\u7684\u7279\u70b9\u3002\u5176\u4e2d\u8ba1\u7b97\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u518d\u5f00\u8f9f\u66f4\u4e3a\u8282\u7ea6\u7a7a\u95f4\u3002 code /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ //\u8ba1\u7b97\u8282\u70b9\u6570\uff0c\u65b9\u4fbf\u5f00\u7a7a\u95f4 int TreeSize(struct TreeNode* root) { if(root == NULL) return 0; return TreeSize(root->left) + TreeSize(root->right) + 1; } typedef struct TreeNode TreeNode; void postoder(TreeNode* root,int* res,int* resSize) { if(root == NULL) return NULL;//\u7a7a\u6811 postoder(root->left,res,resSize);// postoder(root->right,res,resSize);// res[(*resSize)++] = root->val;// } int* postorderTraversal(struct TreeNode* root, int* returnSize){ *returnSize = TreeSize(root); int *res = (int *)malloc(sizeof(int)*(*returnSize));//\u5f00\u8f9f\u6811\u5927\u5c0f\u7684\u7a7a\u95f4 int *a = 0; postoder(root,res,&a);//\u51fd\u6570\u5b9e\u73b0 return res;//\u8fd4\u56de\u6570\u7ec4 } /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ typedef struct TreeNode TreeNode; void postoder(TreeNode* root,int* res,int* resSize) { if(root == NULL) return NULL;//\u7a7a\u6811 postoder(root->left,res,resSize);// postoder(root->right,res,resSize);// res[(*resSize)++] = root->val;// } int* postorderTraversal(struct TreeNode* root, int* returnSize){ int *res = malloc(sizeof(int)*2000); *returnSize = 0; postoder(root,res,returnSize);//\u51fd\u6570\u5b9e\u73b0 return res;//\u8fd4\u56de\u6570\u7ec4 }","title":"\u5206\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/#_1","text":"\u6ce8\u610f\u4ee5\u4e0b\u4e24\u4e2a\u4ee3\u7801\u5728\u5904\u7406\u6570\u7ec4\u65f6\u7684\u7279\u70b9\u3002\u5176\u4e2d\u8ba1\u7b97\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u518d\u5f00\u8f9f\u66f4\u4e3a\u8282\u7ea6\u7a7a\u95f4\u3002","title":"\u5206\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ //\u8ba1\u7b97\u8282\u70b9\u6570\uff0c\u65b9\u4fbf\u5f00\u7a7a\u95f4 int TreeSize(struct TreeNode* root) { if(root == NULL) return 0; return TreeSize(root->left) + TreeSize(root->right) + 1; } typedef struct TreeNode TreeNode; void postoder(TreeNode* root,int* res,int* resSize) { if(root == NULL) return NULL;//\u7a7a\u6811 postoder(root->left,res,resSize);// postoder(root->right,res,resSize);// res[(*resSize)++] = root->val;// } int* postorderTraversal(struct TreeNode* root, int* returnSize){ *returnSize = TreeSize(root); int *res = (int *)malloc(sizeof(int)*(*returnSize));//\u5f00\u8f9f\u6811\u5927\u5c0f\u7684\u7a7a\u95f4 int *a = 0; postoder(root,res,&a);//\u51fd\u6570\u5b9e\u73b0 return res;//\u8fd4\u56de\u6570\u7ec4 } /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ typedef struct TreeNode TreeNode; void postoder(TreeNode* root,int* res,int* resSize) { if(root == NULL) return NULL;//\u7a7a\u6811 postoder(root->left,res,resSize);// postoder(root->right,res,resSize);// res[(*resSize)++] = root->val;// } int* postorderTraversal(struct TreeNode* root, int* returnSize){ int *res = malloc(sizeof(int)*2000); *returnSize = 0; postoder(root,res,returnSize);//\u51fd\u6570\u5b9e\u73b0 return res;//\u8fd4\u56de\u6570\u7ec4 }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/572%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/","text":"\u56fe\u89e3: code /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* s,struct TreeNode*t) { if(s == NULL && t == NULL) return true; if(s == NULL || t == NULL) return false; if(s->val == t->val) return isSameTree(s->left,t->left) && isSameTree(s->right,t->right); else return false; } //\u53e6\u4e00\u4e2a\u6811\u7684\u5b50\u6811 bool isSubtree(struct TreeNode* s, struct TreeNode* t){ //\u7a7a if(s == NULL) return false; else return isSameTree(s,t) || isSubtree(s->left,t) || isSubtree(s->right,t); }","title":"\u56fe\u89e3:"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/572%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/#_1","text":"","title":"\u56fe\u89e3:"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/572%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* s,struct TreeNode*t) { if(s == NULL && t == NULL) return true; if(s == NULL || t == NULL) return false; if(s->val == t->val) return isSameTree(s->left,t->left) && isSameTree(s->right,t->right); else return false; } //\u53e6\u4e00\u4e2a\u6811\u7684\u5b50\u6811 bool isSubtree(struct TreeNode* s, struct TreeNode* t){ //\u7a7a if(s == NULL) return false; else return isSameTree(s,t) || isSubtree(s->left,t) || isSubtree(s->right,t); }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/BinaryTree/newcodertest/","text":"#include<stdio.h> #include<stdlib.h> typedef struct TreeNode { char val; struct TreeNode* left; struct TreeNode* right; }TreeNode; TreeNode* CreateTree(char* arr,int *pi) { if (arr[*pi] == '#') { return NULL; } else { TreeNode * root = (TreeNode *)malloc (sizeof(TreeNode)); root->val = arr[(*pi)++] ; root->left = CreateTree(arr,pi); ++(*pi); root->right = CreateTree(arr,pi); return root; } } void Inorder(TreeNode * root) { if (root == NULL) { return ; } Inorder(root->left); printf(\"%c \",root->val); Inorder(root->right); } int main() { char arr[100]; scanf(\"%s\",arr); int i = 0; TreeNode * root = CreateTree(arr,&i); Inorder(root); return 0; }","title":"Newcodertest"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","text":"code \u601d\u8def\u4e00\uff1a\u9012\u5f52 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ if(l1 == NULL){ return l2; } else if(l2 == NULL){ return l1; } else if(l1->val < l2->val){ l1->next = mergeTwoLists(l1->next,l2); return l1; } else{//l2 small l2->next = mergeTwoLists(l1,l2->next); return l2; } } \u601d\u8def\u4e8c\uff1a\u54e8\u5175\u4f4d\u5934\u8282\u70b9 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* cur = head; while(l1 && l2){ if(l1->val < l2->val){ cur->next =l1; l1 = l1->next; } else{ cur->next = l2; l2 = l2->next; } cur = cur->next; } if(l1 == NULL) cur->next = l2; else if(l2 == NULL) cur ->next =l1; return head->next; } \u601d\u8def\u4e09\uff1a \u53cc\u6307\u9488 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ if(l1 == NULL) return l2; if(l2 == NULL) return l1; struct ListNode* head = NULL,*tail = NULL; //\u5904\u7406head \u548c tail \u4e0e\u4e24\u4e2a\u94fe\u8868\u4e4b\u95f4\u5173\u7cfb\u3002 if(l1->val < l2->val){ head = tail = l1; l1 = l1->next; } else{ head = tail = l2; l2 = l2->next; } while(l1 && l2){ if(l1->val < l2->val){ tail->next = l1;//\u5c0f\u7684\u5c3e\u63d2 l1 = l1->next; } else{ tail->next = l2; l2 = l2->next; } tail = tail->next; } //\u5269\u4f59\u90e8\u5206\u5c3e\u63d2 if(l1) tail->next = l1; if(l2) tail->next = l2; return head; } \u9898\u76ee\u53ca\u5206\u6790 \u601d\u8def\u4e00\uff1a\u9012\u5f52 \u601d\u8def\u4e8c\uff1a\u54e8\u5175\u4f4d\u5934\u8282\u70b9 \u601d\u8def\u4e09\uff1a\u53cc\u6307\u9488","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#code","text":"","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_1","text":"struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ if(l1 == NULL){ return l2; } else if(l2 == NULL){ return l1; } else if(l1->val < l2->val){ l1->next = mergeTwoLists(l1->next,l2); return l1; } else{//l2 small l2->next = mergeTwoLists(l1,l2->next); return l2; } }","title":"\u601d\u8def\u4e00\uff1a\u9012\u5f52"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_2","text":"struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* cur = head; while(l1 && l2){ if(l1->val < l2->val){ cur->next =l1; l1 = l1->next; } else{ cur->next = l2; l2 = l2->next; } cur = cur->next; } if(l1 == NULL) cur->next = l2; else if(l2 == NULL) cur ->next =l1; return head->next; }","title":"\u601d\u8def\u4e8c\uff1a\u54e8\u5175\u4f4d\u5934\u8282\u70b9"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_3","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ if(l1 == NULL) return l2; if(l2 == NULL) return l1; struct ListNode* head = NULL,*tail = NULL; //\u5904\u7406head \u548c tail \u4e0e\u4e24\u4e2a\u94fe\u8868\u4e4b\u95f4\u5173\u7cfb\u3002 if(l1->val < l2->val){ head = tail = l1; l1 = l1->next; } else{ head = tail = l2; l2 = l2->next; } while(l1 && l2){ if(l1->val < l2->val){ tail->next = l1;//\u5c0f\u7684\u5c3e\u63d2 l1 = l1->next; } else{ tail->next = l2; l2 = l2->next; } tail = tail->next; } //\u5269\u4f59\u90e8\u5206\u5c3e\u63d2 if(l1) tail->next = l1; if(l2) tail->next = l2; return head; }","title":"\u601d\u8def\u4e09\uff1a \u53cc\u6307\u9488"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_4","text":"","title":"\u9898\u76ee\u53ca\u5206\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_5","text":"","title":"\u601d\u8def\u4e00\uff1a\u9012\u5f52"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_6","text":"","title":"\u601d\u8def\u4e8c\uff1a\u54e8\u5175\u4f4d\u5934\u8282\u70b9"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/021%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/#_7","text":"","title":"\u601d\u8def\u4e09\uff1a\u53cc\u6307\u9488"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/","text":"code /** * Definition for a Node. * struct Node { * int val; * struct Node *next; * struct Node *random; * }; */ struct Node* copyRandomList(struct Node* head) { if(head == NULL) return NULL; //1.\u62f7\u8d1d\u8282\u70b9\u8fde\u63a5\u5230\u539f\u8282\u70b9\u540e\u9762 struct Node* cur = head; while(cur) { struct Node *next = cur->next; struct Node* copy = (struct Node*)malloc(sizeof(struct Node)); copy->val = cur->val; cur->next = copy; copy->next = next; cur=next;//\u8fed\u4ee3 } //2.\u5904\u7406\u4e00\u4e0b\u62f7\u8d1d\u8282\u70b9\u7684random cur = head; while(cur){ struct Node *copy = cur->next; if(cur->random == NULL) copy->random = NULL; else copy->random = cur->random->next; cur=copy->next; } //3.\u62c6\u89e3\u51fa\u590d\u5236\u94fe\u8868 cur = head; struct Node * copyHead ,*copyTail; copyHead = copyTail = (struct Node*)malloc(sizeof(struct Node)); while(cur){ struct Node *copy = cur->next; struct Node *next = copy->next; //\u5c3e\u63d2 copyTail->next = copy; copyTail = copyTail->next; cur->next = next; cur = next; } struct Node* gurad = copyHead; copyHead = copyHead->next; free(gurad); return copyHead; }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/#code","text":"/** * Definition for a Node. * struct Node { * int val; * struct Node *next; * struct Node *random; * }; */ struct Node* copyRandomList(struct Node* head) { if(head == NULL) return NULL; //1.\u62f7\u8d1d\u8282\u70b9\u8fde\u63a5\u5230\u539f\u8282\u70b9\u540e\u9762 struct Node* cur = head; while(cur) { struct Node *next = cur->next; struct Node* copy = (struct Node*)malloc(sizeof(struct Node)); copy->val = cur->val; cur->next = copy; copy->next = next; cur=next;//\u8fed\u4ee3 } //2.\u5904\u7406\u4e00\u4e0b\u62f7\u8d1d\u8282\u70b9\u7684random cur = head; while(cur){ struct Node *copy = cur->next; if(cur->random == NULL) copy->random = NULL; else copy->random = cur->random->next; cur=copy->next; } //3.\u62c6\u89e3\u51fa\u590d\u5236\u94fe\u8868 cur = head; struct Node * copyHead ,*copyTail; copyHead = copyTail = (struct Node*)malloc(sizeof(struct Node)); while(cur){ struct Node *copy = cur->next; struct Node *next = copy->next; //\u5c3e\u63d2 copyTail->next = copy; copyTail = copyTail->next; cur->next = next; cur = next; } struct Node* gurad = copyHead; copyHead = copyHead->next; free(gurad); return copyHead; }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","text":"code /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ bool hasCycle(struct ListNode *head) { struct ListNode *fast = head ,*slow = head; while(fast && fast->next )//\u5224\u65adfast\u6307\u9488\u4e0d\u7a7a { slow=slow->next; fast=fast->next->next; if(slow==fast){ return true; } } return false; } analyse \u5206\u6790\u5feb\u6162\u6307\u9488","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ bool hasCycle(struct ListNode *head) { struct ListNode *fast = head ,*slow = head; while(fast && fast->next )//\u5224\u65adfast\u6307\u9488\u4e0d\u7a7a { slow=slow->next; fast=fast->next->next; if(slow==fast){ return true; } } return false; }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#analyse","text":"\u5206\u6790\u5feb\u6162\u6307\u9488","title":"analyse"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","text":"code /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { if(headA == NULL || headB == NULL) return NULL; struct ListNode* curA = headA,*curB = headB; int lenA = 0, lenB = 0; while(curA->next){//\u8ba1\u7b97\u94fe\u8868A\u957f\u5ea6 curA = curA->next; lenA++; } while(curB->next){ curB = curB->next; lenB++; } struct ListNode* longList = headA,*shortList = headB; if(lenB > lenA){ longList = headB; shortList = headA; } int gap = abs(lenB-lenA);//\u8ba1\u7b97\u76f8\u5dee while(gap--){//\u957f\u7684\u5148\u8d70 longList = longList->next; } while(longList != shortList){ longList = longList->next; shortList = shortList->next; } return shortList; } analyse \u5148\u8ba1\u7b97\u51fa\u6765\u4e24\u4e2a\u94fe\u8868\u957f\u5ea6\uff0c\u8ba9\u957f\u7684\u5148\u8d70\u5dee\u8ddd\u6b65\uff0c\u7136\u540e\u4e24\u8005\u4e00\u8d77\u8d70\uff0c\u6bd4\u8f83\u662f\u5426\u76f8\u7b49\u3002","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { if(headA == NULL || headB == NULL) return NULL; struct ListNode* curA = headA,*curB = headB; int lenA = 0, lenB = 0; while(curA->next){//\u8ba1\u7b97\u94fe\u8868A\u957f\u5ea6 curA = curA->next; lenA++; } while(curB->next){ curB = curB->next; lenB++; } struct ListNode* longList = headA,*shortList = headB; if(lenB > lenA){ longList = headB; shortList = headA; } int gap = abs(lenB-lenA);//\u8ba1\u7b97\u76f8\u5dee while(gap--){//\u957f\u7684\u5148\u8d70 longList = longList->next; } while(longList != shortList){ longList = longList->next; shortList = shortList->next; } return shortList; }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/#analyse","text":"\u5148\u8ba1\u7b97\u51fa\u6765\u4e24\u4e2a\u94fe\u8868\u957f\u5ea6\uff0c\u8ba9\u957f\u7684\u5148\u8d70\u5dee\u8ddd\u6b65\uff0c\u7136\u540e\u4e24\u8005\u4e00\u8d77\u8d70\uff0c\u6bd4\u8f83\u662f\u5426\u76f8\u7b49\u3002","title":"analyse"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/","text":"\u9898\u76ee \u4ee3\u7801 \u601d\u8def\u4e00\uff1a struct ListNode* removeElements(struct ListNode* head, int val){ struct ListNode* cur = head; struct ListNode* prev = NULL; while(cur) { if(cur->val == val)// find it { struct ListNode* next = cur->next; if(prev == NULL)//cur \u524d\u7684prev\u4e3a\u7a7a cur\u662f\u5934 { free(cur); head = next; cur = next; } else //cur\u4e0d\u662f\u5934 \u8981\u5220\u9664\u7684\u4e0d\u662f\u5934\u7ed3\u70b9 { prev->next = next; free(cur); cur = next; } } else//not find next move { prev = cur; cur = cur->next; } } return head; } \u601d\u8def\u4e8c\uff1a\u5e26\u54e8\u5175\u4f4d\u7684\u65b9\u5f0f struct ListNode* removeElements(struct ListNode* head, int val){ struct ListNode* guardHead = (struct ListNode*)malloc(sizeof(struct ListNode)); guardHead->next = head; struct ListNode* cur = head; struct ListNode* prev = guardHead; while(cur) { if(cur->val == val) { struct ListNode* next = cur->next; prev->next = next; free(cur); cur = next; } else { prev = cur; cur = cur->next; } } head = guardHead->next; free(guardHead); return head; }","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/#_1","text":"","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/#_2","text":"","title":"\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/#_3","text":"struct ListNode* removeElements(struct ListNode* head, int val){ struct ListNode* cur = head; struct ListNode* prev = NULL; while(cur) { if(cur->val == val)// find it { struct ListNode* next = cur->next; if(prev == NULL)//cur \u524d\u7684prev\u4e3a\u7a7a cur\u662f\u5934 { free(cur); head = next; cur = next; } else //cur\u4e0d\u662f\u5934 \u8981\u5220\u9664\u7684\u4e0d\u662f\u5934\u7ed3\u70b9 { prev->next = next; free(cur); cur = next; } } else//not find next move { prev = cur; cur = cur->next; } } return head; }","title":"\u601d\u8def\u4e00\uff1a"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/#_4","text":"struct ListNode* removeElements(struct ListNode* head, int val){ struct ListNode* guardHead = (struct ListNode*)malloc(sizeof(struct ListNode)); guardHead->next = head; struct ListNode* cur = head; struct ListNode* prev = guardHead; while(cur) { if(cur->val == val) { struct ListNode* next = cur->next; prev->next = next; free(cur); cur = next; } else { prev = cur; cur = cur->next; } } head = guardHead->next; free(guardHead); return head; }","title":"\u601d\u8def\u4e8c\uff1a\u5e26\u54e8\u5175\u4f4d\u7684\u65b9\u5f0f"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","text":"\u9898\u76ee \u53cd\u8f6c\u94fe\u8868 \u53cd\u8f6c\u4e00\u4e2a\u5355\u94fe\u8868\u3002 \u793a\u4f8b: \u8f93\u5165: 1->2->3->4->5->NULL \u8f93\u51fa: 5->4->3->2->1->NULL \u8fdb\u9636: \u4f60\u53ef\u4ee5\u8fed\u4ee3\u6216\u9012\u5f52\u5730\u53cd\u8f6c\u94fe\u8868\u3002\u4f60\u80fd\u5426\u7528\u4e24\u79cd\u65b9\u6cd5\u89e3\u51b3\u8fd9\u9053\u9898\uff1f \u4ee3\u7801 \u601d\u8def\u4e00\uff1a\u4e09\u6307\u9488 struct ListNode* reverseList(struct ListNode* head){ if(head == NULL || head->next == NULL)//\u65e0\u8282\u70b9 \u6216\u4e00\u4e2a\u8282\u70b9 return head; struct ListNode* n1 = NULL, *n2 = head, *n3 = head ->next; while(n2) { // n2->next = n1; //\u8fed\u4ee3 n1 = n2; n2 = n3; if(n3) n3 = n3->next; } return n1; } \u601d\u8def\u4e8c\uff1a\u5934\u63d2\u6cd5 struct ListNode* reverseList(struct ListNode* head){ struct ListNode* cur =head; struct ListNode* newHead = NULL; while(cur) { struct ListNode *next = cur->next; cur->next = newHead; //\u540e\u9762\u6307\u5411\u524d\u9762 newHead = cur;//\u65b0\u5934 cur = next; } return newHead; } \u601d\u8def\u4e09\uff1a\u9012\u5f52 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head->next == NULL) { return head; } struct ListNode* newHead = reverseList(head->next); head->next->next = head; head->next = NULL; return newHead; }","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#_1","text":"\u53cd\u8f6c\u94fe\u8868 \u53cd\u8f6c\u4e00\u4e2a\u5355\u94fe\u8868\u3002 \u793a\u4f8b: \u8f93\u5165: 1->2->3->4->5->NULL \u8f93\u51fa: 5->4->3->2->1->NULL \u8fdb\u9636: \u4f60\u53ef\u4ee5\u8fed\u4ee3\u6216\u9012\u5f52\u5730\u53cd\u8f6c\u94fe\u8868\u3002\u4f60\u80fd\u5426\u7528\u4e24\u79cd\u65b9\u6cd5\u89e3\u51b3\u8fd9\u9053\u9898\uff1f","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#_2","text":"","title":"\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#_3","text":"struct ListNode* reverseList(struct ListNode* head){ if(head == NULL || head->next == NULL)//\u65e0\u8282\u70b9 \u6216\u4e00\u4e2a\u8282\u70b9 return head; struct ListNode* n1 = NULL, *n2 = head, *n3 = head ->next; while(n2) { // n2->next = n1; //\u8fed\u4ee3 n1 = n2; n2 = n3; if(n3) n3 = n3->next; } return n1; }","title":"\u601d\u8def\u4e00\uff1a\u4e09\u6307\u9488"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#_4","text":"struct ListNode* reverseList(struct ListNode* head){ struct ListNode* cur =head; struct ListNode* newHead = NULL; while(cur) { struct ListNode *next = cur->next; cur->next = newHead; //\u540e\u9762\u6307\u5411\u524d\u9762 newHead = cur;//\u65b0\u5934 cur = next; } return newHead; }","title":"\u601d\u8def\u4e8c\uff1a\u5934\u63d2\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#_5","text":"struct ListNode* reverseList(struct ListNode* head) { if (head == NULL || head->next == NULL) { return head; } struct ListNode* newHead = reverseList(head->next); head->next->next = head; head->next = NULL; return newHead; }","title":"\u601d\u8def\u4e09\uff1a\u9012\u5f52"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/876%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/","text":"\u9898\u76ee \u94fe\u8868\u7684\u4e2d\u95f4\u7ed3\u70b9 \u7ed9\u5b9a\u4e00\u4e2a\u5934\u7ed3\u70b9\u4e3a head \u7684\u975e\u7a7a\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u95f4\u7ed3\u70b9\u3002 \u5982\u679c\u6709\u4e24\u4e2a\u4e2d\u95f4\u7ed3\u70b9\uff0c\u5219\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u4e2d\u95f4\u7ed3\u70b9\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1a[1,2,3,4,5] \u8f93\u51fa\uff1a\u6b64\u5217\u8868\u4e2d\u7684\u7ed3\u70b9 3 (\u5e8f\u5217\u5316\u5f62\u5f0f\uff1a[3,4,5]) \u8fd4\u56de\u7684\u7ed3\u70b9\u503c\u4e3a 3 \u3002 (\u6d4b\u8bc4\u7cfb\u7edf\u5bf9\u8be5\u7ed3\u70b9\u5e8f\u5217\u5316\u8868\u8ff0\u662f [3,4,5])\u3002 \u6ce8\u610f\uff0c\u6211\u4eec\u8fd4\u56de\u4e86\u4e00\u4e2a ListNode \u7c7b\u578b\u7684\u5bf9\u8c61 ans\uff0c\u8fd9\u6837\uff1a ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, \u4ee5\u53ca ans.next.next.next = NULL. \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1a[1,2,3,4,5,6] \u8f93\u51fa\uff1a\u6b64\u5217\u8868\u4e2d\u7684\u7ed3\u70b9 4 (\u5e8f\u5217\u5316\u5f62\u5f0f\uff1a[4,5,6]) \u7531\u4e8e\u8be5\u5217\u8868\u6709\u4e24\u4e2a\u4e2d\u95f4\u7ed3\u70b9\uff0c\u503c\u5206\u522b\u4e3a 3 \u548c 4\uff0c\u6211\u4eec\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u7ed3\u70b9\u3002 \u63d0\u793a\uff1a \u7ed9\u5b9a\u94fe\u8868\u7684\u7ed3\u70b9\u6570\u4ecb\u4e8e 1 \u548c 100 \u4e4b\u95f4\u3002 \u4ee3\u7801 struct ListNode* middleNode(struct ListNode* head){ struct ListNode* fast = head,* slow = head; while(fast && fast->next) { slow = slow->next; fast = fast->next->next; } return slow; }","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/876%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/#_1","text":"\u94fe\u8868\u7684\u4e2d\u95f4\u7ed3\u70b9 \u7ed9\u5b9a\u4e00\u4e2a\u5934\u7ed3\u70b9\u4e3a head \u7684\u975e\u7a7a\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u95f4\u7ed3\u70b9\u3002 \u5982\u679c\u6709\u4e24\u4e2a\u4e2d\u95f4\u7ed3\u70b9\uff0c\u5219\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u4e2d\u95f4\u7ed3\u70b9\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1a[1,2,3,4,5] \u8f93\u51fa\uff1a\u6b64\u5217\u8868\u4e2d\u7684\u7ed3\u70b9 3 (\u5e8f\u5217\u5316\u5f62\u5f0f\uff1a[3,4,5]) \u8fd4\u56de\u7684\u7ed3\u70b9\u503c\u4e3a 3 \u3002 (\u6d4b\u8bc4\u7cfb\u7edf\u5bf9\u8be5\u7ed3\u70b9\u5e8f\u5217\u5316\u8868\u8ff0\u662f [3,4,5])\u3002 \u6ce8\u610f\uff0c\u6211\u4eec\u8fd4\u56de\u4e86\u4e00\u4e2a ListNode \u7c7b\u578b\u7684\u5bf9\u8c61 ans\uff0c\u8fd9\u6837\uff1a ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, \u4ee5\u53ca ans.next.next.next = NULL. \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1a[1,2,3,4,5,6] \u8f93\u51fa\uff1a\u6b64\u5217\u8868\u4e2d\u7684\u7ed3\u70b9 4 (\u5e8f\u5217\u5316\u5f62\u5f0f\uff1a[4,5,6]) \u7531\u4e8e\u8be5\u5217\u8868\u6709\u4e24\u4e2a\u4e2d\u95f4\u7ed3\u70b9\uff0c\u503c\u5206\u522b\u4e3a 3 \u548c 4\uff0c\u6211\u4eec\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u7ed3\u70b9\u3002 \u63d0\u793a\uff1a \u7ed9\u5b9a\u94fe\u8868\u7684\u7ed3\u70b9\u6570\u4ecb\u4e8e 1 \u548c 100 \u4e4b\u95f4\u3002","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/876%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/#_2","text":"struct ListNode* middleNode(struct ListNode* head){ struct ListNode* fast = head,* slow = head; while(fast && fast->next) { slow = slow->next; fast = fast->next->next; } return slow; }","title":"\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","text":"code /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(pHead == NULL || pHead->next == NULL){ return pHead; } else{ //\u94fe\u8868\u6709\u8d85\u8fc7\u4e00\u4e2a\u8282\u70b9 struct ListNode *prev = NULL; struct ListNode *cur = pHead; struct ListNode *next = pHead->next; while(next != NULL){ if(cur->val != next->val){//\u76f8\u90bb\u76f8\u7b49 prev = cur; cur = next; next = next->next; } else{ int val = cur->val; while(cur != NULL && cur->val == val){//\u627e\u5230\u76f8\u7b49\u5c31\u91ca\u653e struct ListNode *del = cur; cur = cur->next; if(cur == NULL){ next = NULL; } else{ next = next->next; } free(del); } if(prev == NULL){ pHead = cur; } else{ prev->next = cur; } } } } return pHead; } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/List/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/#code","text":"/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(pHead == NULL || pHead->next == NULL){ return pHead; } else{ //\u94fe\u8868\u6709\u8d85\u8fc7\u4e00\u4e2a\u8282\u70b9 struct ListNode *prev = NULL; struct ListNode *cur = pHead; struct ListNode *next = pHead->next; while(next != NULL){ if(cur->val != next->val){//\u76f8\u90bb\u76f8\u7b49 prev = cur; cur = next; next = next->next; } else{ int val = cur->val; while(cur != NULL && cur->val == val){//\u627e\u5230\u76f8\u7b49\u5c31\u91ca\u653e struct ListNode *del = cur; cur = cur->next; if(cur == NULL){ next = NULL; } else{ next = next->next; } free(del); } if(prev == NULL){ pHead = cur; } else{ prev->next = cur; } } } } return pHead; } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/020%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","text":"code //\u7528\u6808\u5b9e\u73b0 typedef int STDataType; struct Stack{ STDataType *a; int top; // int capacity; //\u65b9\u4fbf\u6269\u5bb9 }; typedef struct Stack Stack; //\u521d\u59cb\u5316 void StackInit(Stack* pst) { //assert(pst); //pst->a = NULL; //pst -> top = 0; //pst->capacity = 0; //way2 pst->a = (STDataType *)malloc(sizeof(STDataType) * 4); pst->top = 0; pst->capacity = 4; } //\u6808\u662f\u5426\u4e3a\u7a7a bool StackEmpty(Stack* pst) { assert(pst); return pst->top == 0; } //\u6808\u9500\u6bc1 void StackDestory(Stack* pst) { assert(pst); free(pst->a); pst->a = NULL; //\u9500\u6bc1\u6570\u636e pst->capacity = pst->top = 0;//\u9500\u6bc1\u6307\u9488 } //\u5165\u6808 void StackPush(Stack*pst, STDataType x) { assert(pst); if (pst->top == pst->capacity){ //\u6ee1\u4e86\uff0c\u9700\u6269\u5bb9 STDataType* tmp = (STDataType*)realloc(pst->a,sizeof(STDataType)*pst->capacity * 2); if (tmp == NULL){ printf(\"realloc fail\\n\"); exit(-1);//\u7ed3\u675f\u6574\u4e2a\u7a0b\u5e8f } pst->a = tmp; pst->capacity *= 2;//\u6269\u5bb9 } pst->a[pst->top] = x;//\u6808\u9876\u63d2\u5165 pst->top++;//\u6808\u9876\u79fb\u52a8 } //\u51fa\u6808 void StackPop(Stack* pst) { assert(pst); assert(!StackEmpty(pst));//\u4fdd\u8bc1\u6808\u4e0d\u7a7a pst->top--; } //\u8fd4\u56de\u6808\u9876\u5143\u7d20 STDataType StackTop(Stack *pst) { assert(pst); assert(!StackEmpty(pst));//\u62b1\u6795\u6808\u4e0d\u7a7a return pst->a[pst->top - 1];//\u6808\u9876top\u6307\u9488\u6307\u5411\u4e0b\u4e00\u4f4d\uff0c\u51cf\u4e00\u5c31\u4e3a\u6808\u9876 } //\u6808\u5927\u5c0f int StackSize(Stack *pst) { assert(pst); return pst->top; } bool isValid(char * s){ Stack st; StackInit(&st);//\u521d\u59cb\u5316\u6808 while(*s) { //\u5de6\u62ec\u53f7\u5165\u6808 if(*s == '[' || *s == '(' || *s == '{') { StackPush(&st,*s);//\u5165\u6808 ++s; } else { //\u5de6\u62ec\u53f7 \u4e0d\u5b58\u5728 if(StackEmpty(&st)) { //\u82e5\u6808\u7a7a\uff0c\u9500\u6bc1\u4e4b StackDestory(&st); return false; } char top = StackTop(&st);//\u6808\u9876\u503c if((top == '[' && *s != ']') || (top == '(' && *s != ')') || (top == '{' && *s != '}')) { //\u4e0d\u5339\u914d StackDestory(&st); return false; } else { //\u5339\u914d StackPop(&st); ++s; } } } bool ret = StackEmpty(&st); StackDestory(&st); return ret; } \u601d\u8def\uff1a \u4f7f\u7528\u6808\u7684\u65b9\u5f0f\u6765\u5b9e\u73b0\u3002","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/020%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/#code","text":"//\u7528\u6808\u5b9e\u73b0 typedef int STDataType; struct Stack{ STDataType *a; int top; // int capacity; //\u65b9\u4fbf\u6269\u5bb9 }; typedef struct Stack Stack; //\u521d\u59cb\u5316 void StackInit(Stack* pst) { //assert(pst); //pst->a = NULL; //pst -> top = 0; //pst->capacity = 0; //way2 pst->a = (STDataType *)malloc(sizeof(STDataType) * 4); pst->top = 0; pst->capacity = 4; } //\u6808\u662f\u5426\u4e3a\u7a7a bool StackEmpty(Stack* pst) { assert(pst); return pst->top == 0; } //\u6808\u9500\u6bc1 void StackDestory(Stack* pst) { assert(pst); free(pst->a); pst->a = NULL; //\u9500\u6bc1\u6570\u636e pst->capacity = pst->top = 0;//\u9500\u6bc1\u6307\u9488 } //\u5165\u6808 void StackPush(Stack*pst, STDataType x) { assert(pst); if (pst->top == pst->capacity){ //\u6ee1\u4e86\uff0c\u9700\u6269\u5bb9 STDataType* tmp = (STDataType*)realloc(pst->a,sizeof(STDataType)*pst->capacity * 2); if (tmp == NULL){ printf(\"realloc fail\\n\"); exit(-1);//\u7ed3\u675f\u6574\u4e2a\u7a0b\u5e8f } pst->a = tmp; pst->capacity *= 2;//\u6269\u5bb9 } pst->a[pst->top] = x;//\u6808\u9876\u63d2\u5165 pst->top++;//\u6808\u9876\u79fb\u52a8 } //\u51fa\u6808 void StackPop(Stack* pst) { assert(pst); assert(!StackEmpty(pst));//\u4fdd\u8bc1\u6808\u4e0d\u7a7a pst->top--; } //\u8fd4\u56de\u6808\u9876\u5143\u7d20 STDataType StackTop(Stack *pst) { assert(pst); assert(!StackEmpty(pst));//\u62b1\u6795\u6808\u4e0d\u7a7a return pst->a[pst->top - 1];//\u6808\u9876top\u6307\u9488\u6307\u5411\u4e0b\u4e00\u4f4d\uff0c\u51cf\u4e00\u5c31\u4e3a\u6808\u9876 } //\u6808\u5927\u5c0f int StackSize(Stack *pst) { assert(pst); return pst->top; } bool isValid(char * s){ Stack st; StackInit(&st);//\u521d\u59cb\u5316\u6808 while(*s) { //\u5de6\u62ec\u53f7\u5165\u6808 if(*s == '[' || *s == '(' || *s == '{') { StackPush(&st,*s);//\u5165\u6808 ++s; } else { //\u5de6\u62ec\u53f7 \u4e0d\u5b58\u5728 if(StackEmpty(&st)) { //\u82e5\u6808\u7a7a\uff0c\u9500\u6bc1\u4e4b StackDestory(&st); return false; } char top = StackTop(&st);//\u6808\u9876\u503c if((top == '[' && *s != ']') || (top == '(' && *s != ')') || (top == '{' && *s != '}')) { //\u4e0d\u5339\u914d StackDestory(&st); return false; } else { //\u5339\u914d StackPop(&st); ++s; } } } bool ret = StackEmpty(&st); StackDestory(&st); return ret; }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/020%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/#_1","text":"\u4f7f\u7528\u6808\u7684\u65b9\u5f0f\u6765\u5b9e\u73b0\u3002","title":"\u601d\u8def\uff1a"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/027%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","text":"\u9898\u76ee\uff1a 26. \u5220\u9664\u6709\u5e8f\u6570\u7ec4\u4e2d\u7684\u91cd\u590d\u9879 \u7ed9\u4f60\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4 nums \uff0c\u8bf7\u4f60 \u539f\u5730 \u5220\u9664\u91cd\u590d\u51fa\u73b0\u7684\u5143\u7d20\uff0c\u4f7f\u6bcf\u4e2a\u5143\u7d20 \u53ea\u51fa\u73b0\u4e00\u6b21 \uff0c\u8fd4\u56de\u5220\u9664\u540e\u6570\u7ec4\u7684\u65b0\u957f\u5ea6\u3002 \u4e0d\u8981\u4f7f\u7528\u989d\u5916\u7684\u6570\u7ec4\u7a7a\u95f4\uff0c\u4f60\u5fc5\u987b\u5728 \u539f\u5730 \u4fee\u6539\u8f93\u5165\u6570\u7ec4 \u5e76\u5728\u4f7f\u7528 O(1) \u989d\u5916\u7a7a\u95f4\u7684\u6761\u4ef6\u4e0b\u5b8c\u6210\u3002 \u8bf4\u660e: \u4e3a\u4ec0\u4e48\u8fd4\u56de\u6570\u503c\u662f\u6574\u6570\uff0c\u4f46\u8f93\u51fa\u7684\u7b54\u6848\u662f\u6570\u7ec4\u5462? \u8bf7\u6ce8\u610f\uff0c\u8f93\u5165\u6570\u7ec4\u662f\u4ee5\u300c\u5f15\u7528\u300d\u65b9\u5f0f\u4f20\u9012\u7684\uff0c\u8fd9\u610f\u5473\u7740\u5728\u51fd\u6570\u91cc\u4fee\u6539\u8f93\u5165\u6570\u7ec4\u5bf9\u4e8e\u8c03\u7528\u8005\u662f\u53ef\u89c1\u7684\u3002 \u4f60\u53ef\u4ee5\u60f3\u8c61\u5185\u90e8\u64cd\u4f5c\u5982\u4e0b: // nums \u662f\u4ee5\u201c\u5f15\u7528\u201d\u65b9\u5f0f\u4f20\u9012\u7684\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e0d\u5bf9\u5b9e\u53c2\u505a\u4efb\u4f55\u62f7\u8d1d int len = removeDuplicates(nums); // \u5728\u51fd\u6570\u91cc\u4fee\u6539\u8f93\u5165\u6570\u7ec4\u5bf9\u4e8e\u8c03\u7528\u8005\u662f\u53ef\u89c1\u7684\u3002 // \u6839\u636e\u4f60\u7684\u51fd\u6570\u8fd4\u56de\u7684\u957f\u5ea6, \u5b83\u4f1a\u6253\u5370\u51fa\u6570\u7ec4\u4e2d \u8be5\u957f\u5ea6\u8303\u56f4\u5185 \u7684\u6240\u6709\u5143\u7d20\u3002 for (int i = 0; i < len; i++) { print(nums[i]); } \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [1,1,2] \u8f93\u51fa\uff1a2, nums = [1,2] \u89e3\u91ca\uff1a\u51fd\u6570\u5e94\u8be5\u8fd4\u56de\u65b0\u7684\u957f\u5ea6 2 \uff0c\u5e76\u4e14\u539f\u6570\u7ec4 nums \u7684\u524d\u4e24\u4e2a\u5143\u7d20\u88ab\u4fee\u6539\u4e3a 1, 2 \u3002\u4e0d\u9700\u8981\u8003\u8651\u6570\u7ec4\u4e2d\u8d85\u51fa\u65b0\u957f\u5ea6\u540e\u9762\u7684\u5143\u7d20\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [0,0,1,1,1,2,2,3,3,4] \u8f93\u51fa\uff1a5, nums = [0,1,2,3,4] \u89e3\u91ca\uff1a\u51fd\u6570\u5e94\u8be5\u8fd4\u56de\u65b0\u7684\u957f\u5ea6 5 \uff0c \u5e76\u4e14\u539f\u6570\u7ec4 nums \u7684\u524d\u4e94\u4e2a\u5143\u7d20\u88ab\u4fee\u6539\u4e3a 0, 1, 2, 3, 4 \u3002\u4e0d\u9700\u8981\u8003\u8651\u6570\u7ec4\u4e2d\u8d85\u51fa\u65b0\u957f\u5ea6\u540e\u9762\u7684\u5143\u7d20\u3002 \u63d0\u793a\uff1a 0 <= nums.length <= 3 * 104 -104 <= nums[i] <= 104 nums \u5df2\u6309\u5347\u5e8f\u6392\u5217 int removeDuplicates(int* nums, int numsSize){ assert(nums); if(numsSize<2) return numsSize; int j = 0; for(int i = 1;i<numsSize; ++i) { if(nums[j] != nums[i]) { nums[++j] =nums[i]; } } return j+1;//j\u662f\u5143\u7d20\u4e0b\u6807\uff0c+1 \u662f\u5143\u7d20\u4e2a\u6570 }","title":"027\u5220\u9664\u6709\u5e8f\u6570\u7ec4\u4e2d\u7684\u91cd\u590d\u9879"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/088%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84/","text":"\u9898\u76ee \u7ed9\u4f60\u4e24\u4e2a\u6709\u5e8f\u6574\u6570\u6570\u7ec4 nums1 \u548c nums2\uff0c\u8bf7\u4f60\u5c06 nums2 \u5408\u5e76\u5230 nums1 \u4e2d\uff0c\u4f7f nums1 \u6210\u4e3a\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4\u3002 \u521d\u59cb\u5316 nums1 \u548c nums2 \u7684\u5143\u7d20\u6570\u91cf\u5206\u522b\u4e3a m \u548c n \u3002\u4f60\u53ef\u4ee5\u5047\u8bbe nums1 \u7684\u7a7a\u95f4\u5927\u5c0f\u7b49\u4e8e m + n\uff0c\u8fd9\u6837\u5b83\u5c31\u6709\u8db3\u591f\u7684\u7a7a\u95f4\u4fdd\u5b58\u6765\u81ea nums2 \u7684\u5143\u7d20\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 \u8f93\u51fa\uff1a[1,2,2,3,5,6] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums1 = [1], m = 1, nums2 = [], n = 0 \u8f93\u51fa\uff1a[1] \u63d0\u793a\uff1a nums1.length == m + n nums2.length == n 0 <= m, n <= 200 1 <= m + n <= 200 -109 <= nums1[i], nums2[i] <= 109 \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/merge-sorted-array \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 code void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){ //end1:nums1\u7684\u672b\u5c3e //end2:nums2\u7684\u672b\u5c3e //end:\u5408\u5e76\u4e4b\u540e\u6574\u4e2a\u6570\u7ec4\u7684\u672b\u5c3e int end1 = m - 1; int end2 = n - 1; int end = m + n - 1; while (end1 >= 0 && end2 >= 0) { //\u9009\u51fa\u5c3e\u6700\u5927\u7684\u5143\u7d20\uff0c\u5b58\u653e\u5230\u6574\u4e2a\u6570\u7ec4\u7684\u672b\u5c3e //\u6bcf\u5b58\u653e\u4e00\u4e2a\u5143\u7d20\uff0c\u5c3e\u5411\u524d\u79fb\u52a8\u4e00\u4e2a\u4f4d\u7f6e if (nums1[end1] > nums2[end2]) { nums1[end--] = nums1[end1--]; } else { nums1[end--] = nums2[end2--]; } } //\u5269\u4f59\u5143\u7d20\u4f9d\u6b21\u5411\u672b\u5c3e\u5b58\u653e while (end1 >= 0) { nums1[end--] = nums1[end1--]; } while (end2 >= 0) { nums1[end--] = nums2[end2--]; } }","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/088%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84/#_1","text":"\u7ed9\u4f60\u4e24\u4e2a\u6709\u5e8f\u6574\u6570\u6570\u7ec4 nums1 \u548c nums2\uff0c\u8bf7\u4f60\u5c06 nums2 \u5408\u5e76\u5230 nums1 \u4e2d\uff0c\u4f7f nums1 \u6210\u4e3a\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4\u3002 \u521d\u59cb\u5316 nums1 \u548c nums2 \u7684\u5143\u7d20\u6570\u91cf\u5206\u522b\u4e3a m \u548c n \u3002\u4f60\u53ef\u4ee5\u5047\u8bbe nums1 \u7684\u7a7a\u95f4\u5927\u5c0f\u7b49\u4e8e m + n\uff0c\u8fd9\u6837\u5b83\u5c31\u6709\u8db3\u591f\u7684\u7a7a\u95f4\u4fdd\u5b58\u6765\u81ea nums2 \u7684\u5143\u7d20\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 \u8f93\u51fa\uff1a[1,2,2,3,5,6] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums1 = [1], m = 1, nums2 = [], n = 0 \u8f93\u51fa\uff1a[1] \u63d0\u793a\uff1a nums1.length == m + n nums2.length == n 0 <= m, n <= 200 1 <= m + n <= 200 -109 <= nums1[i], nums2[i] <= 109 \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/merge-sorted-array \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/088%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84/#code","text":"void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){ //end1:nums1\u7684\u672b\u5c3e //end2:nums2\u7684\u672b\u5c3e //end:\u5408\u5e76\u4e4b\u540e\u6574\u4e2a\u6570\u7ec4\u7684\u672b\u5c3e int end1 = m - 1; int end2 = n - 1; int end = m + n - 1; while (end1 >= 0 && end2 >= 0) { //\u9009\u51fa\u5c3e\u6700\u5927\u7684\u5143\u7d20\uff0c\u5b58\u653e\u5230\u6574\u4e2a\u6570\u7ec4\u7684\u672b\u5c3e //\u6bcf\u5b58\u653e\u4e00\u4e2a\u5143\u7d20\uff0c\u5c3e\u5411\u524d\u79fb\u52a8\u4e00\u4e2a\u4f4d\u7f6e if (nums1[end1] > nums2[end2]) { nums1[end--] = nums1[end1--]; } else { nums1[end--] = nums2[end2--]; } } //\u5269\u4f59\u5143\u7d20\u4f9d\u6b21\u5411\u672b\u5c3e\u5b58\u653e while (end1 >= 0) { nums1[end--] = nums1[end1--]; } while (end2 >= 0) { nums1[end--] = nums2[end2--]; } }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/225%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/","text":"code typedef int QDataType; typedef struct QueueNode { QDataType data; struct QueueNode* next; }QueueNode; typedef struct Queue { struct QueueNode* front; struct QueueNode* back; }Queue; // \u521d\u59cb\u5316\u961f\u5217 void QueueInit(Queue* q) { assert(q); q->front = q->back = NULL; } // \u961f\u5c3e\u5165\u961f\u5217 void QueuePush(Queue* q, QDataType data) { assert(q); QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode)); assert(newNode); newNode->data = data; newNode->next = NULL; if (q->back == NULL) { q->front = q->back = newNode; } else { q->back->next = newNode; q->back = newNode; } } // \u961f\u5934\u51fa\u961f\u5217 void QueuePop(Queue* q) { assert(q); if (q->front->next == NULL) { free(q->front); q->front = q->back = NULL; } else { QueueNode* second = q->front->next; free(q->front); q->front = second; } } // \u83b7\u53d6\u961f\u5217\u5934\u90e8\u5143\u7d20 QDataType QueueFront(Queue* q) { assert(q); return q->front->data; } // \u83b7\u53d6\u961f\u5217\u961f\u5c3e\u5143\u7d20 QDataType QueueBack(Queue* q) { assert(q); return q->back->data; } // \u83b7\u53d6\u961f\u5217\u4e2d\u6709\u6548\u5143\u7d20\u4e2a\u6570 int QueueSize(Queue* q) { int count = 0; QueueNode* cur = q->front; while (cur) { ++count; cur = cur->next; } return count; } // \u68c0\u6d4b\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679c\u4e3a\u7a7a\u8fd4\u56de\u975e\u96f6\u7ed3\u679c\uff0c\u5982\u679c\u975e\u7a7a\u8fd4\u56de0 int QueueEmpty(Queue* q) { return q->front == NULL ? 1 : 0; } // \u9500\u6bc1\u961f\u5217 void QueueDestroy(Queue* q) { QueueNode* cur = q->front; while (cur) { QueueNode* next = cur->next; free(cur); cur = next; } q->back = q->front = NULL; } //\u5b9a\u4e49\u4e24\u4e2a\u961f\u5217 typedef struct { Queue q1; Queue q2; } MyStack; /** Initialize your data structure here. */ MyStack* myStackCreate() { MyStack * st = (MyStack*)malloc(sizeof(MyStack)); QueueInit(&st->q1); QueueInit(&st->q2); return st; } /** Push element x onto stack. */ void myStackPush(MyStack* obj, int x) { if(!QueueEmpty(&obj->q1)) { QueuePush(&obj->q1, x); } else { QueuePush(&obj->q2, x); } } /** Removes the element on top of the stack and returns that element. */ int myStackPop(MyStack* obj) { Queue* pempty = &obj->q1; Queue* pnoempty = &obj->q2; if(!QueueEmpty(&obj->q1))//\u786e\u4fdd\u961f\u5217\u4e2d\u4e00\u4e2a\u7a7a\uff0c\u4e00\u4e2a\u975e\u7a7a { pempty = &obj->q2; pnoempty = &obj->q1; } while(QueueSize(pnoempty) > 1) { QueuePush(pempty, QueueFront(pnoempty)); QueuePop(pnoempty); } int _top = QueueBack(pnoempty); QueuePop(pnoempty); return _top; } /** Get the top element. */ int myStackTop(MyStack* obj) { if(!QueueEmpty(&obj->q1)) { return QueueBack(&obj->q1); } else { return QueueBack(&obj->q2); } } /** Returns whether the stack is empty. */ bool myStackEmpty(MyStack* obj) { return QueueEmpty(&obj->q1) && QueueEmpty(&obj->q2); } void myStackFree(MyStack* obj) { QueueDestroy(&obj->q1); QueueDestroy(&obj->q2); free(obj); obj = NULL; } /** * Your MyStack struct will be instantiated and called as such: * MyStack* obj = myStackCreate(); * myStackPush(obj, x); * int param_2 = myStackPop(obj); * int param_3 = myStackTop(obj); * bool param_4 = myStackEmpty(obj); * myStackFree(obj); */ \u5206\u6790","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/225%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/#code","text":"typedef int QDataType; typedef struct QueueNode { QDataType data; struct QueueNode* next; }QueueNode; typedef struct Queue { struct QueueNode* front; struct QueueNode* back; }Queue; // \u521d\u59cb\u5316\u961f\u5217 void QueueInit(Queue* q) { assert(q); q->front = q->back = NULL; } // \u961f\u5c3e\u5165\u961f\u5217 void QueuePush(Queue* q, QDataType data) { assert(q); QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode)); assert(newNode); newNode->data = data; newNode->next = NULL; if (q->back == NULL) { q->front = q->back = newNode; } else { q->back->next = newNode; q->back = newNode; } } // \u961f\u5934\u51fa\u961f\u5217 void QueuePop(Queue* q) { assert(q); if (q->front->next == NULL) { free(q->front); q->front = q->back = NULL; } else { QueueNode* second = q->front->next; free(q->front); q->front = second; } } // \u83b7\u53d6\u961f\u5217\u5934\u90e8\u5143\u7d20 QDataType QueueFront(Queue* q) { assert(q); return q->front->data; } // \u83b7\u53d6\u961f\u5217\u961f\u5c3e\u5143\u7d20 QDataType QueueBack(Queue* q) { assert(q); return q->back->data; } // \u83b7\u53d6\u961f\u5217\u4e2d\u6709\u6548\u5143\u7d20\u4e2a\u6570 int QueueSize(Queue* q) { int count = 0; QueueNode* cur = q->front; while (cur) { ++count; cur = cur->next; } return count; } // \u68c0\u6d4b\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679c\u4e3a\u7a7a\u8fd4\u56de\u975e\u96f6\u7ed3\u679c\uff0c\u5982\u679c\u975e\u7a7a\u8fd4\u56de0 int QueueEmpty(Queue* q) { return q->front == NULL ? 1 : 0; } // \u9500\u6bc1\u961f\u5217 void QueueDestroy(Queue* q) { QueueNode* cur = q->front; while (cur) { QueueNode* next = cur->next; free(cur); cur = next; } q->back = q->front = NULL; } //\u5b9a\u4e49\u4e24\u4e2a\u961f\u5217 typedef struct { Queue q1; Queue q2; } MyStack; /** Initialize your data structure here. */ MyStack* myStackCreate() { MyStack * st = (MyStack*)malloc(sizeof(MyStack)); QueueInit(&st->q1); QueueInit(&st->q2); return st; } /** Push element x onto stack. */ void myStackPush(MyStack* obj, int x) { if(!QueueEmpty(&obj->q1)) { QueuePush(&obj->q1, x); } else { QueuePush(&obj->q2, x); } } /** Removes the element on top of the stack and returns that element. */ int myStackPop(MyStack* obj) { Queue* pempty = &obj->q1; Queue* pnoempty = &obj->q2; if(!QueueEmpty(&obj->q1))//\u786e\u4fdd\u961f\u5217\u4e2d\u4e00\u4e2a\u7a7a\uff0c\u4e00\u4e2a\u975e\u7a7a { pempty = &obj->q2; pnoempty = &obj->q1; } while(QueueSize(pnoempty) > 1) { QueuePush(pempty, QueueFront(pnoempty)); QueuePop(pnoempty); } int _top = QueueBack(pnoempty); QueuePop(pnoempty); return _top; } /** Get the top element. */ int myStackTop(MyStack* obj) { if(!QueueEmpty(&obj->q1)) { return QueueBack(&obj->q1); } else { return QueueBack(&obj->q2); } } /** Returns whether the stack is empty. */ bool myStackEmpty(MyStack* obj) { return QueueEmpty(&obj->q1) && QueueEmpty(&obj->q2); } void myStackFree(MyStack* obj) { QueueDestroy(&obj->q1); QueueDestroy(&obj->q2); free(obj); obj = NULL; } /** * Your MyStack struct will be instantiated and called as such: * MyStack* obj = myStackCreate(); * myStackPush(obj, x); * int param_2 = myStackPop(obj); * int param_3 = myStackTop(obj); * bool param_4 = myStackEmpty(obj); * myStackFree(obj); */","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/225%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/#_1","text":"","title":"\u5206\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","text":"code typedef int STDataType; struct Stack{ STDataType *a; int top; // int capacity; //\u65b9\u4fbf\u6269\u5bb9 }; typedef struct Stack Stack; void StackInit(Stack* pst); void StackDestory(Stack* pst); //\u6808\u9876\u51fa\u5165\u6570\u636e void StackPush(Stack* pst, STDataType x); void StackPop(Stack* pst); STDataType StackTop(Stack *pst); //\u7a7a\u8fd4\u56de1 \u975e\u7a7a\u8fd4\u56de0 //int StackEmpty(Stackt* pst); bool StackEmpty(Stack* pst); int StackSize(Stack *pst); //\u521d\u59cb\u5316 void StackInit(Stack* pst) { //assert(pst); //pst->a = NULL; //pst -> top = 0; //pst->capacity = 0; //way2 pst->a = (STDataType *)malloc(sizeof(STDataType) * 4); pst->top = 0; pst->capacity = 4; } //\u6808\u9500\u6bc1 void StackDestory(Stack* pst) { assert(pst); free(pst->a); pst->a = NULL; //\u9500\u6bc1\u6570\u636e pst->capacity = pst->top = 0;//\u9500\u6bc1\u6307\u9488 } //\u5165\u6808 void StackPush(Stack*pst, STDataType x) { assert(pst); if (pst->top == pst->capacity){ //\u6ee1\u4e86\uff0c\u9700\u6269\u5bb9 STDataType* tmp = (STDataType*)realloc(pst->a,sizeof(STDataType)*pst->capacity * 2); if (tmp == NULL){ printf(\"realloc fail\\n\"); exit(-1);//\u7ed3\u675f\u6574\u4e2a\u7a0b\u5e8f } pst->a = tmp; pst->capacity *= 2;//\u6269\u5bb9 } pst->a[pst->top] = x;//\u6808\u9876\u63d2\u5165 pst->top++;//\u6808\u9876\u79fb\u52a8 } //\u51fa\u6808 void StackPop(Stack* pst) { assert(pst); assert(!StackEmpty(pst));//\u4fdd\u8bc1\u6808\u4e0d\u7a7a pst->top--; } //\u8fd4\u56de\u6808\u9876\u5143\u7d20 STDataType StackTop(Stack *pst) { assert(pst); assert(!StackEmpty(pst));//\u62b1\u6795\u6808\u4e0d\u7a7a return pst->a[pst->top - 1];//\u6808\u9876top\u6307\u9488\u6307\u5411\u4e0b\u4e00\u4f4d\uff0c\u51cf\u4e00\u5c31\u4e3a\u6808\u9876 } //\u6808\u662f\u5426\u4e3a\u7a7a bool StackEmpty(Stack* pst) { assert(pst); return pst->top == 0; } //\u6808\u5927\u5c0f int StackSize(Stack *pst) { assert(pst); return pst->top; } //\u5b9a\u4e49\u4e24\u4e2a\u6808 typedef struct { Stack pushST; Stack popST; } MyQueue; /** Initialize your data structure here. */ MyQueue* myQueueCreate() { MyQueue* q = (MyQueue*)malloc(sizeof(MyQueue)); StackInit(&q->pushST); StackInit(&q->popST); return q; } /** Push element x to the back of queue. */ void myQueuePush(MyQueue* obj, int x) { StackPush(&obj->pushST,x);//\u5165\u6808 } /** Removes the element from in front of queue and returns that element. */ int myQueuePop(MyQueue* obj) { int top = myQueuePeek(obj); StackPop(&obj->popST); return top; } /** Get the front element. */ int myQueuePeek(MyQueue* obj) { if(StackEmpty(&obj->popST)) { while(!StackEmpty(&obj->pushST)) { //pushST \u4e0d\u7a7a\uff0c\u5165\u6808 StackPush(&obj->popST,StackTop(&obj->pushST)); StackPop(&obj->pushST); } } return StackTop(&obj->popST); } /** Returns whether the queue is empty. */ bool myQueueEmpty(MyQueue* obj) { return StackEmpty(&obj->pushST) && StackEmpty(&obj->popST); } void myQueueFree(MyQueue* obj) { StackDestory(&obj->pushST); StackDestory(&obj->popST); free(obj); obj = NULL; } /** * Your MyQueue struct will be instantiated and called as such: * MyQueue* obj = myQueueCreate(); * myQueuePush(obj, x); * int param_2 = myQueuePop(obj); * int param_3 = myQueuePeek(obj); * bool param_4 = myQueueEmpty(obj); * myQueueFree(obj); */","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/#code","text":"typedef int STDataType; struct Stack{ STDataType *a; int top; // int capacity; //\u65b9\u4fbf\u6269\u5bb9 }; typedef struct Stack Stack; void StackInit(Stack* pst); void StackDestory(Stack* pst); //\u6808\u9876\u51fa\u5165\u6570\u636e void StackPush(Stack* pst, STDataType x); void StackPop(Stack* pst); STDataType StackTop(Stack *pst); //\u7a7a\u8fd4\u56de1 \u975e\u7a7a\u8fd4\u56de0 //int StackEmpty(Stackt* pst); bool StackEmpty(Stack* pst); int StackSize(Stack *pst); //\u521d\u59cb\u5316 void StackInit(Stack* pst) { //assert(pst); //pst->a = NULL; //pst -> top = 0; //pst->capacity = 0; //way2 pst->a = (STDataType *)malloc(sizeof(STDataType) * 4); pst->top = 0; pst->capacity = 4; } //\u6808\u9500\u6bc1 void StackDestory(Stack* pst) { assert(pst); free(pst->a); pst->a = NULL; //\u9500\u6bc1\u6570\u636e pst->capacity = pst->top = 0;//\u9500\u6bc1\u6307\u9488 } //\u5165\u6808 void StackPush(Stack*pst, STDataType x) { assert(pst); if (pst->top == pst->capacity){ //\u6ee1\u4e86\uff0c\u9700\u6269\u5bb9 STDataType* tmp = (STDataType*)realloc(pst->a,sizeof(STDataType)*pst->capacity * 2); if (tmp == NULL){ printf(\"realloc fail\\n\"); exit(-1);//\u7ed3\u675f\u6574\u4e2a\u7a0b\u5e8f } pst->a = tmp; pst->capacity *= 2;//\u6269\u5bb9 } pst->a[pst->top] = x;//\u6808\u9876\u63d2\u5165 pst->top++;//\u6808\u9876\u79fb\u52a8 } //\u51fa\u6808 void StackPop(Stack* pst) { assert(pst); assert(!StackEmpty(pst));//\u4fdd\u8bc1\u6808\u4e0d\u7a7a pst->top--; } //\u8fd4\u56de\u6808\u9876\u5143\u7d20 STDataType StackTop(Stack *pst) { assert(pst); assert(!StackEmpty(pst));//\u62b1\u6795\u6808\u4e0d\u7a7a return pst->a[pst->top - 1];//\u6808\u9876top\u6307\u9488\u6307\u5411\u4e0b\u4e00\u4f4d\uff0c\u51cf\u4e00\u5c31\u4e3a\u6808\u9876 } //\u6808\u662f\u5426\u4e3a\u7a7a bool StackEmpty(Stack* pst) { assert(pst); return pst->top == 0; } //\u6808\u5927\u5c0f int StackSize(Stack *pst) { assert(pst); return pst->top; } //\u5b9a\u4e49\u4e24\u4e2a\u6808 typedef struct { Stack pushST; Stack popST; } MyQueue; /** Initialize your data structure here. */ MyQueue* myQueueCreate() { MyQueue* q = (MyQueue*)malloc(sizeof(MyQueue)); StackInit(&q->pushST); StackInit(&q->popST); return q; } /** Push element x to the back of queue. */ void myQueuePush(MyQueue* obj, int x) { StackPush(&obj->pushST,x);//\u5165\u6808 } /** Removes the element from in front of queue and returns that element. */ int myQueuePop(MyQueue* obj) { int top = myQueuePeek(obj); StackPop(&obj->popST); return top; } /** Get the front element. */ int myQueuePeek(MyQueue* obj) { if(StackEmpty(&obj->popST)) { while(!StackEmpty(&obj->pushST)) { //pushST \u4e0d\u7a7a\uff0c\u5165\u6808 StackPush(&obj->popST,StackTop(&obj->pushST)); StackPop(&obj->pushST); } } return StackTop(&obj->popST); } /** Returns whether the queue is empty. */ bool myQueueEmpty(MyQueue* obj) { return StackEmpty(&obj->pushST) && StackEmpty(&obj->popST); } void myQueueFree(MyQueue* obj) { StackDestory(&obj->pushST); StackDestory(&obj->popST); free(obj); obj = NULL; } /** * Your MyQueue struct will be instantiated and called as such: * MyQueue* obj = myQueueCreate(); * myQueuePush(obj, x); * int param_2 = myQueuePop(obj); * int param_3 = myQueuePeek(obj); * bool param_4 = myQueueEmpty(obj); * myQueueFree(obj); */","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/622%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","text":"code typedef struct { int* a; int k;//\u961f\u5217\u5b58\u653e\u6570\u636e\u4e2a\u6570 int front; int tail; } MyCircularQueue; MyCircularQueue* myCircularQueueCreate(int k) { MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue)); obj->a = (int*)malloc(sizeof(int)*(k+1)); obj->front = 0; obj->tail = 0; obj->k = k; return obj; } bool myCircularQueueIsEmpty(MyCircularQueue* obj) { return obj->front == obj->tail; } //\u5206\u6790 bool myCircularQueueIsFull(MyCircularQueue* obj) { int tailNext = obj->tail+1; if(tailNext == obj->k+1){ tailNext = 0; } return tailNext == obj->front; } bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) { if(myCircularQueueIsFull(obj)){ return false; } else{ //\u672a\u6ee1\uff0c\u53ef\u4ee5\u5165 obj->a[obj->tail] = value; ++obj->tail; if(obj->tail == obj->k+1){ obj->tail = 0; } return true; } } bool myCircularQueueDeQueue(MyCircularQueue* obj) { if(myCircularQueueIsEmpty(obj)){ return false; } else{ //\u975e\u7a7a\uff0c\u53ef\u5220\u9664 ++obj->front; if(obj->front == obj->k+1){ obj->front = 0; } return true; } } int myCircularQueueFront(MyCircularQueue* obj) { if(myCircularQueueIsEmpty(obj)){ return -1; } else{ return obj->a[obj->front]; } } int myCircularQueueRear(MyCircularQueue* obj) { if(myCircularQueueIsEmpty(obj)){ return -1; } else{ //\u975e\u7a7a int tailPrev = obj->tail-1; if(tailPrev == -1) tailPrev = obj->k; return obj->a[tailPrev]; } } void myCircularQueueFree(MyCircularQueue* obj) { free(obj->a); free(obj); } /** * Your MyCircularQueue struct will be instantiated and called as such: * MyCircularQueue* obj = myCircularQueueCreate(k); * bool param_1 = myCircularQueueEnQueue(obj, value); * bool param_2 = myCircularQueueDeQueue(obj); * int param_3 = myCircularQueueFront(obj); * int param_4 = myCircularQueueRear(obj); * bool param_5 = myCircularQueueIsEmpty(obj); * bool param_6 = myCircularQueueIsFull(obj); * myCircularQueueFree(obj); */","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/622%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/#code","text":"typedef struct { int* a; int k;//\u961f\u5217\u5b58\u653e\u6570\u636e\u4e2a\u6570 int front; int tail; } MyCircularQueue; MyCircularQueue* myCircularQueueCreate(int k) { MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue)); obj->a = (int*)malloc(sizeof(int)*(k+1)); obj->front = 0; obj->tail = 0; obj->k = k; return obj; } bool myCircularQueueIsEmpty(MyCircularQueue* obj) { return obj->front == obj->tail; } //\u5206\u6790 bool myCircularQueueIsFull(MyCircularQueue* obj) { int tailNext = obj->tail+1; if(tailNext == obj->k+1){ tailNext = 0; } return tailNext == obj->front; } bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) { if(myCircularQueueIsFull(obj)){ return false; } else{ //\u672a\u6ee1\uff0c\u53ef\u4ee5\u5165 obj->a[obj->tail] = value; ++obj->tail; if(obj->tail == obj->k+1){ obj->tail = 0; } return true; } } bool myCircularQueueDeQueue(MyCircularQueue* obj) { if(myCircularQueueIsEmpty(obj)){ return false; } else{ //\u975e\u7a7a\uff0c\u53ef\u5220\u9664 ++obj->front; if(obj->front == obj->k+1){ obj->front = 0; } return true; } } int myCircularQueueFront(MyCircularQueue* obj) { if(myCircularQueueIsEmpty(obj)){ return -1; } else{ return obj->a[obj->front]; } } int myCircularQueueRear(MyCircularQueue* obj) { if(myCircularQueueIsEmpty(obj)){ return -1; } else{ //\u975e\u7a7a int tailPrev = obj->tail-1; if(tailPrev == -1) tailPrev = obj->k; return obj->a[tailPrev]; } } void myCircularQueueFree(MyCircularQueue* obj) { free(obj->a); free(obj); } /** * Your MyCircularQueue struct will be instantiated and called as such: * MyCircularQueue* obj = myCircularQueueCreate(k); * bool param_1 = myCircularQueueEnQueue(obj, value); * bool param_2 = myCircularQueueDeQueue(obj); * int param_3 = myCircularQueueFront(obj); * int param_4 = myCircularQueueRear(obj); * bool param_5 = myCircularQueueIsEmpty(obj); * bool param_6 = myCircularQueueIsFull(obj); * myCircularQueueFree(obj); */","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/66%E5%8A%A0%E4%B8%80/","text":"/** * Note: The returned array must be malloced, assume caller calls free(). */ int* plusOne(int* digits, int digitsSize, int* returnSize){ for(int i = digitsSize-1;i >= 0; i--){//\u4ece\u540e\u5230\u524d\u4f9d\u6b21\u904d\u5386 if(digits[i] != 9){//+1\uff0c\u4e0d\u4ece\u5728\u8fdb\u4f4d digits[i]++; *returnSize = digitsSize; return digits; } //+1\uff0c\u52a01\u5b58\u5728\u8fdb\u4f4d\uff0ci\u7684\u539f\u4f4d\u4e3a9+1 = 0\uff0c\u8fdb\u4f4d\u540e\u9762\u8003\u8651 digits[i] = 0;//digits[i]=9 } int* temp = (int*)malloc(sizeof(int)*(digitsSize+1)); memset(temp,0,(digitsSize+1)*sizeof(int)); temp[0] = 1; *returnSize = digitsSize+1; return temp; }","title":"66\u52a0\u4e00"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Queue/989%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/","text":"989 \u6d4b\u8bd5 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* addToArrayForm(int* num, int numSize, int k, int* returnSize){ int ksize = 0; int kNum = k; // *returnSize = 0; //\u5224\u65adnum\u6570\u5b57\u6709\u591a\u5c11\u4f4d\uff0c\u5b58\u5230ksize\u4e2d while(k){//34 ++ksize;//2 k/=10; } printf(\"ksize : %d\\n\", ksize); //\u5224\u65ad\u6570\u5b57\u4f4d\u6570\u548c\u6570\u7ec4\u4f4d\u6570\u90a3\u4e2a\u5927\uff0c\u8fd4\u56de\u503c+1\uff0c\u9632\u6b62\u8d8a\u754c int len = ksize > numSize ? ksize+1 : numSize+1; printf(\"len : %d\\n\",len); int * retArr = (int *)malloc(sizeof(int)*len); int Ai = numSize -1; //\u6570\u7ec4 printf(\"numSize: %d,Ai: %d\",numSize,Ai); int Ki = 0; int next = 0;//\u8fdb\u4f4d int reti = 0;//\u5148\u653e\u7684\u6570\u7ec4 while(Ai>=0 || Ki < ksize){//\u6570\u7ec4\u4f4d\u6570\u67091\u4f4d\u6216\u8005\u66f4\u591a\uff0c\u6216\u8005\uff0c\u6570\u5b57\u4f4d\u6570\u5c0f\u4e8e\u4e0a\u9762\u8ba1\u7b97 int aVal = 0; if(Ai >= 0) aVal = num[Ai--];//\u5b58\u6570\u7ec4\u4e2d\u503c int kVal = kNum%10;//\u5b58\u6570\u5b57\u503c kNum /= 10; Ki++;//\u6570\u5b57\u4f4d\u6570 int ret = aVal + kVal + next;//\u7b2c\u4e00\u6b21\u8fdb\u4f4d\u4e3a0 if(ret >= 10){//\u6709\u8fdb\u4f4d next = 1; ret -= 10; } else{//\u65e0\u8fdb\u4f4d next = 0; } //\u5012\u7740\u653e\uff0c\u7136\u540e\u9006\u7f6e retArr[reti++] = ret;//\u4f20\u9012\u8fdb\u4f4d\u6807\u5fd7 } if(next == 1)//\u8fd8\u6709\u8fdb\u4f4d retArr[reti++] = 1; //\u9006\u7f6e int left = 0; int right = reti - 1; while (left < right){ int temp = retArr[left]; retArr[left] = retArr[right]; retArr[right] = temp; left++; right--; } *returnSize = reti;//\u6570\u636e\u4e2a\u6570 return retArr; } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* addToArrayForm(int* num, int numSize, int k, int* returnSize){ int ksize = 0; int kNum = k; //\u5224\u65adnum\u6570\u5b57\u6709\u591a\u5c11\u4f4d\uff0c\u5b58\u5230ksize\u4e2d while(kNum){//34 ++ksize;//2 kNum/=10; } //\u5224\u65ad\u6570\u5b57\u4f4d\u6570\u548c\u6570\u7ec4\u4f4d\u6570\u90a3\u4e2a\u5927\uff0c\u8fd4\u56de\u503c+1\uff0c\u9632\u6b62\u8d8a\u754c int len = ksize > numSize ? ksize+1 : numSize+1; int * retArr = (int *)malloc(sizeof(int)*len); *returnSize = 0; for(int Ai =numSize-1; Ai >= 0;--Ai) { int sum = num[Ai] + k % 10;//\u4ece\u540e\u5f80\u524d\u52a0\uff0c\u4ece\u524d\u5f80\u540e\u653e k /= 10; if(sum>=10) { k++;//19/10 = 1 \u8fdb\u4f4d +1 =2 \uff0c\u5de7\u5999\u5904\u7406\u8fdb\u4f4d sum -= 10;//\u51cf10 \u5c31\u662f\u8fdb\u4f4d\u540e\u7684\u503c } retArr[(*returnSize)++] = sum;//\u4ece\u524d\u5f80\u540e\u653e } for(;k>0;k/=10) { retArr[(*returnSize)++] = k %10; } //\u9006\u7f6e int left = 0; int right = (*returnSize)- 1; while (left < right){ int temp = retArr[left]; retArr[left] = retArr[right]; retArr[right] = temp; left++; right--; } return retArr; }","title":"989\u6570\u7ec4\u5f62\u5f0f\u7684\u6574\u6570\u52a0\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/string/043%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","text":"code class Solution { public: string multiply(string num1, string num2) { //1.\u5224\u65ad\u5355\u72ec\u6709\u201c0\u201d \u548c \"1\"\u7684\u60c5\u51b5 if(num1==\"0\" || num2==\"0\") return \"0\"; if(num1==\"1\") return num2; if(num2==\"1\") return num1; //2. \u4fdd\u8bc1\u6548\u7387\uff0c\u8ba9\u5927\u6570\u4e58\u5c0f\u6570 if(num1.length() < num2.length()) swap(num1,num2); // 3. \u6d4b\u957f\u5ea6\uff0c\u5f00\u5b57\u7b26\u4e32 int m = num1.length(), n = num2.length(); //\u63d0\u524d\u5f00\u4e00\u4e2a\u8db3\u591f\u5927\u7684string\uff0cm\u4f4d\u6570\u548cn\u4f4d\u6570\u7684\u4e58\u6cd5\u7ed3\u679c\u4e0d\u4f1a\u8d85\u8fc7m+n\u4f4d\u6570 string res(m+n,'0'); //4. \u8ba1\u7b97\u76f8\u4e58 for(int i = n-1; i>=0; --i){ //if(num2[i]=='0') continue; int c_in = 0; //\u8fdb\u4f4d for(int j = m-1; j>=0; --j){ //\u4e58\u6cd5\u52a0\u6cd5\u8fdb\u4f4d\u4e00\u53e3\u6c14\u7b97\u5b8c int new_num = (num1[j]-'0')*(num2[i]-'0') + (res[i+j+1]-'0') + c_in; c_in = new_num / 10; //\u8fdb\u4f4d new_num = new_num % 10; //\u6c42\u51fa res[i+j+1] = char(new_num + '0'); //\u8f6c\u6210\u5b57\u7b26\u7c7b\u578b } if(c_in > 0) res[i] = char(c_in + '0');//\u6709\u8fdb\u4f4d\uff0c\u52a0\u8fdb\u4f4d } int i = 0; while(res[i] == '0') i++; return res.substr(i,m+n-i); //\u53bb\u6389\u524d\u9762\u591a\u4f59\u76840 } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/string/043%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/#code","text":"class Solution { public: string multiply(string num1, string num2) { //1.\u5224\u65ad\u5355\u72ec\u6709\u201c0\u201d \u548c \"1\"\u7684\u60c5\u51b5 if(num1==\"0\" || num2==\"0\") return \"0\"; if(num1==\"1\") return num2; if(num2==\"1\") return num1; //2. \u4fdd\u8bc1\u6548\u7387\uff0c\u8ba9\u5927\u6570\u4e58\u5c0f\u6570 if(num1.length() < num2.length()) swap(num1,num2); // 3. \u6d4b\u957f\u5ea6\uff0c\u5f00\u5b57\u7b26\u4e32 int m = num1.length(), n = num2.length(); //\u63d0\u524d\u5f00\u4e00\u4e2a\u8db3\u591f\u5927\u7684string\uff0cm\u4f4d\u6570\u548cn\u4f4d\u6570\u7684\u4e58\u6cd5\u7ed3\u679c\u4e0d\u4f1a\u8d85\u8fc7m+n\u4f4d\u6570 string res(m+n,'0'); //4. \u8ba1\u7b97\u76f8\u4e58 for(int i = n-1; i>=0; --i){ //if(num2[i]=='0') continue; int c_in = 0; //\u8fdb\u4f4d for(int j = m-1; j>=0; --j){ //\u4e58\u6cd5\u52a0\u6cd5\u8fdb\u4f4d\u4e00\u53e3\u6c14\u7b97\u5b8c int new_num = (num1[j]-'0')*(num2[i]-'0') + (res[i+j+1]-'0') + c_in; c_in = new_num / 10; //\u8fdb\u4f4d new_num = new_num % 10; //\u6c42\u51fa res[i+j+1] = char(new_num + '0'); //\u8f6c\u6210\u5b57\u7b26\u7c7b\u578b } if(c_in > 0) res[i] = char(c_in + '0');//\u6709\u8fdb\u4f4d\uff0c\u52a0\u8fdb\u4f4d } int i = 0; while(res[i] == '0') i++; return res.substr(i,m+n-i); //\u53bb\u6389\u524d\u9762\u591a\u4f59\u76840 } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/","text":"\u5251\u6307offer \u4ecb\u7ecd \u7ec3\u4e60\u53ca\u56fe\u89e3 \u8f6f\u4ef6\u67b6\u6784 \u8f6f\u4ef6\u67b6\u6784\u8bf4\u660e \u5b89\u88c5\u6559\u7a0b xxxx xxxx xxxx \u4f7f\u7528\u8bf4\u660e xxxx xxxx xxxx \u53c2\u4e0e\u8d21\u732e Fork \u672c\u4ed3\u5e93 \u65b0\u5efa Feat_xxx \u5206\u652f \u63d0\u4ea4\u4ee3\u7801 \u65b0\u5efa Pull Request \u7279\u6280 \u4f7f\u7528 Readme_XXX.md \u6765\u652f\u6301\u4e0d\u540c\u7684\u8bed\u8a00\uff0c\u4f8b\u5982 Readme_en.md, Readme_zh.md Gitee \u5b98\u65b9\u535a\u5ba2 blog.gitee.com \u4f60\u53ef\u4ee5 https://gitee.com/explore \u8fd9\u4e2a\u5730\u5740\u6765\u4e86\u89e3 Gitee \u4e0a\u7684\u4f18\u79c0\u5f00\u6e90\u9879\u76ee GVP \u5168\u79f0\u662f Gitee \u6700\u6709\u4ef7\u503c\u5f00\u6e90\u9879\u76ee\uff0c\u662f\u7efc\u5408\u8bc4\u5b9a\u51fa\u7684\u4f18\u79c0\u5f00\u6e90\u9879\u76ee Gitee \u5b98\u65b9\u63d0\u4f9b\u7684\u4f7f\u7528\u624b\u518c https://gitee.com/help Gitee \u5c01\u9762\u4eba\u7269\u662f\u4e00\u6863\u7528\u6765\u5c55\u793a Gitee \u4f1a\u5458\u98ce\u91c7\u7684\u680f\u76ee https://gitee.com/gitee-stars/","title":"\u5251\u6307offer"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#offer","text":"","title":"\u5251\u6307offer"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#_1","text":"\u7ec3\u4e60\u53ca\u56fe\u89e3","title":"\u4ecb\u7ecd"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#_2","text":"\u8f6f\u4ef6\u67b6\u6784\u8bf4\u660e","title":"\u8f6f\u4ef6\u67b6\u6784"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#_3","text":"xxxx xxxx xxxx","title":"\u5b89\u88c5\u6559\u7a0b"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#_4","text":"xxxx xxxx xxxx","title":"\u4f7f\u7528\u8bf4\u660e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#_5","text":"Fork \u672c\u4ed3\u5e93 \u65b0\u5efa Feat_xxx \u5206\u652f \u63d0\u4ea4\u4ee3\u7801 \u65b0\u5efa Pull Request","title":"\u53c2\u4e0e\u8d21\u732e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/#_6","text":"\u4f7f\u7528 Readme_XXX.md \u6765\u652f\u6301\u4e0d\u540c\u7684\u8bed\u8a00\uff0c\u4f8b\u5982 Readme_en.md, Readme_zh.md Gitee \u5b98\u65b9\u535a\u5ba2 blog.gitee.com \u4f60\u53ef\u4ee5 https://gitee.com/explore \u8fd9\u4e2a\u5730\u5740\u6765\u4e86\u89e3 Gitee \u4e0a\u7684\u4f18\u79c0\u5f00\u6e90\u9879\u76ee GVP \u5168\u79f0\u662f Gitee \u6700\u6709\u4ef7\u503c\u5f00\u6e90\u9879\u76ee\uff0c\u662f\u7efc\u5408\u8bc4\u5b9a\u51fa\u7684\u4f18\u79c0\u5f00\u6e90\u9879\u76ee Gitee \u5b98\u65b9\u63d0\u4f9b\u7684\u4f7f\u7528\u624b\u518c https://gitee.com/help Gitee \u5c01\u9762\u4eba\u7269\u662f\u4e00\u6863\u7528\u6765\u5c55\u793a Gitee \u4f1a\u5458\u98ce\u91c7\u7684\u680f\u76ee https://gitee.com/gitee-stars/","title":"\u7279\u6280"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/","text":"int findRepeatNumber(int* nums, int numsSize){ int arr[numsSize]; memset(arr,0,sizeof(arr)); for(int i = 0;i<numsSize;i++){ if(arr[nums[i]]++) //\u7b2c\u4e8c\u6b21\u9047\u5230\u540c\u6837\u6570\u5b57\uff0cif\u8bed\u53e5\u4e3a\u771f return nums[i]; } return -1; }","title":"03\u6570\u7ec4\u4e2d\u91cd\u590d\u51fa\u73b0\u7684\u6570\u5b57"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/#_1","text":"int findRepeatNumber(int* nums, int numsSize){ int arr[numsSize]; memset(arr,0,sizeof(arr)); for(int i = 0;i<numsSize;i++){ if(arr[nums[i]]++) //\u7b2c\u4e8c\u6b21\u9047\u5230\u540c\u6837\u6570\u5b57\uff0cif\u8bed\u53e5\u4e3a\u771f return nums[i]; } return -1; }","title":""},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/067%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/","text":"code class Solution { public: int strToInt(string str) { //1. \u5b57\u7b26\u4e32\u4e3a\u7a7a if (str.empty()) return 0; // 1.1 \u8003\u8651\u524d\u9762\u7684\u7a7a\u683c \u5982\u201c -23 min\u201d int i = 0; for ( i = 0; i < str.size() && str[i] == ' '; ++i) { //\u7a7a\u64cd\u4f5c } str = str.substr(i, str.size() ); // 2. \u8003\u8651\u6b63\u8d1f\u53f7 int sign = 1; if (str[0] == '-'){ sign = -1; } string res = \"\"; if (str[0] == '+' || str[0] == '-') { res = str.substr(1, str.size() - 1); } else{ res = str; } //3. \u8003\u8651\u6570\u5b57\u8d8a\u754c \u51fa\u9519 \u95ee\u9898\u89e3\u51b3 \u7a7a\u683c\u95ee\u9898 for (int i = 0; i<res.size(); i++){ if (res[i]>'9' || res[i] < '0') //res[i] = 0;// return 0; res = res.substr(0, i); } // long long result = 0; // long long bitcount = 1; // for (int i = res.size() - 1; i >= 0 ; i--){ // // result = result + (res[i] - '0')*bitcount; // // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 // result = result*10 + (res[i] - '0'); // //\u8003\u8651\u5927\u6570 // if(sign == 1 && result > INT_MAX){ // return INT_MAX; // } // else if(sign == -1 && -result < INT_MIN){ // return INT_MIN; // } // } // // \u6b63\u5e8f\u5199\u6cd5 long long result = 0; int bitcount = 1; for (int i = 0; i <= res.size()-1 && isdigit(res[i]); ++i){ // result = result*10 + (res[i] - '0')*bitcount; // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 result = result*10 + (res[i] - '0')*bitcount; //\u8003\u8651\u5927\u6570 if(sign == 1 && result > INT_MAX){ return INT_MAX; } else if(sign == -1 && -result < INT_MIN){ return INT_MIN; } } return sign*result; } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/067%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/#code","text":"class Solution { public: int strToInt(string str) { //1. \u5b57\u7b26\u4e32\u4e3a\u7a7a if (str.empty()) return 0; // 1.1 \u8003\u8651\u524d\u9762\u7684\u7a7a\u683c \u5982\u201c -23 min\u201d int i = 0; for ( i = 0; i < str.size() && str[i] == ' '; ++i) { //\u7a7a\u64cd\u4f5c } str = str.substr(i, str.size() ); // 2. \u8003\u8651\u6b63\u8d1f\u53f7 int sign = 1; if (str[0] == '-'){ sign = -1; } string res = \"\"; if (str[0] == '+' || str[0] == '-') { res = str.substr(1, str.size() - 1); } else{ res = str; } //3. \u8003\u8651\u6570\u5b57\u8d8a\u754c \u51fa\u9519 \u95ee\u9898\u89e3\u51b3 \u7a7a\u683c\u95ee\u9898 for (int i = 0; i<res.size(); i++){ if (res[i]>'9' || res[i] < '0') //res[i] = 0;// return 0; res = res.substr(0, i); } // long long result = 0; // long long bitcount = 1; // for (int i = res.size() - 1; i >= 0 ; i--){ // // result = result + (res[i] - '0')*bitcount; // // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 // result = result*10 + (res[i] - '0'); // //\u8003\u8651\u5927\u6570 // if(sign == 1 && result > INT_MAX){ // return INT_MAX; // } // else if(sign == -1 && -result < INT_MIN){ // return INT_MIN; // } // } // // \u6b63\u5e8f\u5199\u6cd5 long long result = 0; int bitcount = 1; for (int i = 0; i <= res.size()-1 && isdigit(res[i]); ++i){ // result = result*10 + (res[i] - '0')*bitcount; // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 result = result*10 + (res[i] - '0')*bitcount; //\u8003\u8651\u5927\u6570 if(sign == 1 && result > INT_MAX){ return INT_MAX; } else if(sign == -1 && -result < INT_MIN){ return INT_MIN; } } return sign*result; } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* reversePrint(struct ListNode* head, int* returnSize){ int total = 0; struct ListNode* p = head; int *res = malloc(10000 * sizeof(int)); memset(res, 0, 10000 * sizeof(int)); while (p) { res[total++] = p->val;//\u987a\u5e8f\u5b58\u653e p = p->next; } //\u9006\u7f6e for (int i = 0; i < total / 2; i++) { int temp = res[i]; res[i] = res[total - i - 1]; res[total - i - 1] = temp; } *returnSize = total; return res; }","title":"06\u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","text":"code struct ListNode* getKthFromEnd(struct ListNode* head, int k){ struct ListNode * cur = head; int num = 0; while(cur != NULL)//\u7edf\u8ba1\u94fe\u8868\u7684\u957f\u5ea6 { num++; cur = cur->next; } cur = head; while(num != k) { cur = cur->next; num--; } return cur; } analyse","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/#code","text":"struct ListNode* getKthFromEnd(struct ListNode* head, int k){ struct ListNode * cur = head; int num = 0; while(cur != NULL)//\u7edf\u8ba1\u94fe\u8868\u7684\u957f\u5ea6 { num++; cur = cur->next; } cur = head; while(num != k) { cur = cur->next; num--; } return cur; }","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/#analyse","text":"","title":"analyse"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/68-II%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ typedef struct TreeNode TreeNode; //\u6ce8\u610f\u5173\u4e8e\u6b64\u7c7b\u578b\u7684\u8fd4\u56de\u503c\u95ee\u9898 struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q){ if(root == NULL) return NULL; if(root == p || root == q) return root;//\u5b50\u6811\u53ea\u6709\u4e00\u8fb9\u6709 TreeNode* left = lowestCommonAncestor(root->left,p,q); TreeNode* right = lowestCommonAncestor(root->right,p,q); if(left != NULL && right != NULL){ return root;//p q \u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811 } if(left != NULL){ return left; } if(right != NULL){ return right; } return NULL; }","title":"68 II \u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/JZ03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","text":"\u9898\u76ee \u89e3\u6790 \u9012\u5f52\u65b9\u6cd5 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector<int> printListFromTailToHead(ListNode* head) { //\u9012\u5f52\u89e3\u6cd5 vector<int> ans; // head \u4e3a\u7a7a \uff01head \u4e3a true \u8fd4\u56de 0 // head \u975e\u7a7a, \u6267\u884cans=printfListFormTailToHead()\u9012\u5f52 if(!head) return ans; ans = printListFromTailToHead(head->next); ans.push_back(head->val); return ans; } }; \u53cd\u8f6c\u94fe\u8868 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector<int> printListFromTailToHead(ListNode* head) { ListNode* pre = nullptr; ListNode* cur = head; ListNode* temp = cur; while(cur) { temp = cur->next; cur->next = pre;//\u540e\u9762\u6b65\u9aa4\u5c06pre\u8c03\u6574\u5230cur\u4e4b\u524d\u4e86 pre = cur;//pre \u548c cur \u540e\u79fb\u4e00\u4f4d cur = temp; } //\u5f00\u8f9f\u6570\u7ec4 \u5c3e\u63d2 vector<int> ans; while(pre) { ans.push_back(pre->val); pre = pre->next; } return ans; } };","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/JZ03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/#_1","text":"","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/JZ03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/#_2","text":"","title":"\u89e3\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/JZ03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/#_3","text":"/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector<int> printListFromTailToHead(ListNode* head) { //\u9012\u5f52\u89e3\u6cd5 vector<int> ans; // head \u4e3a\u7a7a \uff01head \u4e3a true \u8fd4\u56de 0 // head \u975e\u7a7a, \u6267\u884cans=printfListFormTailToHead()\u9012\u5f52 if(!head) return ans; ans = printListFromTailToHead(head->next); ans.push_back(head->val); return ans; } };","title":"\u9012\u5f52\u65b9\u6cd5"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/JZ03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/#_4","text":"/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector<int> printListFromTailToHead(ListNode* head) { ListNode* pre = nullptr; ListNode* cur = head; ListNode* temp = cur; while(cur) { temp = cur->next; cur->next = pre;//\u540e\u9762\u6b65\u9aa4\u5c06pre\u8c03\u6574\u5230cur\u4e4b\u524d\u4e86 pre = cur;//pre \u548c cur \u540e\u79fb\u4e00\u4f4d cur = temp; } //\u5f00\u8f9f\u6570\u7ec4 \u5c3e\u63d2 vector<int> ans; while(pre) { ans.push_back(pre->val); pre = pre->next; } return ans; } };","title":"\u53cd\u8f6c\u94fe\u8868"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/","text":"\u5251\u6307offer Description \u7ec3\u4e60\u53ca\u56fe\u89e3 Software Architecture Software architecture description Installation xxxx xxxx xxxx Instructions xxxx xxxx xxxx Contribution Fork the repository Create Feat_xxx branch Commit your code Create Pull Request Gitee Feature You can use Readme_XXX.md to support different languages, such as Readme_en.md, Readme_zh.md Gitee blog blog.gitee.com Explore open source project https://gitee.com/explore The most valuable open source project GVP The manual of Gitee https://gitee.com/help The most popular members https://gitee.com/gitee-stars/","title":"\u5251\u6307offer"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#offer","text":"","title":"\u5251\u6307offer"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#description","text":"\u7ec3\u4e60\u53ca\u56fe\u89e3","title":"Description"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#software-architecture","text":"Software architecture description","title":"Software Architecture"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#installation","text":"xxxx xxxx xxxx","title":"Installation"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#instructions","text":"xxxx xxxx xxxx","title":"Instructions"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#contribution","text":"Fork the repository Create Feat_xxx branch Commit your code Create Pull Request","title":"Contribution"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/README.en/#gitee-feature","text":"You can use Readme_XXX.md to support different languages, such as Readme_en.md, Readme_zh.md Gitee blog blog.gitee.com Explore open source project https://gitee.com/explore The most valuable open source project GVP The manual of Gitee https://gitee.com/help The most popular members https://gitee.com/gitee-stars/","title":"Gitee Feature"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","text":"\u9898\u76ee \u9898\u76ee\u63cf\u8ff0\uff1a \u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4[1,2,3,2,2,2,5,4,2]\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u662f\u975e\u7a7a\u7684\uff0c\u5e76\u4e14\u7ed9\u5b9a\u7684\u6570\u7ec4\u603b\u662f\u5b58\u5728\u591a\u6570\u5143\u7d20\u30021<=\u6570\u7ec4\u957f\u5ea6<=50000\uff0c0<=\u6570\u7ec4\u5143\u7d20<=10000 \u6768\u6c0f\u77e9\u9635\u67e5\u627e \u9898\u76ee\u6240\u63d0\u4f9b\u7684\u77e9\u9635\u662f\u4e00\u79cd\u7279\u6b8a\u77e9\u9635\uff0c\u79f0\u4e4b\u4e3a\u6768\u6c0f\u77e9\u9635\u3002\u5176\u67e5\u627e\u7b97\u6cd5\u5982\u4e0b\uff1a \u4ece\u77e9\u9635\u7684\u5de6\u4e0b\u89d2\u6216\u8005\u53f3\u4e0a\u89d2\u5f00\u59cb\u9012\u5f52\u8fd0\u884c\u3002\u4ee5\u5de6\u4e0b\u89d2\u4e3a\u4f8b\u5b50\uff0cvalue\u4e3a\u9700\u8981\u67e5\u627e\u7684\u503c\u3002 \u5982\u679c\u8d85\u8fc7\u4e86\u77e9\u9635\u8303\u56f4\uff0c\u5219\u8bf4\u660e\u4e0d\u5b58\u5728\u8fd9\u6837\u7684\u5143\u7d20\uff0c\u8fd4\u56defalse\uff1b \u5426\u5219\uff0c\u5982\u5f53\u524d\u4f4d\u7f6e\u5927\u4e8evalue\uff0c\u8bf4\u660e\u8981\u79fb\u52a8\u4f4d\u7f6e\uff08\u5411\u4e0a\u79fb\u52a8\u4e00\u884c\uff09\uff0c\u662f\u7684\u6570\u503c\u51cf\u5c0f\uff0c\u9012\u5f52\u4e0a\u4e00\u884c\u3002\u5982\u5f53\u524d\u4f4d\u7f6e\u5c0f\u4e8evalue\uff0c\u8bf4\u660e\u8981\u79fb\u52a8\u4f4d\u7f6e\uff08\u5411\u53f3\u79fb\u52a8\u4e00\u4e9b\uff09\uff0c\u4f7f\u5f97\u6570\u503c\u589e\u5927\uff0c\u9012\u5f52 j = j+1\u3002\u5982\u679c\u521a\u597d\u7b49\u4e8evalue\uff0c\u8fd4\u56de\u5f53\u524d\u4f4d\u7f6etrue\u5373\u53ef\u3002 bool searchMatrix(vector<vector<int> > &matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int i = m - 1, j = 0; while (i >= 0 && j <= n - 1) { if (matrix[i][j] == target) { return true; } else if (matrix[i][j] < target) { //\u5982\u679c\u76ee\u6807\u503c\u5927\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\uff0c\u5f53\u524d\u4f4d\u7f6e\u53f3\u79fb j++; } else { //\u5982\u679c\u76ee\u6807\u503c\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\uff0c\u5f53\u524d\u4f4d\u7f6e\u4e0a\u79fb i--; } } return false; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(m+n)\u3002 \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1) \uff0c\u6ca1\u6709\u7533\u8bf7\u989d\u5916\u7684\u7a7a\u95f4\u3002","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/#_1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a \u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4[1,2,3,2,2,2,5,4,2]\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u662f\u975e\u7a7a\u7684\uff0c\u5e76\u4e14\u7ed9\u5b9a\u7684\u6570\u7ec4\u603b\u662f\u5b58\u5728\u591a\u6570\u5143\u7d20\u30021<=\u6570\u7ec4\u957f\u5ea6<=50000\uff0c0<=\u6570\u7ec4\u5143\u7d20<=10000","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/#_2","text":"\u9898\u76ee\u6240\u63d0\u4f9b\u7684\u77e9\u9635\u662f\u4e00\u79cd\u7279\u6b8a\u77e9\u9635\uff0c\u79f0\u4e4b\u4e3a\u6768\u6c0f\u77e9\u9635\u3002\u5176\u67e5\u627e\u7b97\u6cd5\u5982\u4e0b\uff1a \u4ece\u77e9\u9635\u7684\u5de6\u4e0b\u89d2\u6216\u8005\u53f3\u4e0a\u89d2\u5f00\u59cb\u9012\u5f52\u8fd0\u884c\u3002\u4ee5\u5de6\u4e0b\u89d2\u4e3a\u4f8b\u5b50\uff0cvalue\u4e3a\u9700\u8981\u67e5\u627e\u7684\u503c\u3002 \u5982\u679c\u8d85\u8fc7\u4e86\u77e9\u9635\u8303\u56f4\uff0c\u5219\u8bf4\u660e\u4e0d\u5b58\u5728\u8fd9\u6837\u7684\u5143\u7d20\uff0c\u8fd4\u56defalse\uff1b \u5426\u5219\uff0c\u5982\u5f53\u524d\u4f4d\u7f6e\u5927\u4e8evalue\uff0c\u8bf4\u660e\u8981\u79fb\u52a8\u4f4d\u7f6e\uff08\u5411\u4e0a\u79fb\u52a8\u4e00\u884c\uff09\uff0c\u662f\u7684\u6570\u503c\u51cf\u5c0f\uff0c\u9012\u5f52\u4e0a\u4e00\u884c\u3002\u5982\u5f53\u524d\u4f4d\u7f6e\u5c0f\u4e8evalue\uff0c\u8bf4\u660e\u8981\u79fb\u52a8\u4f4d\u7f6e\uff08\u5411\u53f3\u79fb\u52a8\u4e00\u4e9b\uff09\uff0c\u4f7f\u5f97\u6570\u503c\u589e\u5927\uff0c\u9012\u5f52 j = j+1\u3002\u5982\u679c\u521a\u597d\u7b49\u4e8evalue\uff0c\u8fd4\u56de\u5f53\u524d\u4f4d\u7f6etrue\u5373\u53ef\u3002 bool searchMatrix(vector<vector<int> > &matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int i = m - 1, j = 0; while (i >= 0 && j <= n - 1) { if (matrix[i][j] == target) { return true; } else if (matrix[i][j] < target) { //\u5982\u679c\u76ee\u6807\u503c\u5927\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\uff0c\u5f53\u524d\u4f4d\u7f6e\u53f3\u79fb j++; } else { //\u5982\u679c\u76ee\u6807\u503c\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\uff0c\u5f53\u524d\u4f4d\u7f6e\u4e0a\u79fb i--; } } return false; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(m+n)\u3002 \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1) \uff0c\u6ca1\u6709\u7533\u8bf7\u989d\u5916\u7684\u7a7a\u95f4\u3002","title":"\u6768\u6c0f\u77e9\u9635\u67e5\u627e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/","text":"\u6574\u7406\u725b\u5ba2\u7f51\u5251\u6307offer\u7ec3\u4e60\u9898\u603b\u7ed3\u3002 \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570 class Solution { public: int strToInt(string str) { //1. \u5b57\u7b26\u4e32\u4e3a\u7a7a if (str.empty()) return 0; // 1.1 \u8003\u8651\u524d\u9762\u7684\u7a7a\u683c \u5982\u201c -23 min\u201d int i = 0; for ( i = 0; i < str.size() && str[i] == ' '; ++i) { //\u7a7a\u64cd\u4f5c } str = str.substr(i, str.size() ); // 2. \u8003\u8651\u6b63\u8d1f\u53f7 int sign = 1; if (str[0] == '-'){ sign = -1; } string res = \"\"; if (str[0] == '+' || str[0] == '-') { res = str.substr(1, str.size() - 1); } else{ res = str; } //3. \u8003\u8651\u6570\u5b57\u8d8a\u754c \u51fa\u9519 \u95ee\u9898\u89e3\u51b3 \u7a7a\u683c\u95ee\u9898 for (int i = 0; i<res.size(); i++){ if (res[i]>'9' || res[i] < '0') //res[i] = 0;// return 0; res = res.substr(0, i); } // long long result = 0; // long long bitcount = 1; // for (int i = res.size() - 1; i >= 0 ; i--){ // // result = result + (res[i] - '0')*bitcount; // // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 // result = result*10 + (res[i] - '0'); // //\u8003\u8651\u5927\u6570 // if(sign == 1 && result > INT_MAX){ // return INT_MAX; // } // else if(sign == -1 && -result < INT_MIN){ // return INT_MIN; // } // } // // \u6b63\u5e8f\u5199\u6cd5 long long result = 0; int bitcount = 1; for (int i = 0; i <= res.size()-1 && isdigit(res[i]); ++i){ // result = result*10 + (res[i] - '0')*bitcount; // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 result = result*10 + (res[i] - '0')*bitcount; //\u8003\u8651\u5927\u6570 if(sign == 1 && result > INT_MAX){ return INT_MAX; } else if(sign == -1 && -result < INT_MIN){ return INT_MIN; } } return sign*result; } }; \u6570\u7ec4\u4e2d\u91cd\u590d\u51fa\u73b0\u7684\u6570\u5b57 int findRepeatNumber(int* nums, int numsSize){ int arr[numsSize]; memset(arr,0,sizeof(arr)); for(int i = 0;i<numsSize;i++){ if(arr[nums[i]]++) //\u7b2c\u4e8c\u6b21\u9047\u5230\u540c\u6837\u6570\u5b57\uff0cif\u8bed\u53e5\u4e3a\u771f return nums[i]; } return -1; } \u6570\u7ec4\u4e2d\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6574\u6570 \u9898\u76ee\u63cf\u8ff0\uff1a \u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4[1,2,3,2,2,2,5,4,2]\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u662f\u975e\u7a7a\u7684\uff0c\u5e76\u4e14\u7ed9\u5b9a\u7684\u6570\u7ec4\u603b\u662f\u5b58\u5728\u591a\u6570\u5143\u7d20\u30021<=\u6570\u7ec4\u957f\u5ea6<=50000\uff0c0<=\u6570\u7ec4\u5143\u7d20<=10000 \u601d\u8def \u65b9\u6cd5\u4e00\uff1a\u76f4\u63a5\u6392\u5e8f\uff0c\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\u80af\u5b9a\u5728\u4e2d\u95f4\u76f4\u63a5\u8fd4\u56de\u6570\u7ec4\u4e2d\u95f4\u7684\u6570\u5b57\u5373\u53ef\u3002 \u7f3a\u70b9\uff1a\u6548\u7387\u4f4e\uff0c\u4f7f\u7528\u4e86sort \u65b9\u6cd5\u4e8c\uff1a\u4f9d\u6b21\u904d\u5386\u6570\u7ec4\uff08\u4ee3\u7801\u5982\u4e0b\u9762code\uff09 \u627e\u51fa\u57fa\u51c6\u6570\u5b57\uff0c\u4f8b\u5982numbers[0]; \u8bb0count = 1\uff1b \u904d\u5386\u6570\u7ec4\uff0c\u82e5\u6570\u7ec4\u4e2d\u7684\u503c\u7b49\u4e8e numbers[0]\uff0ccount++\uff1b\u5426\u5219count--\uff1b \u82e5count == 0 \u65f6\uff0c\u8bf4\u660e\u7b2c\u4e00\u4e2a\u6570\u5b57numbers[0]\u4e0d\u662f\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\uff0c\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4e2a\u6570\u5b57numbers[1]; \u82e5\u627e\u5230\uff0c\u76f4\u63a5\u8fd4\u56de\u8fd9\u4e2a\u6570\u3002 code class Solution { public: int MoreThanHalfNum_Solution(vector<int> numbers) { int len = numbers.size(); int curNum = numbers[0]; int count = 1; //\u7edf\u8ba1\u51fa\u73b0\u591a\u5c11\u6b21 for(int i = 1;i<numbers.size();++i) { if(numbers[i] == curNum) count++; else { count--; if(count == 0) { //\u82e5\u7b2c\u4e00\u4e2a\u6570\u4e0d\u662f\uff0c\u90a3\u4e48\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4f4d curNum = numbers[i]; count = 1; } } } return curNum; } }; \u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868 \u8f93\u5165\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u8282\u70b9\uff0c\u4ece\u5c3e\u5230\u5934\u53cd\u8fc7\u6765\u8fd4\u56de\u6bcf\u4e2a\u8282\u70b9\u7684\u503c\uff08\u7528\u6570\u7ec4\u8fd4\u56de\uff09 \u8f93\u5165\uff1ahead = [1,3,2] \u8f93\u51fa\uff1a[2,3,1] \u9650\u5236\uff1a 0 <= \u94fe\u8868\u957f\u5ea6 <= 10000 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector<int> reversePrint(ListNode* head) { if(head == nullptr) return {}; vector<int> v; v = reversePrint(head->next); v.push_back(head->val); return v; } }; /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* reversePrint(struct ListNode* head, int* returnSize){ int total = 0; struct ListNode* p = head; int *res = malloc(10000 * sizeof(int)); memset(res, 0, 10000 * sizeof(int)); while (p) { res[total++] = p->val;//\u987a\u5e8f\u5b58\u653e p = p->next; } //\u9006\u7f6e for (int i = 0; i < total / 2; i++) { int temp = res[i]; res[i] = res[total - i - 1]; res[total - i - 1] = temp; } *returnSize = total; return res; } \u94fe\u8868\u4e2d\u6700\u540ek\u4e2a\u8282\u70b9 struct ListNode* getKthFromEnd(struct ListNode* head, int k){ struct ListNode * cur = head; int num = 0; while(cur != NULL)//\u7edf\u8ba1\u94fe\u8868\u7684\u957f\u5ea6 { num++; cur = cur->next; } cur = head; while(num != k) { cur = cur->next; num--; } return cur; } analyse C++ stack & vector\u601d\u8def /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector<int> reversePrint(ListNode* head) { vector<int> res; stack<int> st; while(head){ st.push(head->val); head = head->next; } while(!st.empty()){ res.push_back(st.top()); //stack\u5b58\u653e\u5230vector\u4e2d st.pop(); } return res; } }; \u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148 C\u8bed\u8a00 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ typedef struct TreeNode TreeNode; //\u6ce8\u610f\u5173\u4e8e\u6b64\u7c7b\u578b\u7684\u8fd4\u56de\u503c\u95ee\u9898 struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q){ if(root == NULL) return NULL; //1.\u7a7a\u6811 if(root == p || root == q) return root;//2.\u5b50\u6811\u53ea\u6709\u4e00\u8fb9\u6709 TreeNode* left = lowestCommonAncestor(root->left,p,q); //3.\u904d\u5386\u5de6\u5b50\u6811 TreeNode* right = lowestCommonAncestor(root->right,p,q); //4. \u904d\u5386\u53f3\u5b50\u6811 if(left != NULL && right != NULL){ //5. p q \u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811 return root; } if(left != NULL && right == NULL){ //6. \u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c \u5de6\u5b50\u6811\u4e0d\u7a7a return left; } if(right != NULL && left == NULL){ //7. \u53f3\u5b50\u6811\u4e0d\u7a7a\uff0c\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a return right; } return NULL; // \u5176\u4ed6\u60c5\u51b5 } \u6808\u7684\u538b\u5165\u3001\u5f39\u51fa LeetCode\u9898\u76ee\u94fe\u63a5 \u9898\u76ee\u63cf\u8ff0\uff1a \u8f93\u5165\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u7b2c\u4e00\u4e2a\u5e8f\u5217\u8868\u793a\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u8bf7\u5224\u65ad\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u662f\u5426\u53ef\u80fd\u4e3a\u8be5\u6808\u7684\u5f39\u51fa\u987a\u5e8f\u3002\u5047\u8bbe\u538b\u5165\u6808\u7684\u6240\u6709\u6570\u5b57\u5747\u4e0d\u76f8\u7b49\u3002\u4f8b\u5982\u5e8f\u52171,2,3,4,5\u662f\u67d0\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u5e8f\u52174,5,3,2,1\u662f\u8be5\u538b\u6808\u5e8f\u5217\u5bf9\u5e94\u7684\u4e00\u4e2a\u5f39\u51fa\u5e8f\u5217\uff0c\u4f464,3,5,1,2\u5c31\u4e0d\u53ef\u80fd\u662f\u8be5\u538b\u6808\u5e8f\u5217\u7684\u5f39\u51fa\u5e8f\u5217\u3002\uff08\u6ce8\u610f\uff1a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u957f\u5ea6\u662f\u76f8\u7b49\u7684\uff09 \u89e3\u6790\u601d\u8def \u6709\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u5206\u522b\u4e3apushV \u548c popV\uff0c\u5206\u522b\u8868\u793a\u7ad9\u7684\u538b\u5165\u5e8f\u5217\u548c\u5f39\u51fa\u5e8f\u5217\u3002 \u5c06pushV\u5e8f\u5217\u9010\u4e2apush\u5230\u6808st\u4e2d\u3002 \u5982\u6808\u9876\u5143\u7d20 \u548c popV\u5143\u7d20\u76f8\u7b49\uff1b\u5220\u9664\u6808\u9876\u5143\u7d20 st.pop(); class Solution { public: bool IsPopOrder(vector<int> pushV,vector<int> popV) { stack<int> st; int i = 0;//\u63a7\u5236\u5165\u6808\u7684pushV\u6570\u636e\u4e0b\u8868 int j = 0;//\u63a7\u5236\u6808\u5143\u7d20\u7684pop\uff0c\u8bb0\u5f55\u5176popv\u957f\u5ea6 while(i < pushV.size()){ // pushV\u6570\u7ec4\u7684\u503c\u5165\u6808 st.push(pushV[i]); ++i; //\u51fa\u6808\uff0cpop\u6570\u7ec4\u503c\u4f9d\u6b21\u4e0e\u6808\u91cc\u9762\u7684\u6570\u636e\u6bd4\u8f83 //\u82e5\u76f8\u7b49 pop \uff0c\u51fa\u6808\u91cc\u7684\u6570\u636e \uff1b \u82e5\u4e0d\u7b49 \u7ed3\u675f while(!st.empty() && st.top() == popV[j]){ st.pop(); ++j; } } return j == popV.size();//j\u8d70\u5b8cpopv\uff0c\u662f\u5339\u914d } }; JZ8\uff1a\u4e8c\u53c9\u6811\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9 \u4ee3\u7801\uff0c\u9012\u5f52\u5f0f\uff1a /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public: vector<TreeLinkNode*> nodes; //\u4e2d\u5e8f\u904d\u5386\u5b50\u51fd\u6570\uff0c\u9012\u5f52\u5f0f void InOrder(TreeLinkNode* root) { if(root == nullptr) return; InOrder(root->left); nodes.push_back(root); InOrder(root->right); } TreeLinkNode* GetNext(TreeLinkNode* pNode) { TreeLinkNode* root = pNode; while(root->next) root = root->next; //\u83b7\u53d6\u6839\u7ed3\u70b9 InOrder(root);//\u4e2d\u5e8f\u904d\u5386 int n = nodes.size(); for(int i = 0; i<n-1; i++) { TreeLinkNode* cur = nodes[i]; if(pNode == cur) { return nodes[i+1]; } } return NULL; } }; JZ13 \u673a\u5668\u4eba\u7684\u8fd0\u52a8\u8303\u56f4 \u9898\u76ee\u94fe\u63a5 \uff1b \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08dfs\uff09 \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u4e00\u822c\u7528\u4e8e\u6811\u6216\u8005\u56fe\u7684\u904d\u5386\uff0c\u5176\u4ed6\u6709\u5206\u652f\u7684\uff08\u5982\u4e8c\u7ef4\u77e9\u9635\uff09\u4e5f\u9002\u7528\u3002\u5b83\u7684\u539f\u7406\u662f\u4ece\u521d\u59cb\u70b9\u5f00\u59cb\uff0c\u4e00\u76f4\u6cbf\u7740\u540c\u4e00\u4e2a\u5206\u652f\u904d\u5386\uff0c\u76f4\u5230\u8be5\u5206\u652f\u7ed3\u675f\uff0c\u7136\u540e\u56de\u6eaf\u5230\u4e0a\u4e00\u7ea7\u7ee7\u7eed\u6cbf\u7740\u4e00\u4e2a\u5206\u652f\u8d70\u5230\u5e95\uff0c\u5982\u6b64\u5f80\u590d\uff0c\u76f4\u5230\u6240\u6709\u7684\u8282\u70b9\u90fd\u6709\u88ab\u8bbf\u95ee\u5230\u3002 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u662f\u4e00\u6761\u8def\u8d70\u5230\u5e95\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u3002\u53ea\u8981\u904d\u5386\u7684\u65f6\u5019\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u4f9d\u6b21\u8bbf\u95ee\u4e0e\u5176\u76f8\u90bb\u7684\u56db\u4e2a\u65b9\u5411\uff08\u5982\u679c\u53ef\u4ee5\u8bbf\u95ee\uff09\uff0c\u7136\u540e\u518d\u5c06\u4e0e\u8fd9\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u8282\u70b9\u90fd\u4f9d\u6b21\u52a0\u5165\u961f\u5217\u4e2d\u6392\u961f\u7b49\u5f85\u8bbf\u95ee\u3002\u8fd9\u6837\u4e0b\u6765\uff0c\u6bcf\u6b21\u8bbf\u95ee\u90fd\u662f\u4e00\u5708\u4e00\u5708\u63a8\u8fdb\uff0c\u56e0\u6b64\u662f\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u3002","title":"\u5251\u6307offer\u4e60\u9898\u603b\u7ed3"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_1","text":"class Solution { public: int strToInt(string str) { //1. \u5b57\u7b26\u4e32\u4e3a\u7a7a if (str.empty()) return 0; // 1.1 \u8003\u8651\u524d\u9762\u7684\u7a7a\u683c \u5982\u201c -23 min\u201d int i = 0; for ( i = 0; i < str.size() && str[i] == ' '; ++i) { //\u7a7a\u64cd\u4f5c } str = str.substr(i, str.size() ); // 2. \u8003\u8651\u6b63\u8d1f\u53f7 int sign = 1; if (str[0] == '-'){ sign = -1; } string res = \"\"; if (str[0] == '+' || str[0] == '-') { res = str.substr(1, str.size() - 1); } else{ res = str; } //3. \u8003\u8651\u6570\u5b57\u8d8a\u754c \u51fa\u9519 \u95ee\u9898\u89e3\u51b3 \u7a7a\u683c\u95ee\u9898 for (int i = 0; i<res.size(); i++){ if (res[i]>'9' || res[i] < '0') //res[i] = 0;// return 0; res = res.substr(0, i); } // long long result = 0; // long long bitcount = 1; // for (int i = res.size() - 1; i >= 0 ; i--){ // // result = result + (res[i] - '0')*bitcount; // // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 // result = result*10 + (res[i] - '0'); // //\u8003\u8651\u5927\u6570 // if(sign == 1 && result > INT_MAX){ // return INT_MAX; // } // else if(sign == -1 && -result < INT_MIN){ // return INT_MIN; // } // } // // \u6b63\u5e8f\u5199\u6cd5 long long result = 0; int bitcount = 1; for (int i = 0; i <= res.size()-1 && isdigit(res[i]); ++i){ // result = result*10 + (res[i] - '0')*bitcount; // bitcount = bitcount * 10; // \u4ece\u4e2a\u4f4d\u5f80\u4e0a\u52a0 result = result*10 + (res[i] - '0')*bitcount; //\u8003\u8651\u5927\u6570 if(sign == 1 && result > INT_MAX){ return INT_MAX; } else if(sign == -1 && -result < INT_MIN){ return INT_MIN; } } return sign*result; } };","title":"\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_2","text":"int findRepeatNumber(int* nums, int numsSize){ int arr[numsSize]; memset(arr,0,sizeof(arr)); for(int i = 0;i<numsSize;i++){ if(arr[nums[i]]++) //\u7b2c\u4e8c\u6b21\u9047\u5230\u540c\u6837\u6570\u5b57\uff0cif\u8bed\u53e5\u4e3a\u771f return nums[i]; } return -1; }","title":"\u6570\u7ec4\u4e2d\u91cd\u590d\u51fa\u73b0\u7684\u6570\u5b57"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_3","text":"\u9898\u76ee\u63cf\u8ff0\uff1a \u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4[1,2,3,2,2,2,5,4,2]\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u662f\u975e\u7a7a\u7684\uff0c\u5e76\u4e14\u7ed9\u5b9a\u7684\u6570\u7ec4\u603b\u662f\u5b58\u5728\u591a\u6570\u5143\u7d20\u30021<=\u6570\u7ec4\u957f\u5ea6<=50000\uff0c0<=\u6570\u7ec4\u5143\u7d20<=10000","title":"\u6570\u7ec4\u4e2d\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6574\u6570"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_4","text":"\u65b9\u6cd5\u4e00\uff1a\u76f4\u63a5\u6392\u5e8f\uff0c\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\u80af\u5b9a\u5728\u4e2d\u95f4\u76f4\u63a5\u8fd4\u56de\u6570\u7ec4\u4e2d\u95f4\u7684\u6570\u5b57\u5373\u53ef\u3002 \u7f3a\u70b9\uff1a\u6548\u7387\u4f4e\uff0c\u4f7f\u7528\u4e86sort \u65b9\u6cd5\u4e8c\uff1a\u4f9d\u6b21\u904d\u5386\u6570\u7ec4\uff08\u4ee3\u7801\u5982\u4e0b\u9762code\uff09 \u627e\u51fa\u57fa\u51c6\u6570\u5b57\uff0c\u4f8b\u5982numbers[0]; \u8bb0count = 1\uff1b \u904d\u5386\u6570\u7ec4\uff0c\u82e5\u6570\u7ec4\u4e2d\u7684\u503c\u7b49\u4e8e numbers[0]\uff0ccount++\uff1b\u5426\u5219count--\uff1b \u82e5count == 0 \u65f6\uff0c\u8bf4\u660e\u7b2c\u4e00\u4e2a\u6570\u5b57numbers[0]\u4e0d\u662f\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\uff0c\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4e2a\u6570\u5b57numbers[1]; \u82e5\u627e\u5230\uff0c\u76f4\u63a5\u8fd4\u56de\u8fd9\u4e2a\u6570\u3002","title":"\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#code","text":"class Solution { public: int MoreThanHalfNum_Solution(vector<int> numbers) { int len = numbers.size(); int curNum = numbers[0]; int count = 1; //\u7edf\u8ba1\u51fa\u73b0\u591a\u5c11\u6b21 for(int i = 1;i<numbers.size();++i) { if(numbers[i] == curNum) count++; else { count--; if(count == 0) { //\u82e5\u7b2c\u4e00\u4e2a\u6570\u4e0d\u662f\uff0c\u90a3\u4e48\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4f4d curNum = numbers[i]; count = 1; } } } return curNum; } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_5","text":"\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u8282\u70b9\uff0c\u4ece\u5c3e\u5230\u5934\u53cd\u8fc7\u6765\u8fd4\u56de\u6bcf\u4e2a\u8282\u70b9\u7684\u503c\uff08\u7528\u6570\u7ec4\u8fd4\u56de\uff09 \u8f93\u5165\uff1ahead = [1,3,2] \u8f93\u51fa\uff1a[2,3,1] \u9650\u5236\uff1a 0 <= \u94fe\u8868\u957f\u5ea6 <= 10000 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector<int> reversePrint(ListNode* head) { if(head == nullptr) return {}; vector<int> v; v = reversePrint(head->next); v.push_back(head->val); return v; } }; /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* reversePrint(struct ListNode* head, int* returnSize){ int total = 0; struct ListNode* p = head; int *res = malloc(10000 * sizeof(int)); memset(res, 0, 10000 * sizeof(int)); while (p) { res[total++] = p->val;//\u987a\u5e8f\u5b58\u653e p = p->next; } //\u9006\u7f6e for (int i = 0; i < total / 2; i++) { int temp = res[i]; res[i] = res[total - i - 1]; res[total - i - 1] = temp; } *returnSize = total; return res; }","title":"\u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#k","text":"struct ListNode* getKthFromEnd(struct ListNode* head, int k){ struct ListNode * cur = head; int num = 0; while(cur != NULL)//\u7edf\u8ba1\u94fe\u8868\u7684\u957f\u5ea6 { num++; cur = cur->next; } cur = head; while(num != k) { cur = cur->next; num--; } return cur; }","title":"\u94fe\u8868\u4e2d\u6700\u540ek\u4e2a\u8282\u70b9"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#analyse","text":"","title":"analyse"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#c-stack-vector","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector<int> reversePrint(ListNode* head) { vector<int> res; stack<int> st; while(head){ st.push(head->val); head = head->next; } while(!st.empty()){ res.push_back(st.top()); //stack\u5b58\u653e\u5230vector\u4e2d st.pop(); } return res; } };","title":"C++ stack &amp; vector\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_6","text":"","title":"\u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#c","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ typedef struct TreeNode TreeNode; //\u6ce8\u610f\u5173\u4e8e\u6b64\u7c7b\u578b\u7684\u8fd4\u56de\u503c\u95ee\u9898 struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q){ if(root == NULL) return NULL; //1.\u7a7a\u6811 if(root == p || root == q) return root;//2.\u5b50\u6811\u53ea\u6709\u4e00\u8fb9\u6709 TreeNode* left = lowestCommonAncestor(root->left,p,q); //3.\u904d\u5386\u5de6\u5b50\u6811 TreeNode* right = lowestCommonAncestor(root->right,p,q); //4. \u904d\u5386\u53f3\u5b50\u6811 if(left != NULL && right != NULL){ //5. p q \u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811 return root; } if(left != NULL && right == NULL){ //6. \u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c \u5de6\u5b50\u6811\u4e0d\u7a7a return left; } if(right != NULL && left == NULL){ //7. \u53f3\u5b50\u6811\u4e0d\u7a7a\uff0c\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a return right; } return NULL; // \u5176\u4ed6\u60c5\u51b5 }","title":"C\u8bed\u8a00"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_7","text":"LeetCode\u9898\u76ee\u94fe\u63a5 \u9898\u76ee\u63cf\u8ff0\uff1a \u8f93\u5165\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u7b2c\u4e00\u4e2a\u5e8f\u5217\u8868\u793a\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u8bf7\u5224\u65ad\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u662f\u5426\u53ef\u80fd\u4e3a\u8be5\u6808\u7684\u5f39\u51fa\u987a\u5e8f\u3002\u5047\u8bbe\u538b\u5165\u6808\u7684\u6240\u6709\u6570\u5b57\u5747\u4e0d\u76f8\u7b49\u3002\u4f8b\u5982\u5e8f\u52171,2,3,4,5\u662f\u67d0\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u5e8f\u52174,5,3,2,1\u662f\u8be5\u538b\u6808\u5e8f\u5217\u5bf9\u5e94\u7684\u4e00\u4e2a\u5f39\u51fa\u5e8f\u5217\uff0c\u4f464,3,5,1,2\u5c31\u4e0d\u53ef\u80fd\u662f\u8be5\u538b\u6808\u5e8f\u5217\u7684\u5f39\u51fa\u5e8f\u5217\u3002\uff08\u6ce8\u610f\uff1a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u957f\u5ea6\u662f\u76f8\u7b49\u7684\uff09","title":"\u6808\u7684\u538b\u5165\u3001\u5f39\u51fa"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#_8","text":"\u6709\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u5206\u522b\u4e3apushV \u548c popV\uff0c\u5206\u522b\u8868\u793a\u7ad9\u7684\u538b\u5165\u5e8f\u5217\u548c\u5f39\u51fa\u5e8f\u5217\u3002 \u5c06pushV\u5e8f\u5217\u9010\u4e2apush\u5230\u6808st\u4e2d\u3002 \u5982\u6808\u9876\u5143\u7d20 \u548c popV\u5143\u7d20\u76f8\u7b49\uff1b\u5220\u9664\u6808\u9876\u5143\u7d20 st.pop(); class Solution { public: bool IsPopOrder(vector<int> pushV,vector<int> popV) { stack<int> st; int i = 0;//\u63a7\u5236\u5165\u6808\u7684pushV\u6570\u636e\u4e0b\u8868 int j = 0;//\u63a7\u5236\u6808\u5143\u7d20\u7684pop\uff0c\u8bb0\u5f55\u5176popv\u957f\u5ea6 while(i < pushV.size()){ // pushV\u6570\u7ec4\u7684\u503c\u5165\u6808 st.push(pushV[i]); ++i; //\u51fa\u6808\uff0cpop\u6570\u7ec4\u503c\u4f9d\u6b21\u4e0e\u6808\u91cc\u9762\u7684\u6570\u636e\u6bd4\u8f83 //\u82e5\u76f8\u7b49 pop \uff0c\u51fa\u6808\u91cc\u7684\u6570\u636e \uff1b \u82e5\u4e0d\u7b49 \u7ed3\u675f while(!st.empty() && st.top() == popV[j]){ st.pop(); ++j; } } return j == popV.size();//j\u8d70\u5b8cpopv\uff0c\u662f\u5339\u914d } };","title":"\u89e3\u6790\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#jz8","text":"\u4ee3\u7801\uff0c\u9012\u5f52\u5f0f\uff1a /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public: vector<TreeLinkNode*> nodes; //\u4e2d\u5e8f\u904d\u5386\u5b50\u51fd\u6570\uff0c\u9012\u5f52\u5f0f void InOrder(TreeLinkNode* root) { if(root == nullptr) return; InOrder(root->left); nodes.push_back(root); InOrder(root->right); } TreeLinkNode* GetNext(TreeLinkNode* pNode) { TreeLinkNode* root = pNode; while(root->next) root = root->next; //\u83b7\u53d6\u6839\u7ed3\u70b9 InOrder(root);//\u4e2d\u5e8f\u904d\u5386 int n = nodes.size(); for(int i = 0; i<n-1; i++) { TreeLinkNode* cur = nodes[i]; if(pNode == cur) { return nodes[i+1]; } } return NULL; } };","title":"JZ8\uff1a\u4e8c\u53c9\u6811\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/#jz13","text":"\u9898\u76ee\u94fe\u63a5 \uff1b \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08dfs\uff09 \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u4e00\u822c\u7528\u4e8e\u6811\u6216\u8005\u56fe\u7684\u904d\u5386\uff0c\u5176\u4ed6\u6709\u5206\u652f\u7684\uff08\u5982\u4e8c\u7ef4\u77e9\u9635\uff09\u4e5f\u9002\u7528\u3002\u5b83\u7684\u539f\u7406\u662f\u4ece\u521d\u59cb\u70b9\u5f00\u59cb\uff0c\u4e00\u76f4\u6cbf\u7740\u540c\u4e00\u4e2a\u5206\u652f\u904d\u5386\uff0c\u76f4\u5230\u8be5\u5206\u652f\u7ed3\u675f\uff0c\u7136\u540e\u56de\u6eaf\u5230\u4e0a\u4e00\u7ea7\u7ee7\u7eed\u6cbf\u7740\u4e00\u4e2a\u5206\u652f\u8d70\u5230\u5e95\uff0c\u5982\u6b64\u5f80\u590d\uff0c\u76f4\u5230\u6240\u6709\u7684\u8282\u70b9\u90fd\u6709\u88ab\u8bbf\u95ee\u5230\u3002 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u662f\u4e00\u6761\u8def\u8d70\u5230\u5e95\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5c1d\u8bd5\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u3002\u53ea\u8981\u904d\u5386\u7684\u65f6\u5019\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u4f9d\u6b21\u8bbf\u95ee\u4e0e\u5176\u76f8\u90bb\u7684\u56db\u4e2a\u65b9\u5411\uff08\u5982\u679c\u53ef\u4ee5\u8bbf\u95ee\uff09\uff0c\u7136\u540e\u518d\u5c06\u4e0e\u8fd9\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u8282\u70b9\u90fd\u4f9d\u6b21\u52a0\u5165\u961f\u5217\u4e2d\u6392\u961f\u7b49\u5f85\u8bbf\u95ee\u3002\u8fd9\u6837\u4e0b\u6765\uff0c\u6bcf\u6b21\u8bbf\u95ee\u90fd\u662f\u4e00\u5708\u4e00\u5708\u63a8\u8fdb\uff0c\u56e0\u6b64\u662f\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u3002","title":"JZ13 \u673a\u5668\u4eba\u7684\u8fd0\u52a8\u8303\u56f4"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","text":"\u9898\u76ee \u9898\u76ee\u63cf\u8ff0\uff1a \u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4[1,2,3,2,2,2,5,4,2]\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u662f\u975e\u7a7a\u7684\uff0c\u5e76\u4e14\u7ed9\u5b9a\u7684\u6570\u7ec4\u603b\u662f\u5b58\u5728\u591a\u6570\u5143\u7d20\u30021<=\u6570\u7ec4\u957f\u5ea6<=50000\uff0c0<=\u6570\u7ec4\u5143\u7d20<=10000 \u601d\u8def \u65b9\u6cd5\u4e00\uff1a\u76f4\u63a5\u6392\u5e8f\uff0c\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\u80af\u5b9a\u5728\u4e2d\u95f4\u76f4\u63a5\u8fd4\u56de\u6570\u7ec4\u4e2d\u95f4\u7684\u6570\u5b57\u5373\u53ef\u3002 \u7f3a\u70b9\uff1a\u6548\u7387\u4f4e\uff0c\u4f7f\u7528\u4e86sort \u65b9\u6cd5\u4e8c\uff1a\u4f9d\u6b21\u904d\u5386\u6570\u7ec4\uff08\u4ee3\u7801\u5982\u4e0b\u9762code\uff09 \u627e\u51fa\u57fa\u51c6\u6570\u5b57\uff0c\u4f8b\u5982numbers[0]; \u8bb0count = 1\uff1b \u904d\u5386\u6570\u7ec4\uff0c\u82e5\u6570\u7ec4\u4e2d\u7684\u503c\u7b49\u4e8e numbers[0]\uff0ccount++\uff1b\u5426\u5219count--\uff1b \u82e5count == 0 \u65f6\uff0c\u8bf4\u660e\u7b2c\u4e00\u4e2a\u6570\u5b57numbers[0]\u4e0d\u662f\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\uff0c\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4e2a\u6570\u5b57numbers[1]; \u82e5\u627e\u5230\uff0c\u76f4\u63a5\u8fd4\u56de\u8fd9\u4e2a\u6570\u3002 code class Solution { public: int MoreThanHalfNum_Solution(vector<int> numbers) { int len = numbers.size(); int curNum = numbers[0]; int count = 1; //\u7edf\u8ba1\u51fa\u73b0\u591a\u5c11\u6b21 for(int i = 1;i<numbers.size();++i) { if(numbers[i] == curNum) count++; else { count--; if(count == 0) { //\u82e5\u7b2c\u4e00\u4e2a\u6570\u4e0d\u662f\uff0c\u90a3\u4e48\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4f4d curNum = numbers[i]; count = 1; } } } return curNum; } };","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/#_1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a \u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4[1,2,3,2,2,2,5,4,2]\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u662f\u975e\u7a7a\u7684\uff0c\u5e76\u4e14\u7ed9\u5b9a\u7684\u6570\u7ec4\u603b\u662f\u5b58\u5728\u591a\u6570\u5143\u7d20\u30021<=\u6570\u7ec4\u957f\u5ea6<=50000\uff0c0<=\u6570\u7ec4\u5143\u7d20<=10000","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/#_2","text":"\u65b9\u6cd5\u4e00\uff1a\u76f4\u63a5\u6392\u5e8f\uff0c\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\u80af\u5b9a\u5728\u4e2d\u95f4\u76f4\u63a5\u8fd4\u56de\u6570\u7ec4\u4e2d\u95f4\u7684\u6570\u5b57\u5373\u53ef\u3002 \u7f3a\u70b9\uff1a\u6548\u7387\u4f4e\uff0c\u4f7f\u7528\u4e86sort \u65b9\u6cd5\u4e8c\uff1a\u4f9d\u6b21\u904d\u5386\u6570\u7ec4\uff08\u4ee3\u7801\u5982\u4e0b\u9762code\uff09 \u627e\u51fa\u57fa\u51c6\u6570\u5b57\uff0c\u4f8b\u5982numbers[0]; \u8bb0count = 1\uff1b \u904d\u5386\u6570\u7ec4\uff0c\u82e5\u6570\u7ec4\u4e2d\u7684\u503c\u7b49\u4e8e numbers[0]\uff0ccount++\uff1b\u5426\u5219count--\uff1b \u82e5count == 0 \u65f6\uff0c\u8bf4\u660e\u7b2c\u4e00\u4e2a\u6570\u5b57numbers[0]\u4e0d\u662f\u51fa\u73b0\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57\uff0c\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4e2a\u6570\u5b57numbers[1]; \u82e5\u627e\u5230\uff0c\u76f4\u63a5\u8fd4\u56de\u8fd9\u4e2a\u6570\u3002","title":"\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/#code","text":"class Solution { public: int MoreThanHalfNum_Solution(vector<int> numbers) { int len = numbers.size(); int curNum = numbers[0]; int count = 1; //\u7edf\u8ba1\u51fa\u73b0\u591a\u5c11\u6b21 for(int i = 1;i<numbers.size();++i) { if(numbers[i] == curNum) count++; else { count--; if(count == 0) { //\u82e5\u7b2c\u4e00\u4e2a\u6570\u4e0d\u662f\uff0c\u90a3\u4e48\u7ee7\u7eed\u627e\u6570\u7ec4\u4e0b\u4e00\u4f4d curNum = numbers[i]; count = 1; } } } return curNum; } };","title":"code"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/","text":"","title":"17\u7535\u8bdd\u53f7\u7801\u7684\u7ec4\u5408"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u6309 \u5c42\u5e8f\u904d\u5386 \u5f97\u5230\u7684\u8282\u70b9\u503c\u3002 \uff08\u5373\u9010\u5c42\u5730\uff0c\u4ece\u5de6\u5230\u53f3\u8bbf\u95ee\u6240\u6709\u8282\u70b9\uff09\u3002 \u793a\u4f8b\uff1a \u4e8c\u53c9\u6811\uff1a[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 \u8fd4\u56de\u5176\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff1a [ [3], [9,20], [15,7] ] \u4ee3\u7801\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { if(root == nullptr) //root\u4e3a\u7a7a return vector<vector<int>>(); queue<TreeNode*> q; //\u961f\u5217 int levelSize = 1; q.push(root); //push\u6839\u7ed3\u70b9 vector<vector<int>> vv; while(!q.empty()) //\u961f\u5217\u4e0d\u4e3a\u7a7a { //\u6309\u5c42\u51fa vector<int> v; for(int i = 0; i < levelSize; ++i) { TreeNode* front = q.front(); q.pop(); v.push_back(front->val); if(front->left) { q.push(front->left); } if(front->right) { q.push(front->right); } } //\u51fa\u5b8c\u4e00\u5c42\uff0c\u4e0b\u4e00\u5c42\u5165\u961f\u5217 levelSize = q.size(); vv.push_back(v); } return vv; } };","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u6309 \u5c42\u5e8f\u904d\u5386 \u5f97\u5230\u7684\u8282\u70b9\u503c\u3002 \uff08\u5373\u9010\u5c42\u5730\uff0c\u4ece\u5de6\u5230\u53f3\u8bbf\u95ee\u6240\u6709\u8282\u70b9\uff09\u3002 \u793a\u4f8b\uff1a \u4e8c\u53c9\u6811\uff1a[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 \u8fd4\u56de\u5176\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff1a [ [3], [9,20], [15,7] ] \u4ee3\u7801\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { if(root == nullptr) //root\u4e3a\u7a7a return vector<vector<int>>(); queue<TreeNode*> q; //\u961f\u5217 int levelSize = 1; q.push(root); //push\u6839\u7ed3\u70b9 vector<vector<int>> vv; while(!q.empty()) //\u961f\u5217\u4e0d\u4e3a\u7a7a { //\u6309\u5c42\u51fa vector<int> v; for(int i = 0; i < levelSize; ++i) { TreeNode* front = q.front(); q.pop(); v.push_back(front->val); if(front->left) { q.push(front->left); } if(front->right) { q.push(front->right); } } //\u51fa\u5b8c\u4e00\u5c42\uff0c\u4e0b\u4e00\u5c42\u5165\u961f\u5217 levelSize = q.size(); vv.push_back(v); } return vv; } };","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801 \u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> preorderTraversal(TreeNode* root) { vector<int> v; if(root == nullptr) return v; stack<TreeNode*> st; TreeNode* cur = root; while(cur !=nullptr || !st.empty()) { while(cur != nullptr){ v.push_back(cur->val); st.push(cur); cur = cur->left; } TreeNode* top = st.top();//\u53d6\u6808\u9876\u5143\u7d20 st.pop(); cur = top->right; } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/#_2","text":"\u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> preorderTraversal(TreeNode* root) { vector<int> v; if(root == nullptr) return v; stack<TreeNode*> st; TreeNode* cur = root; while(cur !=nullptr || !st.empty()) { while(cur != nullptr){ v.push_back(cur->val); st.push(cur); cur = cur->left; } TreeNode* top = st.top();//\u53d6\u6808\u9876\u5143\u7d20 st.pop(); cur = top->right; } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801 \u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> postorderTraversal(TreeNode* root) { TreeNode *cur = root; vector<int> v; stack<TreeNode*> st; TreeNode *prev = nullptr; while(cur != nullptr || !st.empty()){ while(cur){ st.push(cur); cur = cur->left; } //\u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c\u6216\u53f3\u5b50\u6811\u5df2\u7ecf\u8bbf\u95ee\u5b8c TreeNode *top = st.top(); if(top->right == nullptr || top->right == prev){ st.pop(); v.push_back(top->val); prev = top; } else { cur = top->right; } } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#_2","text":"\u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> postorderTraversal(TreeNode* root) { TreeNode *cur = root; vector<int> v; stack<TreeNode*> st; TreeNode *prev = nullptr; while(cur != nullptr || !st.empty()){ while(cur){ st.push(cur); cur = cur->left; } //\u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c\u6216\u53f3\u5b50\u6811\u5df2\u7ecf\u8bbf\u95ee\u5b8c TreeNode *top = st.top(); if(top->right == nullptr || top->right == prev){ st.pop(); v.push_back(top->val); prev = top; } else { cur = top->right; } } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","text":"\u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148 LeetCode\u9898\u76ee\u94fe\u63a5 \u9012\u5f52\u6cd5\u53c2\u8003 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //1.\u6839\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u6216\u6839\u7ed3\u70b9\u662f\u5176\u4e2d\u4e00\u4e2a\u6216\u4e24\u4e2a\u8282\u70b9 \u8fd4\u56de \u6839\u7ed3\u70b9 if(root == nullptr || root == p || root == q) return root; //2. \u9012\u5f52\u904d\u5386\u5de6\u53f3\u5b50\u6811\uff0c\u627e\u8282\u70b9 TreeNode *left = lowestCommonAncestor(root->left, p, q); TreeNode *right = lowestCommonAncestor(root->right, p, q); //3.\u82e5left\u4e14right\u4e0d\u7a7a\uff0c\u8bf4\u660ep\uff0cq\u5c31\u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811\u4e2d if(left != nullptr && right != nullptr) return root; else if((left != nullptr && right == nullptr) || (left == nullptr && right != nullptr) ) { //4. \u82e5\u5de6\u53f3\u5b50\u6811\u5176\u4e2d\u4e00\u4e2a\u4e0d\u7a7a\uff0c\u5c31\u8fd4\u56de\u6b64\u975e\u7a7a\u8282\u70b9 return left ? left : right; } return nullptr; } }; \u53c2\u8003\u601d\u8def\u56fe\uff1a \u53c2\u8003\u601d\u8def \uff1a\u70b9\u51fb\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#_1","text":"LeetCode\u9898\u76ee\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#_2","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //1.\u6839\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u6216\u6839\u7ed3\u70b9\u662f\u5176\u4e2d\u4e00\u4e2a\u6216\u4e24\u4e2a\u8282\u70b9 \u8fd4\u56de \u6839\u7ed3\u70b9 if(root == nullptr || root == p || root == q) return root; //2. \u9012\u5f52\u904d\u5386\u5de6\u53f3\u5b50\u6811\uff0c\u627e\u8282\u70b9 TreeNode *left = lowestCommonAncestor(root->left, p, q); TreeNode *right = lowestCommonAncestor(root->right, p, q); //3.\u82e5left\u4e14right\u4e0d\u7a7a\uff0c\u8bf4\u660ep\uff0cq\u5c31\u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811\u4e2d if(left != nullptr && right != nullptr) return root; else if((left != nullptr && right == nullptr) || (left == nullptr && right != nullptr) ) { //4. \u82e5\u5de6\u53f3\u5b50\u6811\u5176\u4e2d\u4e00\u4e2a\u4e0d\u7a7a\uff0c\u5c31\u8fd4\u56de\u6b64\u975e\u7a7a\u8282\u70b9 return left ? left : right; } return nullptr; } }; \u53c2\u8003\u601d\u8def\u56fe\uff1a \u53c2\u8003\u601d\u8def \uff1a\u70b9\u51fb\u94fe\u63a5","title":"\u9012\u5f52\u6cd5\u53c2\u8003"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","text":"\u6839\u636e\u4e8c\u53c9\u6811\u521b\u5efa\u5b57\u7b26\u4e32 \u9898\u76ee\u94fe\u63a5 \u4f60\u9700\u8981\u91c7\u7528\u524d\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\uff0c\u5c06\u4e00\u4e2a\u4e8c\u53c9\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u7531\u62ec\u53f7\u548c\u6574\u6570\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u7a7a\u8282\u70b9\u5219\u7528\u4e00\u5bf9\u7a7a\u62ec\u53f7 \"()\" \u8868\u793a\u3002\u800c\u4e14\u4f60\u9700\u8981\u7701\u7565\u6240\u6709\u4e0d\u5f71\u54cd\u5b57\u7b26\u4e32\u4e0e\u539f\u59cb\u4e8c\u53c9\u6811\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u7684\u7a7a\u62ec\u53f7\u5bf9\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,4] 1 / \\ 2 3 / 4 \u8f93\u51fa: \"1(2(4))(3)\" \u89e3\u91ca: \u539f\u672c\u5c06\u662f\u201c1(2(4)())(3())\u201d\uff0c \u5728\u4f60\u7701\u7565\u6240\u6709\u4e0d\u5fc5\u8981\u7684\u7a7a\u62ec\u53f7\u5bf9\u4e4b\u540e\uff0c \u5b83\u5c06\u662f\u201c1(2(4))(3)\u201d\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 \u8f93\u51fa: \"1(2()(4))(3)\" \u89e3\u91ca: \u548c\u7b2c\u4e00\u4e2a\u793a\u4f8b\u76f8\u4f3c\uff0c \u9664\u4e86\u6211\u4eec\u4e0d\u80fd\u7701\u7565\u7b2c\u4e00\u4e2a\u5bf9\u62ec\u53f7\u6765\u4e2d\u65ad\u8f93\u5165\u548c\u8f93\u51fa\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u3002 \u601d\u8def\u4e00\uff1a\u4f20\u503c\u8fd4\u56de \u4f20\u503c\u8fd4\u56de\u4e00\uff1a \u601d\u8def\uff1a \u6ca1\u6709\u8282\u70b9\uff0c\u8fd4\u56de\u7a7a \u6ca1\u6709\u5de6\u53f3\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u672c\u8282\u70b9\u503c \u6ca1\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u53ea\u9700\u8981\u5728\u5de6\u5b50\u6811\u8282\u70b9\u5916\u52a0\u62ec\u53f7\uff0c\u53f3\u5b50\u6811\u4e0d\u505a\u4efb\u4f55\u5904\u7406\uff1b \u53ea\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u5de6\u5b50\u6811\u8282\u70b9\u4e0d\u5b58\u5728\uff0c\u5148\u7ed9\u5de6\u5b50\u6811\u52a0\u4e00\u5c42\uff08\uff09,\u5728\u5bf9\u53f3\u5b50\u6811\u8fdb\u884c\u5904\u7406\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return \"\"; if(root->left == nullptr && root->right == nullptr) return to_string(root->val) ; if(root->right == nullptr) return to_string(root->val) + \"(\" + tree2str(root->left) + \")\"; return to_string(root->val) + \"(\" + tree2str(root->left) + \")\" + \"(\" + tree2str(root->right) + \")\"; } }; \u8fd0\u884c\u7ed3\u679c\uff1a \u9012\u5f52\u5206\u6790\u56fe\uff1a \u4f20\u503c\u8fd4\u56de\u4e8c\uff1a \u601d\u8def\uff1a \u82e5\u6839\u4e3a\u7a7a\uff0creturn\u7a7a \u82e5\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u6216\u8005\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u5de6\u6811\uff0c\u5e76\u5728\u5de6\u6811\u5916\u52a0\u62ec\u53f7\uff08\u5de6\u6811\u4e3a\u7a7a\u4e5f\u8981\u52a0\u62ec\u53f7\uff09 \u82e5\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u53f3\u5b50\u6811\uff0c\u53f3\u5b50\u6811\u5916\u52a0\u62ec\u53f7 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { //1.\u7a7a\u6811 if(root == nullptr) return \"\"; string str; str += to_string(root->val); //2.\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->left || root->right) str = str + \"(\" + tree2str(root->left) + \")\"; //3.\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->right) str = str + \"(\" + tree2str(root->right) + \")\"; return str; } }; \u9012\u5f52\u5206\u6790\u56fe\uff1a \u6539\u5199\u4e0a\u8ff0\u4ee3\u7801\uff0c\u53c2\u8003\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return string(); string str; str += to_string(root->val); //1.\u5de6\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u503c\u5916\u5e26\u62ec\u53f7\uff1b\u53f3\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u7684\u7a7a\u62ec\u53f7\u4e0d\u53ef\u7701\u7565 if(root->left != nullptr || root->right != nullptr) { str +=\"(\"; str += tree2str(root->left); str += \")\"; } //2.\u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u5916\u9762\u5e26\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; str += tree2str(root->right); str += \")\"; } return str; } }; \u4e0a\u8ff0\u4ee3\u7801\u5b58\u5728\u5f88\u5927\u95ee\u9898\uff0creturn str\u662f\u4f20\u503c\u8fd4\u56de\uff0c\u5b58\u5728\u5927\u91cf\u7684string\u6df1\u62f7\u8d1d\uff0c\u6240\u4ee5\u4e0b\u9762\u7ed9\u51fa\u53e6\u4e00\u79cd\u65b9\u6cd5\u3002 \u601d\u8def\u4e8c\uff1a\u4f20\u5f15\u7528 \u76f4\u63a5\u6539\u4e3a\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d\u6b21\u6570\u3002 \u5206\u6790\u5982\u4e0b\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void _tree2str(TreeNode* root, string& str) //\u901a\u8fc7\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d { if(root == nullptr) return ; str += to_string(root->val); //1.\u5de6\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u6570\u4e0d\u4e3a\u7a7a if(root->left != nullptr || root->right != nullptr) { str += \"(\"; _tree2str(root->left, str);//\u904d\u5386\u5de6\u6811\uff0c\u5de6\u6811\u4e3a\u7a7a\u65f6\u4e5f\u52a0\u62ec\u53f7 str += \")\"; } //2. \u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u7684\u503c\u5916\u52a0\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; _tree2str(root->right, str); str += \")\"; } } string tree2str(TreeNode* root) { string s; _tree2str(root, s); return s; } }; \u6267\u884c\u7ed3\u679c\uff1a","title":"\u6839\u636e\u4e8c\u53c9\u6811\u521b\u5efa\u5b57\u7b26\u4e32"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_1","text":"\u9898\u76ee\u94fe\u63a5 \u4f60\u9700\u8981\u91c7\u7528\u524d\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\uff0c\u5c06\u4e00\u4e2a\u4e8c\u53c9\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u7531\u62ec\u53f7\u548c\u6574\u6570\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u7a7a\u8282\u70b9\u5219\u7528\u4e00\u5bf9\u7a7a\u62ec\u53f7 \"()\" \u8868\u793a\u3002\u800c\u4e14\u4f60\u9700\u8981\u7701\u7565\u6240\u6709\u4e0d\u5f71\u54cd\u5b57\u7b26\u4e32\u4e0e\u539f\u59cb\u4e8c\u53c9\u6811\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u7684\u7a7a\u62ec\u53f7\u5bf9\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,4] 1 / \\ 2 3 / 4 \u8f93\u51fa: \"1(2(4))(3)\" \u89e3\u91ca: \u539f\u672c\u5c06\u662f\u201c1(2(4)())(3())\u201d\uff0c \u5728\u4f60\u7701\u7565\u6240\u6709\u4e0d\u5fc5\u8981\u7684\u7a7a\u62ec\u53f7\u5bf9\u4e4b\u540e\uff0c \u5b83\u5c06\u662f\u201c1(2(4))(3)\u201d\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 \u8f93\u51fa: \"1(2()(4))(3)\" \u89e3\u91ca: \u548c\u7b2c\u4e00\u4e2a\u793a\u4f8b\u76f8\u4f3c\uff0c \u9664\u4e86\u6211\u4eec\u4e0d\u80fd\u7701\u7565\u7b2c\u4e00\u4e2a\u5bf9\u62ec\u53f7\u6765\u4e2d\u65ad\u8f93\u5165\u548c\u8f93\u51fa\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u3002","title":"\u6839\u636e\u4e8c\u53c9\u6811\u521b\u5efa\u5b57\u7b26\u4e32"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_2","text":"\u4f20\u503c\u8fd4\u56de\u4e00\uff1a \u601d\u8def\uff1a \u6ca1\u6709\u8282\u70b9\uff0c\u8fd4\u56de\u7a7a \u6ca1\u6709\u5de6\u53f3\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u672c\u8282\u70b9\u503c \u6ca1\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u53ea\u9700\u8981\u5728\u5de6\u5b50\u6811\u8282\u70b9\u5916\u52a0\u62ec\u53f7\uff0c\u53f3\u5b50\u6811\u4e0d\u505a\u4efb\u4f55\u5904\u7406\uff1b \u53ea\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u5de6\u5b50\u6811\u8282\u70b9\u4e0d\u5b58\u5728\uff0c\u5148\u7ed9\u5de6\u5b50\u6811\u52a0\u4e00\u5c42\uff08\uff09,\u5728\u5bf9\u53f3\u5b50\u6811\u8fdb\u884c\u5904\u7406\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return \"\"; if(root->left == nullptr && root->right == nullptr) return to_string(root->val) ; if(root->right == nullptr) return to_string(root->val) + \"(\" + tree2str(root->left) + \")\"; return to_string(root->val) + \"(\" + tree2str(root->left) + \")\" + \"(\" + tree2str(root->right) + \")\"; } }; \u8fd0\u884c\u7ed3\u679c\uff1a \u9012\u5f52\u5206\u6790\u56fe\uff1a \u4f20\u503c\u8fd4\u56de\u4e8c\uff1a \u601d\u8def\uff1a \u82e5\u6839\u4e3a\u7a7a\uff0creturn\u7a7a \u82e5\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u6216\u8005\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u5de6\u6811\uff0c\u5e76\u5728\u5de6\u6811\u5916\u52a0\u62ec\u53f7\uff08\u5de6\u6811\u4e3a\u7a7a\u4e5f\u8981\u52a0\u62ec\u53f7\uff09 \u82e5\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u53f3\u5b50\u6811\uff0c\u53f3\u5b50\u6811\u5916\u52a0\u62ec\u53f7 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { //1.\u7a7a\u6811 if(root == nullptr) return \"\"; string str; str += to_string(root->val); //2.\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->left || root->right) str = str + \"(\" + tree2str(root->left) + \")\"; //3.\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->right) str = str + \"(\" + tree2str(root->right) + \")\"; return str; } }; \u9012\u5f52\u5206\u6790\u56fe\uff1a \u6539\u5199\u4e0a\u8ff0\u4ee3\u7801\uff0c\u53c2\u8003\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return string(); string str; str += to_string(root->val); //1.\u5de6\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u503c\u5916\u5e26\u62ec\u53f7\uff1b\u53f3\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u7684\u7a7a\u62ec\u53f7\u4e0d\u53ef\u7701\u7565 if(root->left != nullptr || root->right != nullptr) { str +=\"(\"; str += tree2str(root->left); str += \")\"; } //2.\u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u5916\u9762\u5e26\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; str += tree2str(root->right); str += \")\"; } return str; } }; \u4e0a\u8ff0\u4ee3\u7801\u5b58\u5728\u5f88\u5927\u95ee\u9898\uff0creturn str\u662f\u4f20\u503c\u8fd4\u56de\uff0c\u5b58\u5728\u5927\u91cf\u7684string\u6df1\u62f7\u8d1d\uff0c\u6240\u4ee5\u4e0b\u9762\u7ed9\u51fa\u53e6\u4e00\u79cd\u65b9\u6cd5\u3002","title":"\u601d\u8def\u4e00\uff1a\u4f20\u503c\u8fd4\u56de"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_3","text":"\u76f4\u63a5\u6539\u4e3a\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d\u6b21\u6570\u3002 \u5206\u6790\u5982\u4e0b\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void _tree2str(TreeNode* root, string& str) //\u901a\u8fc7\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d { if(root == nullptr) return ; str += to_string(root->val); //1.\u5de6\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u6570\u4e0d\u4e3a\u7a7a if(root->left != nullptr || root->right != nullptr) { str += \"(\"; _tree2str(root->left, str);//\u904d\u5386\u5de6\u6811\uff0c\u5de6\u6811\u4e3a\u7a7a\u65f6\u4e5f\u52a0\u62ec\u53f7 str += \")\"; } //2. \u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u7684\u503c\u5916\u52a0\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; _tree2str(root->right, str); str += \")\"; } } string tree2str(TreeNode* root) { string s; _tree2str(root, s); return s; } }; \u6267\u884c\u7ed3\u679c\uff1a","title":"\u601d\u8def\u4e8c\uff1a\u4f20\u5f15\u7528"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7ec3\u4e60\u9898\u603b\u7ed3 1 \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801 \u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> inorderTraversal(TreeNode* root) { //\u4e2d\u5e8f\u904d\u5386 \u6839\u5de6\u53f3 vector<int> v; TreeNode *cur = root; stack<TreeNode*> st; while(cur != nullptr || !st.empty()) { while(cur) { st.push(cur); cur = cur->left; } //\u6b64\u65f6\uff0ccur\u4e3a\u7a7a\uff0c\u904d\u5386\u5230\u7684\u5de6\u5b50\u6811\u4e3a\u7a7a\uff0c\u540e\u9762\u9700\u8981\u904d\u5386\u53f3\u5b50\u6811\u3002 TreeNode *top = st.top();//\u53d6\u51fa\u6808\u9876\u5143\u7d20 st.pop(); v.push_back(top->val); //\u6808\u9876\u5143\u7d20\u63d2\u5165\u5230vector\u4e2d\u4fdd\u5b58 cur = top->right;//\u904d\u5386\u53f3\u5b50\u6811 } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b 2 \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386","title":"LeetCode94\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#1","text":"\u9898\u76ee\u94fe\u63a5","title":"1 \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> inorderTraversal(TreeNode* root) { //\u4e2d\u5e8f\u904d\u5386 \u6839\u5de6\u53f3 vector<int> v; TreeNode *cur = root; stack<TreeNode*> st; while(cur != nullptr || !st.empty()) { while(cur) { st.push(cur); cur = cur->left; } //\u6b64\u65f6\uff0ccur\u4e3a\u7a7a\uff0c\u904d\u5386\u5230\u7684\u5de6\u5b50\u6811\u4e3a\u7a7a\uff0c\u540e\u9762\u9700\u8981\u904d\u5386\u53f3\u5b50\u6811\u3002 TreeNode *top = st.top();//\u53d6\u51fa\u6808\u9876\u5143\u7d20 st.pop(); v.push_back(top->val); //\u6808\u9876\u5143\u7d20\u63d2\u5165\u5230vector\u4e2d\u4fdd\u5b58 cur = top->right;//\u904d\u5386\u53f3\u5b50\u6811 } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#2","text":"","title":"2 \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0/","text":"\u4e00\u3001\u7b2c\u4e00\u5929 1 \u5b57\u6bcd\u53d8\u6362 \u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 ^= 32; \u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5c0f\u5199 : \u5b57\u7b26 |= 32; \u5c0f\u5199\u53d8\u5927\u5199\u3001\u5927\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 &= -33; \u4f8b\u5982\uff1a ASCII\u7801\u8868\u4e2d\u5927\u5199\u7684A\u662f65\uff0c\u5c0f\u5199\u7684a\u662f97\uff0c\u5b83\u4eec\u7684\u5dee\u662f32 65 | 32 \u8f6c\u4e3a\u4e8c\u8fdb\u5236\uff08\u63098\u4f4d\u6765\u7b97\uff09\u53ef\u4ee5\u5f97\u5230 0100 0001 | 0010 0000 = 0110 0001 = 97 = a \u4e8c\u3001day2 \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e int searchInsert(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; int ans = numsSize; while(left <= right) { int mid = ((right - left) >> 1) + left; if(target <= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; }","title":"\u4e00\u3001\u7b2c\u4e00\u5929"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0/#_1","text":"","title":"\u4e00\u3001\u7b2c\u4e00\u5929"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0/#1","text":"\u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 ^= 32; \u5927\u5199\u53d8\u5c0f\u5199\u3001\u5c0f\u5199\u53d8\u5c0f\u5199 : \u5b57\u7b26 |= 32; \u5c0f\u5199\u53d8\u5927\u5199\u3001\u5927\u5199\u53d8\u5927\u5199 : \u5b57\u7b26 &= -33; \u4f8b\u5982\uff1a ASCII\u7801\u8868\u4e2d\u5927\u5199\u7684A\u662f65\uff0c\u5c0f\u5199\u7684a\u662f97\uff0c\u5b83\u4eec\u7684\u5dee\u662f32 65 | 32 \u8f6c\u4e3a\u4e8c\u8fdb\u5236\uff08\u63098\u4f4d\u6765\u7b97\uff09\u53ef\u4ee5\u5f97\u5230 0100 0001 | 0010 0000 = 0110 0001 = 97 = a","title":"1 \u5b57\u6bcd\u53d8\u6362"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0/#day2","text":"","title":"\u4e8c\u3001day2"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E7%AE%B1/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0/#_2","text":"int searchInsert(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; int ans = numsSize; while(left <= right) { int mid = ((right - left) >> 1) + left; if(target <= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; }","title":"\u641c\u7d22\u63d2\u5165\u4f4d\u7f6e"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/01Pre-Post/","text":"per-post \u9898\u76ee\u94fe\u63a5 We are all familiar with pre-order, in-order and post-order traversals of binary trees. A common problem in data structure classes is to find the pre-order traversal of a binary tree when given the in-order and post-order traversals. Alternatively, you can find the post-order traversal when given the in-order and pre-order. However, in general you cannot determine the in-order traversal of a tree when given its pre-order and post-order traversals. Consider the four binary trees below: \u6211\u4eec\u90fd\u719f\u6089\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u3001\u6709\u5e8f\u548c\u540e\u5e8f\u904d\u5386\u3002\u6570\u636e\u7ed3\u6784\u7c7b\u4e2d\u7684\u4e00\u4e2a\u5e38\u89c1\u95ee\u9898\u662f\uff0c\u5728\u7ed9\u5b9a\u6709\u5e8f\u548c\u6709\u5e8f\u904d\u5386\u65f6\uff0c\u5982\u4f55\u627e\u5230\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u3002\u6216\u8005\uff0c\u60a8\u53ef\u4ee5\u5728\u7ed9\u5b9ain-order\u548cpre-order\u65f6\u627e\u5230post-order\u904d\u5386\u3002\u4f46\u662f\uff0c\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u5f53\u7ed9\u5b9a\u6811\u7684\u524d\u5e8f\u548c\u540e\u5e8f\u904d\u5386\u65f6\uff0c\u60a8\u4e0d\u80fd\u786e\u5b9a\u6811\u7684in-order\u3002\u8003\u8651\u4e0b\u9762\u7684\u56db\u68f5\u4e8c\u53c9\u6811: All of these trees have the same pre-order and post-order traversals. This phenomenon is not restricted to binary trees, but holds for general m-ary trees as well. \u6240\u6709\u8fd9\u4e9b\u6811\u5177\u6709\u76f8\u540c\u7684\u524d\u5e8f\u548c\u540e\u5e8f\u904d\u5386\u3002\u8fd9\u79cd\u73b0\u8c61\u4e0d\u4ec5\u9650\u4e8e\u4e8c\u53c9\u6811\uff0c\u4e5f\u9002\u7528\u4e8e\u4e00\u822c\u7684m\u53c9\u6811\u3002 \u8f93\u5165\u63cf\u8ff0\uff1a Input will consist of multiple problem instances. Each instance will consist of a line of the form m s1 s2, indicating that the trees are m-ary trees, s1 is the pre-order traversal and s2 is the post-order traversal.All traversal strings will consist of lowercase alphabetic characters. For all input instances, 1 <= m <= 20 and the length of s1 and s2 will be between 1 and 26 inclusive. If the length of s1 is k (which is the same as the length of s2, of course), the first k letters of the alphabet will be used in the strings. An input line of 0 will terminate the input. \u8f93\u5165\u5c06\u5305\u542b\u591a\u4e2a\u95ee\u9898\u5b9e\u4f8b\u3002\u6bcf\u4e2a\u5b9e\u4f8b\u5c06\u7531\u4e00\u884c\u5f62\u5f0f\u4e3a m s1 s2\u7684\u884c\u7ec4\u6210\uff0c\u8868\u793a\u6811\u662f m \u5143\u6811\uff0cs1\u662f\u524d\u5e8f\u904d\u5386\uff0cs2\u662f\u540e\u5e8f\u904d\u5386\u3002\u6240\u6709\u904d\u5386\u5b57\u7b26\u4e32\u5c06\u7531\u5c0f\u5199\u5b57\u6bcd\u7ec4\u6210\u3002\u5bf9\u4e8e\u6240\u6709\u8f93\u5165\u5b9e\u4f8b\uff0c1 < = m < = 20\uff0cs1\u548c s2\u7684\u957f\u5ea6\u4ecb\u4e8e1\u548c26\u4e4b\u95f4\u3002\u5982\u679c s1\u7684\u957f\u5ea6\u662f k (\u5f53\u7136\u8fd9\u548c s2\u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684) \uff0c\u5b57\u7b26\u4e32\u4e2d\u5c06\u4f7f\u7528\u5b57\u6bcd\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a k \u5b57\u6bcd\u3002\u8f93\u5165\u884c0\u5c06\u7ec8\u6b62\u8f93\u5165\u3002 \u8f93\u51fa\u63cf\u8ff0\uff1a For each problem instance, you should output one line containing the number of possible trees which would result in the pre-order and post-order traversals for the instance. All output values will be within the range of a 32-bit signed integer. For each problem instance, you are guaranteed that there is at least one tree with the given pre-order and post-order traversals. \u5bf9\u4e8e\u6bcf\u4e2a\u95ee\u9898\u5b9e\u4f8b\uff0c\u60a8\u5e94\u8be5\u8f93\u51fa\u4e00\u884c\uff0c\u5176\u4e2d\u5305\u542b\u53ef\u80fd\u5bfc\u81f4\u5b9e\u4f8b\u7684pre-order \u548cpost-order\u904d\u5386\u7684\u6811\u7684\u6570\u91cf\u3002\u6240\u6709\u8f93\u51fa\u503c\u90fd\u572832\u4f4d\u5e26\u7b26\u53f7\u6574\u6570\u7684\u8303\u56f4\u5185\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u95ee\u9898\u5b9e\u4f8b\uff0c\u53ef\u4ee5\u4fdd\u8bc1\u81f3\u5c11\u6709\u4e00\u68f5\u6811\u5177\u6709\u7ed9\u5b9a\u7684\u9884\u6392\u5e8f\u548c\u540e\u6392\u5e8f\u904d\u5386\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a C 2 abc cba 2 abc bca 10 abc bca 13 abejkcfghid jkebfghicda \u8f93\u51fa\uff1a 4 1 45 207352860","title":"per-post"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/01Pre-Post/#per-post","text":"\u9898\u76ee\u94fe\u63a5 We are all familiar with pre-order, in-order and post-order traversals of binary trees. A common problem in data structure classes is to find the pre-order traversal of a binary tree when given the in-order and post-order traversals. Alternatively, you can find the post-order traversal when given the in-order and pre-order. However, in general you cannot determine the in-order traversal of a tree when given its pre-order and post-order traversals. Consider the four binary trees below: \u6211\u4eec\u90fd\u719f\u6089\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u3001\u6709\u5e8f\u548c\u540e\u5e8f\u904d\u5386\u3002\u6570\u636e\u7ed3\u6784\u7c7b\u4e2d\u7684\u4e00\u4e2a\u5e38\u89c1\u95ee\u9898\u662f\uff0c\u5728\u7ed9\u5b9a\u6709\u5e8f\u548c\u6709\u5e8f\u904d\u5386\u65f6\uff0c\u5982\u4f55\u627e\u5230\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u3002\u6216\u8005\uff0c\u60a8\u53ef\u4ee5\u5728\u7ed9\u5b9ain-order\u548cpre-order\u65f6\u627e\u5230post-order\u904d\u5386\u3002\u4f46\u662f\uff0c\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u5f53\u7ed9\u5b9a\u6811\u7684\u524d\u5e8f\u548c\u540e\u5e8f\u904d\u5386\u65f6\uff0c\u60a8\u4e0d\u80fd\u786e\u5b9a\u6811\u7684in-order\u3002\u8003\u8651\u4e0b\u9762\u7684\u56db\u68f5\u4e8c\u53c9\u6811: All of these trees have the same pre-order and post-order traversals. This phenomenon is not restricted to binary trees, but holds for general m-ary trees as well. \u6240\u6709\u8fd9\u4e9b\u6811\u5177\u6709\u76f8\u540c\u7684\u524d\u5e8f\u548c\u540e\u5e8f\u904d\u5386\u3002\u8fd9\u79cd\u73b0\u8c61\u4e0d\u4ec5\u9650\u4e8e\u4e8c\u53c9\u6811\uff0c\u4e5f\u9002\u7528\u4e8e\u4e00\u822c\u7684m\u53c9\u6811\u3002 \u8f93\u5165\u63cf\u8ff0\uff1a Input will consist of multiple problem instances. Each instance will consist of a line of the form m s1 s2, indicating that the trees are m-ary trees, s1 is the pre-order traversal and s2 is the post-order traversal.All traversal strings will consist of lowercase alphabetic characters. For all input instances, 1 <= m <= 20 and the length of s1 and s2 will be between 1 and 26 inclusive. If the length of s1 is k (which is the same as the length of s2, of course), the first k letters of the alphabet will be used in the strings. An input line of 0 will terminate the input. \u8f93\u5165\u5c06\u5305\u542b\u591a\u4e2a\u95ee\u9898\u5b9e\u4f8b\u3002\u6bcf\u4e2a\u5b9e\u4f8b\u5c06\u7531\u4e00\u884c\u5f62\u5f0f\u4e3a m s1 s2\u7684\u884c\u7ec4\u6210\uff0c\u8868\u793a\u6811\u662f m \u5143\u6811\uff0cs1\u662f\u524d\u5e8f\u904d\u5386\uff0cs2\u662f\u540e\u5e8f\u904d\u5386\u3002\u6240\u6709\u904d\u5386\u5b57\u7b26\u4e32\u5c06\u7531\u5c0f\u5199\u5b57\u6bcd\u7ec4\u6210\u3002\u5bf9\u4e8e\u6240\u6709\u8f93\u5165\u5b9e\u4f8b\uff0c1 < = m < = 20\uff0cs1\u548c s2\u7684\u957f\u5ea6\u4ecb\u4e8e1\u548c26\u4e4b\u95f4\u3002\u5982\u679c s1\u7684\u957f\u5ea6\u662f k (\u5f53\u7136\u8fd9\u548c s2\u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684) \uff0c\u5b57\u7b26\u4e32\u4e2d\u5c06\u4f7f\u7528\u5b57\u6bcd\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a k \u5b57\u6bcd\u3002\u8f93\u5165\u884c0\u5c06\u7ec8\u6b62\u8f93\u5165\u3002 \u8f93\u51fa\u63cf\u8ff0\uff1a For each problem instance, you should output one line containing the number of possible trees which would result in the pre-order and post-order traversals for the instance. All output values will be within the range of a 32-bit signed integer. For each problem instance, you are guaranteed that there is at least one tree with the given pre-order and post-order traversals. \u5bf9\u4e8e\u6bcf\u4e2a\u95ee\u9898\u5b9e\u4f8b\uff0c\u60a8\u5e94\u8be5\u8f93\u51fa\u4e00\u884c\uff0c\u5176\u4e2d\u5305\u542b\u53ef\u80fd\u5bfc\u81f4\u5b9e\u4f8b\u7684pre-order \u548cpost-order\u904d\u5386\u7684\u6811\u7684\u6570\u91cf\u3002\u6240\u6709\u8f93\u51fa\u503c\u90fd\u572832\u4f4d\u5e26\u7b26\u53f7\u6574\u6570\u7684\u8303\u56f4\u5185\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u95ee\u9898\u5b9e\u4f8b\uff0c\u53ef\u4ee5\u4fdd\u8bc1\u81f3\u5c11\u6709\u4e00\u68f5\u6811\u5177\u6709\u7ed9\u5b9a\u7684\u9884\u6392\u5e8f\u548c\u540e\u6392\u5e8f\u904d\u5386\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a C 2 abc cba 2 abc bca 10 abc bca 13 abejkcfghid jkebfghicda \u8f93\u51fa\uff1a 4 1 45 207352860","title":"per-post"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/","text":"17\u7535\u8bdd\u53f7\u7801\u7684\u7ec4\u5408 \u7535\u8bdd\u53f7\u7801\u7684\u5b57\u6bcd\u7ec4\u5408 \uff0c \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b\u6570\u5b572-9\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u6240\u6709\u5b83\u80fd\u8868\u793a\u7684\u5b57\u6bcd\u7ec4\u5408\u3002\u7b54\u6848\u53ef\u4ee5\u6309\u4efb\u610f\u987a\u5e8f\u8fd4\u56de\u3002\u6570\u5b57\u548c\u5b57\u6bcd\u5bf9\u5e94\u7684\u6620\u5c04\u5982\u4e0b\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1adigits = \"23\" \u8f93\u51fa\uff1a[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1adigits = \"\" \u8f93\u51fa\uff1a[] \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1adigits = \"2\" \u8f93\u51fa\uff1a[\"a\",\"b\",\"c\"] unorder_map\u601d\u8def class Solution { public: vector<string> letterCombinations(string digits) { vector<string> combinations; if (digits.empty()) { return combinations; } unordered_map<char, string> phoneMap{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations; } void backtrack(vector<string>& combinations, const unordered_map<char, string>& phoneMap, const string& digits, int index, string& combination) { if (index == digits.length()) { combinations.push_back(combination); } else { char digit = digits[index]; const string& letters = phoneMap.at(digit); for (const char& letter: letters) { combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination); combination.pop_back(); } } } }; \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 vector & string class Solution { public: vector<string> phone={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> letterCombinations(string digits) { if(digits.size() == 0) return {}; vector<string> res; res.push_back(\"\"); for(char digit : digits) { vector<string> temp; for(string s : res) // s\u662f\u524d\u9762\u4e00\u8f6e\u5b57\u7b26\u9009\u62e9\u7ed3\u679c { for(char candidate : phone[digit - '0']) //candidate \u662f\u672c\u8f6e\u5f85\u9009\u62e9\u7684\u5b57\u7b26 { temp.push_back(s + candidate); } } res.swap(temp); //\u4ea4\u6362temp \u548c res } return res; } }; \u7406\u89e3swap","title":"17\u7535\u8bdd\u53f7\u7801\u7684\u7ec4\u5408"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/#17","text":"\u7535\u8bdd\u53f7\u7801\u7684\u5b57\u6bcd\u7ec4\u5408 \uff0c \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b\u6570\u5b572-9\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u6240\u6709\u5b83\u80fd\u8868\u793a\u7684\u5b57\u6bcd\u7ec4\u5408\u3002\u7b54\u6848\u53ef\u4ee5\u6309\u4efb\u610f\u987a\u5e8f\u8fd4\u56de\u3002\u6570\u5b57\u548c\u5b57\u6bcd\u5bf9\u5e94\u7684\u6620\u5c04\u5982\u4e0b\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1adigits = \"23\" \u8f93\u51fa\uff1a[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1adigits = \"\" \u8f93\u51fa\uff1a[] \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1adigits = \"2\" \u8f93\u51fa\uff1a[\"a\",\"b\",\"c\"]","title":"17\u7535\u8bdd\u53f7\u7801\u7684\u7ec4\u5408"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/#unorder_map","text":"class Solution { public: vector<string> letterCombinations(string digits) { vector<string> combinations; if (digits.empty()) { return combinations; } unordered_map<char, string> phoneMap{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations; } void backtrack(vector<string>& combinations, const unordered_map<char, string>& phoneMap, const string& digits, int index, string& combination) { if (index == digits.length()) { combinations.push_back(combination); } else { char digit = digits[index]; const string& letters = phoneMap.at(digit); for (const char& letter: letters) { combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination); combination.pop_back(); } } } }; \u4f5c\u8005\uff1aLeetCode-Solution \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"unorder_map\u601d\u8def"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/#vector-string","text":"class Solution { public: vector<string> phone={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> letterCombinations(string digits) { if(digits.size() == 0) return {}; vector<string> res; res.push_back(\"\"); for(char digit : digits) { vector<string> temp; for(string s : res) // s\u662f\u524d\u9762\u4e00\u8f6e\u5b57\u7b26\u9009\u62e9\u7ed3\u679c { for(char candidate : phone[digit - '0']) //candidate \u662f\u672c\u8f6e\u5f85\u9009\u62e9\u7684\u5b57\u7b26 { temp.push_back(s + candidate); } } res.swap(temp); //\u4ea4\u6362temp \u548c res } return res; } }; \u7406\u89e3swap","title":"vector &amp; string"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u6309 \u5c42\u5e8f\u904d\u5386 \u5f97\u5230\u7684\u8282\u70b9\u503c\u3002 \uff08\u5373\u9010\u5c42\u5730\uff0c\u4ece\u5de6\u5230\u53f3\u8bbf\u95ee\u6240\u6709\u8282\u70b9\uff09\u3002 \u793a\u4f8b\uff1a \u4e8c\u53c9\u6811\uff1a[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 \u8fd4\u56de\u5176\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff1a [ [3], [9,20], [15,7] ] \u4ee3\u7801\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { if(root == nullptr) //root\u4e3a\u7a7a return vector<vector<int>>(); queue<TreeNode*> q; //\u961f\u5217 int levelSize = 1; q.push(root); //push\u6839\u7ed3\u70b9 vector<vector<int>> vv; while(!q.empty()) //\u961f\u5217\u4e0d\u4e3a\u7a7a { //\u6309\u5c42\u51fa vector<int> v; for(int i = 0; i < levelSize; ++i) { TreeNode* front = q.front(); q.pop(); v.push_back(front->val); if(front->left) { q.push(front->left); } if(front->right) { q.push(front->right); } } //\u51fa\u5b8c\u4e00\u5c42\uff0c\u4e0b\u4e00\u5c42\u5165\u961f\u5217 levelSize = q.size(); vv.push_back(v); } return vv; } };","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u6309 \u5c42\u5e8f\u904d\u5386 \u5f97\u5230\u7684\u8282\u70b9\u503c\u3002 \uff08\u5373\u9010\u5c42\u5730\uff0c\u4ece\u5de6\u5230\u53f3\u8bbf\u95ee\u6240\u6709\u8282\u70b9\uff09\u3002 \u793a\u4f8b\uff1a \u4e8c\u53c9\u6811\uff1a[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 \u8fd4\u56de\u5176\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff1a [ [3], [9,20], [15,7] ] \u4ee3\u7801\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { if(root == nullptr) //root\u4e3a\u7a7a return vector<vector<int>>(); queue<TreeNode*> q; //\u961f\u5217 int levelSize = 1; q.push(root); //push\u6839\u7ed3\u70b9 vector<vector<int>> vv; while(!q.empty()) //\u961f\u5217\u4e0d\u4e3a\u7a7a { //\u6309\u5c42\u51fa vector<int> v; for(int i = 0; i < levelSize; ++i) { TreeNode* front = q.front(); q.pop(); v.push_back(front->val); if(front->left) { q.push(front->left); } if(front->right) { q.push(front->right); } } //\u51fa\u5b8c\u4e00\u5c42\uff0c\u4e0b\u4e00\u5c42\u5165\u961f\u5217 levelSize = q.size(); vv.push_back(v); } return vv; } };","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801 \u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> preorderTraversal(TreeNode* root) { vector<int> v; if(root == nullptr) return v; stack<TreeNode*> st; TreeNode* cur = root; while(cur !=nullptr || !st.empty()) { while(cur != nullptr){ v.push_back(cur->val); st.push(cur); cur = cur->left; } TreeNode* top = st.top();//\u53d6\u6808\u9876\u5143\u7d20 st.pop(); cur = top->right; } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/#_2","text":"\u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> preorderTraversal(TreeNode* root) { vector<int> v; if(root == nullptr) return v; stack<TreeNode*> st; TreeNode* cur = root; while(cur !=nullptr || !st.empty()) { while(cur != nullptr){ v.push_back(cur->val); st.push(cur); cur = cur->left; } TreeNode* top = st.top();//\u53d6\u6808\u9876\u5143\u7d20 st.pop(); cur = top->right; } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801 \u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> postorderTraversal(TreeNode* root) { TreeNode *cur = root; vector<int> v; stack<TreeNode*> st; TreeNode *prev = nullptr; while(cur != nullptr || !st.empty()){ while(cur){ st.push(cur); cur = cur->left; } //\u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c\u6216\u53f3\u5b50\u6811\u5df2\u7ecf\u8bbf\u95ee\u5b8c TreeNode *top = st.top(); if(top->right == nullptr || top->right == prev){ st.pop(); v.push_back(top->val); prev = top; } else { cur = top->right; } } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#_2","text":"\u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> postorderTraversal(TreeNode* root) { TreeNode *cur = root; vector<int> v; stack<TreeNode*> st; TreeNode *prev = nullptr; while(cur != nullptr || !st.empty()){ while(cur){ st.push(cur); cur = cur->left; } //\u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c\u6216\u53f3\u5b50\u6811\u5df2\u7ecf\u8bbf\u95ee\u5b8c TreeNode *top = st.top(); if(top->right == nullptr || top->right == prev){ st.pop(); v.push_back(top->val); prev = top; } else { cur = top->right; } } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","text":"\u9898\u76ee LeetCode\u9898\u76ee\u94fe\u63a5 \u9012\u5f52\u6cd5\u53c2\u8003 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //1.\u6839\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u6216\u6839\u7ed3\u70b9\u662f\u5176\u4e2d\u4e00\u4e2a\u6216\u4e24\u4e2a\u8282\u70b9 \u8fd4\u56de \u6839\u7ed3\u70b9 if(root == nullptr || root == p || root == q) return root; //2. \u9012\u5f52\u904d\u5386\u5de6\u53f3\u5b50\u6811\uff0c\u627e\u8282\u70b9 TreeNode *left = lowestCommonAncestor(root->left, p, q); TreeNode *right = lowestCommonAncestor(root->right, p, q); //3.\u82e5left\u4e14right\u4e0d\u7a7a\uff0c\u8bf4\u660ep\uff0cq\u5c31\u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811\u4e2d if(left != nullptr && right != nullptr) return root; else if((left != nullptr && right == nullptr) || (left == nullptr && right != nullptr) ) { //4. \u82e5\u5de6\u53f3\u5b50\u6811\u5176\u4e2d\u4e00\u4e2a\u4e0d\u7a7a\uff0c\u5c31\u8fd4\u56de\u6b64\u975e\u7a7a\u8282\u70b9 return left ? left : right; } return nullptr; } }; \u53c2\u8003\u601d\u8def\u56fe\uff1a \u53c2\u8003\u601d\u8def \uff1a\u70b9\u51fb\u94fe\u63a5","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#_1","text":"LeetCode\u9898\u76ee\u94fe\u63a5","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#_2","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //1.\u6839\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u6216\u6839\u7ed3\u70b9\u662f\u5176\u4e2d\u4e00\u4e2a\u6216\u4e24\u4e2a\u8282\u70b9 \u8fd4\u56de \u6839\u7ed3\u70b9 if(root == nullptr || root == p || root == q) return root; //2. \u9012\u5f52\u904d\u5386\u5de6\u53f3\u5b50\u6811\uff0c\u627e\u8282\u70b9 TreeNode *left = lowestCommonAncestor(root->left, p, q); TreeNode *right = lowestCommonAncestor(root->right, p, q); //3.\u82e5left\u4e14right\u4e0d\u7a7a\uff0c\u8bf4\u660ep\uff0cq\u5c31\u5206\u5e03\u5728\u5de6\u53f3\u5b50\u6811\u4e2d if(left != nullptr && right != nullptr) return root; else if((left != nullptr && right == nullptr) || (left == nullptr && right != nullptr) ) { //4. \u82e5\u5de6\u53f3\u5b50\u6811\u5176\u4e2d\u4e00\u4e2a\u4e0d\u7a7a\uff0c\u5c31\u8fd4\u56de\u6b64\u975e\u7a7a\u8282\u70b9 return left ? left : right; } return nullptr; } }; \u53c2\u8003\u601d\u8def\u56fe\uff1a \u53c2\u8003\u601d\u8def \uff1a\u70b9\u51fb\u94fe\u63a5","title":"\u9012\u5f52\u6cd5\u53c2\u8003"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","text":"\u9898\u76ee \u9898\u76ee\u94fe\u63a5 \u4f60\u9700\u8981\u91c7\u7528\u524d\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\uff0c\u5c06\u4e00\u4e2a\u4e8c\u53c9\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u7531\u62ec\u53f7\u548c\u6574\u6570\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u7a7a\u8282\u70b9\u5219\u7528\u4e00\u5bf9\u7a7a\u62ec\u53f7 \"()\" \u8868\u793a\u3002\u800c\u4e14\u4f60\u9700\u8981\u7701\u7565\u6240\u6709\u4e0d\u5f71\u54cd\u5b57\u7b26\u4e32\u4e0e\u539f\u59cb\u4e8c\u53c9\u6811\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u7684\u7a7a\u62ec\u53f7\u5bf9\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,4] 1 / \\ 2 3 / 4 \u8f93\u51fa: \"1(2(4))(3)\" \u89e3\u91ca: \u539f\u672c\u5c06\u662f\u201c1(2(4)())(3())\u201d\uff0c \u5728\u4f60\u7701\u7565\u6240\u6709\u4e0d\u5fc5\u8981\u7684\u7a7a\u62ec\u53f7\u5bf9\u4e4b\u540e\uff0c \u5b83\u5c06\u662f\u201c1(2(4))(3)\u201d\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 \u8f93\u51fa: \"1(2()(4))(3)\" \u89e3\u91ca: \u548c\u7b2c\u4e00\u4e2a\u793a\u4f8b\u76f8\u4f3c\uff0c \u9664\u4e86\u6211\u4eec\u4e0d\u80fd\u7701\u7565\u7b2c\u4e00\u4e2a\u5bf9\u62ec\u53f7\u6765\u4e2d\u65ad\u8f93\u5165\u548c\u8f93\u51fa\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u3002 \u5206\u6790 \u601d\u8def\u4e00\uff1a\u4f20\u503c\u8fd4\u56de \u4f20\u503c\u8fd4\u56de\u4e00\uff1a \u601d\u8def\uff1a \u6ca1\u6709\u8282\u70b9\uff0c\u8fd4\u56de\u7a7a \u6ca1\u6709\u5de6\u53f3\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u672c\u8282\u70b9\u503c \u6ca1\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u53ea\u9700\u8981\u5728\u5de6\u5b50\u6811\u8282\u70b9\u5916\u52a0\u62ec\u53f7\uff0c\u53f3\u5b50\u6811\u4e0d\u505a\u4efb\u4f55\u5904\u7406\uff1b \u53ea\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u5de6\u5b50\u6811\u8282\u70b9\u4e0d\u5b58\u5728\uff0c\u5148\u7ed9\u5de6\u5b50\u6811\u52a0\u4e00\u5c42\uff08\uff09,\u5728\u5bf9\u53f3\u5b50\u6811\u8fdb\u884c\u5904\u7406\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return \"\"; if(root->left == nullptr && root->right == nullptr) return to_string(root->val) ; if(root->right == nullptr) return to_string(root->val) + \"(\" + tree2str(root->left) + \")\"; return to_string(root->val) + \"(\" + tree2str(root->left) + \")\" + \"(\" + tree2str(root->right) + \")\"; } }; \u8fd0\u884c\u7ed3\u679c\uff1a \u9012\u5f52\u5206\u6790\u56fe\uff1a \u4f20\u503c\u8fd4\u56de\u4e8c\uff1a \u601d\u8def\uff1a \u82e5\u6839\u4e3a\u7a7a\uff0creturn\u7a7a \u82e5\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u6216\u8005\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u5de6\u6811\uff0c\u5e76\u5728\u5de6\u6811\u5916\u52a0\u62ec\u53f7\uff08\u5de6\u6811\u4e3a\u7a7a\u4e5f\u8981\u52a0\u62ec\u53f7\uff09 \u82e5\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u53f3\u5b50\u6811\uff0c\u53f3\u5b50\u6811\u5916\u52a0\u62ec\u53f7 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { //1.\u7a7a\u6811 if(root == nullptr) return \"\"; string str; str += to_string(root->val); //2.\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->left || root->right) str = str + \"(\" + tree2str(root->left) + \")\"; //3.\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->right) str = str + \"(\" + tree2str(root->right) + \")\"; return str; } }; \u9012\u5f52\u5206\u6790\u56fe\uff1a \u6539\u5199\u4e0a\u8ff0\u4ee3\u7801\uff0c\u53c2\u8003\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return string(); string str; str += to_string(root->val); //1.\u5de6\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u503c\u5916\u5e26\u62ec\u53f7\uff1b\u53f3\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u7684\u7a7a\u62ec\u53f7\u4e0d\u53ef\u7701\u7565 if(root->left != nullptr || root->right != nullptr) { str +=\"(\"; str += tree2str(root->left); str += \")\"; } //2.\u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u5916\u9762\u5e26\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; str += tree2str(root->right); str += \")\"; } return str; } }; \u4e0a\u8ff0\u4ee3\u7801\u5b58\u5728\u5f88\u5927\u95ee\u9898\uff0creturn str\u662f\u4f20\u503c\u8fd4\u56de\uff0c\u5b58\u5728\u5927\u91cf\u7684string\u6df1\u62f7\u8d1d\uff0c\u6240\u4ee5\u4e0b\u9762\u7ed9\u51fa\u53e6\u4e00\u79cd\u65b9\u6cd5\u3002 \u601d\u8def\u4e8c\uff1a\u4f20\u5f15\u7528 \u76f4\u63a5\u6539\u4e3a\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d\u6b21\u6570\u3002 \u5206\u6790\u5982\u4e0b\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void _tree2str(TreeNode* root, string& str) //\u901a\u8fc7\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d { if(root == nullptr) return ; str += to_string(root->val); //1.\u5de6\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u6570\u4e0d\u4e3a\u7a7a if(root->left != nullptr || root->right != nullptr) { str += \"(\"; _tree2str(root->left, str);//\u904d\u5386\u5de6\u6811\uff0c\u5de6\u6811\u4e3a\u7a7a\u65f6\u4e5f\u52a0\u62ec\u53f7 str += \")\"; } //2. \u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u7684\u503c\u5916\u52a0\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; _tree2str(root->right, str); str += \")\"; } } string tree2str(TreeNode* root) { string s; _tree2str(root, s); return s; } }; \u6267\u884c\u7ed3\u679c\uff1a","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_1","text":"\u9898\u76ee\u94fe\u63a5 \u4f60\u9700\u8981\u91c7\u7528\u524d\u5e8f\u904d\u5386\u7684\u65b9\u5f0f\uff0c\u5c06\u4e00\u4e2a\u4e8c\u53c9\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u7531\u62ec\u53f7\u548c\u6574\u6570\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u7a7a\u8282\u70b9\u5219\u7528\u4e00\u5bf9\u7a7a\u62ec\u53f7 \"()\" \u8868\u793a\u3002\u800c\u4e14\u4f60\u9700\u8981\u7701\u7565\u6240\u6709\u4e0d\u5f71\u54cd\u5b57\u7b26\u4e32\u4e0e\u539f\u59cb\u4e8c\u53c9\u6811\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u7684\u7a7a\u62ec\u53f7\u5bf9\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,4] 1 / \\ 2 3 / 4 \u8f93\u51fa: \"1(2(4))(3)\" \u89e3\u91ca: \u539f\u672c\u5c06\u662f\u201c1(2(4)())(3())\u201d\uff0c \u5728\u4f60\u7701\u7565\u6240\u6709\u4e0d\u5fc5\u8981\u7684\u7a7a\u62ec\u53f7\u5bf9\u4e4b\u540e\uff0c \u5b83\u5c06\u662f\u201c1(2(4))(3)\u201d\u3002 \u8f93\u5165: \u4e8c\u53c9\u6811: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 \u8f93\u51fa: \"1(2()(4))(3)\" \u89e3\u91ca: \u548c\u7b2c\u4e00\u4e2a\u793a\u4f8b\u76f8\u4f3c\uff0c \u9664\u4e86\u6211\u4eec\u4e0d\u80fd\u7701\u7565\u7b2c\u4e00\u4e2a\u5bf9\u62ec\u53f7\u6765\u4e2d\u65ad\u8f93\u5165\u548c\u8f93\u51fa\u4e4b\u95f4\u7684\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb\u3002","title":"\u9898\u76ee"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_2","text":"","title":"\u5206\u6790"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_3","text":"\u4f20\u503c\u8fd4\u56de\u4e00\uff1a \u601d\u8def\uff1a \u6ca1\u6709\u8282\u70b9\uff0c\u8fd4\u56de\u7a7a \u6ca1\u6709\u5de6\u53f3\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u672c\u8282\u70b9\u503c \u6ca1\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u53ea\u9700\u8981\u5728\u5de6\u5b50\u6811\u8282\u70b9\u5916\u52a0\u62ec\u53f7\uff0c\u53f3\u5b50\u6811\u4e0d\u505a\u4efb\u4f55\u5904\u7406\uff1b \u53ea\u6709\u53f3\u5b50\u6811\u8282\u70b9\uff0c\u5de6\u5b50\u6811\u8282\u70b9\u4e0d\u5b58\u5728\uff0c\u5148\u7ed9\u5de6\u5b50\u6811\u52a0\u4e00\u5c42\uff08\uff09,\u5728\u5bf9\u53f3\u5b50\u6811\u8fdb\u884c\u5904\u7406\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return \"\"; if(root->left == nullptr && root->right == nullptr) return to_string(root->val) ; if(root->right == nullptr) return to_string(root->val) + \"(\" + tree2str(root->left) + \")\"; return to_string(root->val) + \"(\" + tree2str(root->left) + \")\" + \"(\" + tree2str(root->right) + \")\"; } }; \u8fd0\u884c\u7ed3\u679c\uff1a \u9012\u5f52\u5206\u6790\u56fe\uff1a \u4f20\u503c\u8fd4\u56de\u4e8c\uff1a \u601d\u8def\uff1a \u82e5\u6839\u4e3a\u7a7a\uff0creturn\u7a7a \u82e5\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u6216\u8005\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u5de6\u6811\uff0c\u5e76\u5728\u5de6\u6811\u5916\u52a0\u62ec\u53f7\uff08\u5de6\u6811\u4e3a\u7a7a\u4e5f\u8981\u52a0\u62ec\u53f7\uff09 \u82e5\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u9012\u5f52\u904d\u5386\u53f3\u5b50\u6811\uff0c\u53f3\u5b50\u6811\u5916\u52a0\u62ec\u53f7 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { //1.\u7a7a\u6811 if(root == nullptr) return \"\"; string str; str += to_string(root->val); //2.\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->left || root->right) str = str + \"(\" + tree2str(root->left) + \")\"; //3.\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a if(root->right) str = str + \"(\" + tree2str(root->right) + \")\"; return str; } }; \u9012\u5f52\u5206\u6790\u56fe\uff1a \u6539\u5199\u4e0a\u8ff0\u4ee3\u7801\uff0c\u53c2\u8003\uff1b /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { if(root == nullptr) return string(); string str; str += to_string(root->val); //1.\u5de6\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u503c\u5916\u5e26\u62ec\u53f7\uff1b\u53f3\u4e0d\u4e3a\u7a7a\uff0c\u5de6\u4e3a\u7a7a\uff0c\u5de6\u8fb9\u7684\u7a7a\u62ec\u53f7\u4e0d\u53ef\u7701\u7565 if(root->left != nullptr || root->right != nullptr) { str +=\"(\"; str += tree2str(root->left); str += \")\"; } //2.\u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u5916\u9762\u5e26\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; str += tree2str(root->right); str += \")\"; } return str; } }; \u4e0a\u8ff0\u4ee3\u7801\u5b58\u5728\u5f88\u5927\u95ee\u9898\uff0creturn str\u662f\u4f20\u503c\u8fd4\u56de\uff0c\u5b58\u5728\u5927\u91cf\u7684string\u6df1\u62f7\u8d1d\uff0c\u6240\u4ee5\u4e0b\u9762\u7ed9\u51fa\u53e6\u4e00\u79cd\u65b9\u6cd5\u3002","title":"\u601d\u8def\u4e00\uff1a\u4f20\u503c\u8fd4\u56de"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode606%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#_4","text":"\u76f4\u63a5\u6539\u4e3a\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d\u6b21\u6570\u3002 \u5206\u6790\u5982\u4e0b\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void _tree2str(TreeNode* root, string& str) //\u901a\u8fc7\u4f20\u5f15\u7528\u8fd4\u56de\uff0c\u51cf\u5c11\u6df1\u62f7\u8d1d { if(root == nullptr) return ; str += to_string(root->val); //1.\u5de6\u6811\u4e0d\u4e3a\u7a7a \u6216\u8005 \u53f3\u6570\u4e0d\u4e3a\u7a7a if(root->left != nullptr || root->right != nullptr) { str += \"(\"; _tree2str(root->left, str);//\u904d\u5386\u5de6\u6811\uff0c\u5de6\u6811\u4e3a\u7a7a\u65f6\u4e5f\u52a0\u62ec\u53f7 str += \")\"; } //2. \u53f3\u6811\u4e0d\u4e3a\u7a7a\uff0c\u53f3\u6811\u7684\u503c\u5916\u52a0\u62ec\u53f7 if(root->right != nullptr) { str += \"(\"; _tree2str(root->right, str); str += \")\"; } } string tree2str(TreeNode* root) { string s; _tree2str(root, s); return s; } }; \u6267\u884c\u7ed3\u679c\uff1a","title":"\u601d\u8def\u4e8c\uff1a\u4f20\u5f15\u7528"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 \u9898\u76ee\u94fe\u63a5 \u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801 \u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> inorderTraversal(TreeNode* root) { vector<int> v; TreeNode *cur = root; stack<TreeNode*> st; while(cur != nullptr || !st.empty()) { while(cur) { st.push(cur); cur = cur->left; } TreeNode *top = st.top(); st.pop(); v.push_back(top->val); cur = top->right; } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#_1","text":"\u9898\u76ee\u94fe\u63a5","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%BB%83%E4%B9%A0-BackUp/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/#_2","text":"\u5206\u6790\u56fe\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> inorderTraversal(TreeNode* root) { vector<int> v; TreeNode *cur = root; stack<TreeNode*> st; while(cur != nullptr || !st.empty()) { while(cur) { st.push(cur); cur = cur->left; } TreeNode *top = st.top(); st.pop(); v.push_back(top->val); cur = top->right; } return v; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6$O(n)$\uff1b","title":"\u975e\u9012\u5f52\u53c2\u8003\u4ee3\u7801"}]}